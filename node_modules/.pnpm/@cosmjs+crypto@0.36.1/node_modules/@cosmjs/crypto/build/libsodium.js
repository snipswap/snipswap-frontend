"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = void 0;
exports.isArgon2idOptions = isArgon2idOptions;
const utils_1 = require("@cosmjs/utils");
const chacha_js_1 = require("@noble/ciphers/chacha.js");
const ed25519_js_1 = require("@noble/curves/ed25519.js");
const hash_wasm_1 = require("hash-wasm");
function isArgon2idOptions(thing) {
    if (!(0, utils_1.isNonNullObject)(thing))
        return false;
    if (typeof thing.outputLength !== "number")
        return false;
    if (typeof thing.opsLimit !== "number")
        return false;
    if (typeof thing.memLimitKib !== "number")
        return false;
    return true;
}
class Argon2id {
    static async execute(password, salt, options) {
        const opts = {
            password,
            salt,
            outputType: "binary",
            iterations: options.opsLimit,
            memorySize: options.memLimitKib,
            parallelism: 1, // no parallelism allowed, just like libsodium
            hashLength: options.outputLength,
        };
        if (salt.length !== 16) {
            throw new Error(`Got invalid salt length ${salt.length}. Must be 16.`);
        }
        const hash = await (0, hash_wasm_1.argon2id)(opts);
        // guaranteed by outputType: 'binary'
        (0, utils_1.assert)(typeof hash !== "string");
        return hash;
    }
}
exports.Argon2id = Argon2id;
class Ed25519Keypair {
    // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
    static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
            throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
    }
    privkey;
    pubkey;
    constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
    }
    toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
    }
}
exports.Ed25519Keypair = Ed25519Keypair;
class Ed25519 {
    /**
     * Generates a keypair deterministically from a given 32 bytes seed.
     *
     * This seed equals the Ed25519 private key.
     * For implementation details see crypto_sign_seed_keypair in
     * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
     * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */
    static async makeKeypair(privKey) {
        const pubKey = ed25519_js_1.ed25519.getPublicKey(privKey);
        return new Ed25519Keypair(privKey, pubKey);
    }
    static async createSignature(message, keyPair) {
        return ed25519_js_1.ed25519.sign(message, keyPair.privkey);
    }
    static async verifySignature(signature, message, pubkey) {
        return ed25519_js_1.ed25519.verify(signature, message, pubkey);
    }
}
exports.Ed25519 = Ed25519;
/**
 * Nonce length in bytes for all flavours of XChaCha20.
 *
 * @see https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xchacha20#notes
 */
exports.xchacha20NonceLength = 24;
class Xchacha20poly1305Ietf {
    static async encrypt(message, key, nonce) {
        const additionalAuthenticatedData = undefined;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.encrypt(message);
    }
    static async decrypt(ciphertext, key, nonce) {
        const additionalAuthenticatedData = undefined;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.decrypt(ciphertext);
    }
}
exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
//# sourceMappingURL=libsodium.js.map