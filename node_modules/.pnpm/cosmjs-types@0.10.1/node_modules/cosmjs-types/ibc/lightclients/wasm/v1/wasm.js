"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checksums = exports.ClientMessage = exports.ConsensusState = exports.ClientState = exports.protobufPackage = void 0;
/* eslint-disable */
const client_1 = require("../../../core/client/v1/client");
const binary_1 = require("../../../../binary");
const helpers_1 = require("../../../../helpers");
exports.protobufPackage = "ibc.lightclients.wasm.v1";
function createBaseClientState() {
    return {
        data: new Uint8Array(),
        checksum: new Uint8Array(),
        latestHeight: client_1.Height.fromPartial({}),
    };
}
exports.ClientState = {
    typeUrl: "/ibc.lightclients.wasm.v1.ClientState",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        if (message.checksum.length !== 0) {
            writer.uint32(18).bytes(message.checksum);
        }
        if (message.latestHeight !== undefined) {
            client_1.Height.encode(message.latestHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.checksum = reader.bytes();
                    break;
                case 3:
                    message.latestHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.data))
            obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.checksum))
            obj.checksum = (0, helpers_1.bytesFromBase64)(object.checksum);
        if ((0, helpers_1.isSet)(object.latestHeight))
            obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        return obj;
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.checksum !== undefined &&
            (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== undefined ? message.checksum : new Uint8Array()));
        message.latestHeight !== undefined &&
            (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseClientState();
        message.data = object.data ?? new Uint8Array();
        message.checksum = object.checksum ?? new Uint8Array();
        if (object.latestHeight !== undefined && object.latestHeight !== null) {
            message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        }
        return message;
    },
};
function createBaseConsensusState() {
    return {
        data: new Uint8Array(),
    };
}
exports.ConsensusState = {
    typeUrl: "/ibc.lightclients.wasm.v1.ConsensusState",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.data))
            obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConsensusState();
        message.data = object.data ?? new Uint8Array();
        return message;
    },
};
function createBaseClientMessage() {
    return {
        data: new Uint8Array(),
    };
}
exports.ClientMessage = {
    typeUrl: "/ibc.lightclients.wasm.v1.ClientMessage",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const obj = createBaseClientMessage();
        if ((0, helpers_1.isSet)(object.data))
            obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseClientMessage();
        message.data = object.data ?? new Uint8Array();
        return message;
    },
};
function createBaseChecksums() {
    return {
        checksums: [],
    };
}
exports.Checksums = {
    typeUrl: "/ibc.lightclients.wasm.v1.Checksums",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.checksums) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChecksums();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.checksums.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const obj = createBaseChecksums();
        if (Array.isArray(object?.checksums))
            obj.checksums = object.checksums.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON(message) {
        const obj = {};
        if (message.checksums) {
            obj.checksums = message.checksums.map((e) => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.checksums = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseChecksums();
        message.checksums = object.checksums?.map((e) => e) || [];
        return message;
    },
};
//# sourceMappingURL=wasm.js.map