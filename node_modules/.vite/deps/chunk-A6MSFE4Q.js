import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS
} from "./chunk-BYYN2XO5.js";

// node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decimal = void 0;
    var maxFractionalDigits = 100;
    var Decimal = class _Decimal {
      constructor(atomics, fractionalDigits) {
        __publicField(this, "data");
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: BigInt(atomics),
          fractionalDigits
        };
      }
      static fromUserInput(input, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new _Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = a.data.atomics - b.data.atomics;
        if (difference < 0n)
          return -1;
        if (difference > 0n)
          return 1;
        return 0;
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      /** Creates a new instance with the same value */
      clone() {
        return new _Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics((whole * factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(((whole + 1n) * factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics + b.data.atomics;
        return new _Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics - b.data.atomics;
        if (difference < 0n)
          throw new Error("Difference must not be negative");
        return new _Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b) {
        const product = this.data.atomics * b.toBigInt();
        return new _Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b) {
        return _Decimal.compare(this, b) === 0;
      }
      isLessThan(b) {
        return _Decimal.compare(this, b) < 0;
      }
      isLessThanOrEqual(b) {
        return _Decimal.compare(this, b) <= 0;
      }
      isGreaterThan(b) {
        return _Decimal.compare(this, b) > 0;
      }
      isGreaterThanOrEqual(b) {
        return _Decimal.compare(this, b) >= 0;
      }
    };
    exports.Decimal = Decimal;
  }
});

// node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/integers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;
    var uint64MaxValue = 18446744073709551615n;
    var Uint32 = class _Uint32 {
      constructor(input) {
        __publicField(this, "data");
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes) {
        return _Uint32.fromBytes(bytes);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error(`Invalid value in byte. Found: ${bytes[i]}`);
          }
        }
        const beBytes = endianness === "be" ? bytes : Array.from(bytes).reverse();
        return new _Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint32(Number.parseInt(str, 10));
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint32 = Uint32;
    var Int53 = class _Int53 {
      constructor(input) {
        __publicField(this, "data");
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      static fromString(str) {
        if (!str.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Int53(Number.parseInt(str, 10));
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Int53 = Int53;
    var Uint53 = class _Uint53 {
      constructor(input) {
        __publicField(this, "data");
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      static fromString(str) {
        const signed = Int53.fromString(str);
        return new _Uint53(signed.toNumber());
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint53 = Uint53;
    var Uint64 = class _Uint64 {
      constructor(data2) {
        __publicField(this, "data");
        if (data2 < 0n) {
          throw new Error("Input is negative");
        }
        if (data2 > uint64MaxValue) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data2;
      }
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes) {
        return _Uint64.fromBytes(bytes);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        const beBytes = endianness === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        let value = 0n;
        for (const byte of beBytes) {
          value *= 256n;
          if (!Number.isInteger(byte) || byte > 255 || byte < 0) {
            throw new Error(`Invalid value in byte. Found: ${byte}`);
          }
          value += BigInt(byte);
        }
        return new _Uint64(value);
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint64(BigInt(str));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (!Number.isSafeInteger(input)) {
          throw new Error("Input is not a safe integer");
        }
        const bigint = BigInt(input);
        return new _Uint64(bigint);
      }
      toBytesBigEndian() {
        return this.toBytesLittleEndian().reverse();
      }
      toBytesLittleEndian() {
        const bytes = new Uint8Array(8);
        let value = this.data;
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = Number(value % 256n);
          value /= 256n;
        }
        return bytes;
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return this.data;
      }
      toNumber() {
        if (this.data > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("number can only safely store up to 53 bits");
        }
        const num = Number(this.data);
        return num;
      }
    };
    exports.Uint64 = Uint64;
  }
});

// node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/index.js
var require_build = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.36.1/node_modules/@cosmjs/math/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/utf8.js
var require_utf8 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8Write = exports.utf8Read = exports.utf8Length = void 0;
    function utf8Length(str) {
      let len = 0, c = 0;
      for (let i = 0; i < str.length; ++i) {
        c = str.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }
    exports.utf8Length = utf8Length;
    function utf8Read(buffer, start, end) {
      const len = end - start;
      if (len < 1)
        return "";
      const chunk = [];
      let parts = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode(...chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode(...chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode(...chunk.slice(0, i));
    }
    exports.utf8Read = utf8Read;
    function utf8Write(str, buffer, offset) {
      const start = offset;
      let c1, c2;
      for (let i = 0; i < str.length; ++i) {
        c1 = str.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }
    exports.utf8Write = utf8Write;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/varint.js
var require_varint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;
    function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    exports.varint64read = varint64read;
    function varint64write(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
      const hasMoreBits = !(hi >> 3 == 0);
      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes.push(hi >>> 31 & 1);
    }
    exports.varint64write = varint64write;
    var TWO_PWR_32_DBL = 4294967296;
    function int64FromString(dec) {
      const minus = dec[0] === "-";
      if (minus) {
        dec = dec.slice(1);
      }
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
          lowBits = lowBits % TWO_PWR_32_DBL;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
    }
    exports.int64FromString = int64FromString;
    function int64ToString(lo, hi) {
      let bits = newBits(lo, hi);
      const negative = bits.hi & 2147483648;
      if (negative) {
        bits = negate(bits.lo, bits.hi);
      }
      const result = uInt64ToString(bits.lo, bits.hi);
      return negative ? "-" + result : result;
    }
    exports.int64ToString = int64ToString;
    function uInt64ToString(lo, hi) {
      ({ lo, hi } = toUnsigned(lo, hi));
      if (hi <= 2097151) {
        return String(TWO_PWR_32_DBL * hi + lo);
      }
      const low = lo & 16777215;
      const mid = (lo >>> 24 | hi << 8) & 16777215;
      const high = hi >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      const base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
    }
    exports.uInt64ToString = uInt64ToString;
    function toUnsigned(lo, hi) {
      return { lo: lo >>> 0, hi: hi >>> 0 };
    }
    function newBits(lo, hi) {
      return { lo: lo | 0, hi: hi | 0 };
    }
    function negate(lowBits, highBits) {
      highBits = ~highBits;
      if (lowBits) {
        lowBits = ~lowBits + 1;
      } else {
        highBits += 1;
      }
      return newBits(lowBits, highBits);
    }
    var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
    function varint32write(value, bytes) {
      if (value >= 0) {
        while (value > 127) {
          bytes.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes.push(value);
      } else {
        for (let i = 0; i < 9; i++) {
          bytes.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes.push(1);
      }
    }
    exports.varint32write = varint32write;
    function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 127;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 7;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 14;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 21;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 15) << 28;
      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
      if ((b & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result >>> 0;
    }
    exports.varint32read = varint32read;
    function zzEncode(lo, hi) {
      let mask = hi >> 31;
      hi = ((hi << 1 | lo >>> 31) ^ mask) >>> 0;
      lo = (lo << 1 ^ mask) >>> 0;
      return [lo, hi];
    }
    exports.zzEncode = zzEncode;
    function zzDecode(lo, hi) {
      let mask = -(lo & 1);
      lo = ((lo >>> 1 | hi << 31) ^ mask) >>> 0;
      hi = (hi >>> 1 ^ mask) >>> 0;
      return [lo, hi];
    }
    exports.zzDecode = zzDecode;
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    exports.readUInt32 = readUInt32;
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    exports.readInt32 = readInt32;
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    exports.writeVarint32 = writeVarint32;
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    exports.writeVarint64 = writeVarint64;
    function int64Length(lo, hi) {
      let part0 = lo, part1 = (lo >>> 28 | hi << 4) >>> 0, part2 = hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    exports.int64Length = int64Length;
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    exports.writeFixed32 = writeFixed32;
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    exports.writeByte = writeByte;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryWriter = exports.BinaryReader = exports.WireType = void 0;
    var utf8_1 = require_utf8();
    var varint_1 = require_varint();
    var WireType;
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Fixed64"] = 1] = "Fixed64";
      WireType2[WireType2["Bytes"] = 2] = "Bytes";
      WireType2[WireType2["Fixed32"] = 5] = "Fixed32";
    })(WireType || (exports.WireType = WireType = {}));
    var BinaryReader = class {
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      constructor(buf) {
        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);
        this.pos = 0;
        this.type = 0;
        this.len = this.buf.length;
      }
      tag() {
        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType, tag];
      }
      skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      }
      skipType(wireType) {
        switch (wireType) {
          case WireType.Varint:
            this.skip();
            break;
          case WireType.Fixed64:
            this.skip(8);
            break;
          case WireType.Bytes:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case WireType.Fixed32:
            this.skip(4);
            break;
          /* istanbul ignore next */
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      }
      uint32() {
        return varint_1.varint32read.bind(this)();
      }
      int32() {
        return this.uint32() | 0;
      }
      sint32() {
        const num = this.uint32();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      }
      fixed32() {
        const val = (0, varint_1.readUInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      sfixed32() {
        const val = (0, varint_1.readInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      int64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      uint64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
      }
      sint64() {
        let [lo, hi] = varint_1.varint64read.bind(this)();
        [lo, hi] = (0, varint_1.zzDecode)(lo, hi);
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      fixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
      }
      sfixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      float() {
        throw new Error("float not supported");
      }
      double() {
        throw new Error("double not supported");
      }
      bool() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return lo !== 0 || hi !== 0;
      }
      bytes() {
        const len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      string() {
        const bytes = this.bytes();
        return (0, utf8_1.utf8Read)(bytes, 0, bytes.length);
      }
    };
    exports.BinaryReader = BinaryReader;
    var Op = class {
      constructor(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.val = val;
      }
      proceed(buf, pos) {
        if (this.fn) {
          this.fn(this.val, buf, pos);
        }
      }
    };
    var State = class {
      constructor(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
    };
    var BinaryWriter = class _BinaryWriter {
      constructor() {
        this.len = 0;
        this.uint64 = _BinaryWriter.prototype.int64;
        this.sfixed64 = _BinaryWriter.prototype.fixed64;
        this.sfixed32 = _BinaryWriter.prototype.fixed32;
        this.head = new Op(null, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      static create() {
        return new _BinaryWriter();
      }
      static alloc(size) {
        if (typeof Uint8Array !== "undefined") {
          return pool((size2) => new Uint8Array(size2), Uint8Array.prototype.subarray)(size);
        } else {
          return new Array(size);
        }
      }
      _push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      }
      finish() {
        let head = this.head.next, pos = 0;
        const buf = _BinaryWriter.alloc(this.len);
        while (head) {
          head.proceed(buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      }
      fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(null, 0, 0);
        this.len = 0;
        return this;
      }
      reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(null, 0, 0);
          this.len = 0;
        }
        return this;
      }
      ldelim() {
        const head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      }
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      uint32(value) {
        this.len += (this.tail = this.tail.next = new Op(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
      }
      int32(value) {
        return value < 0 ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) : this.uint32(value);
      }
      sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      }
      int64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });
      }
      sint64(value) {
        let { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        [lo, hi] = (0, varint_1.zzEncode)(lo, hi);
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });
      }
      fixed64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeFixed32, 4, lo)._push(varint_1.writeFixed32, 4, hi);
      }
      bool(value) {
        return this._push(varint_1.writeByte, 1, value ? 1 : 0);
      }
      fixed32(value) {
        return this._push(varint_1.writeFixed32, 4, value >>> 0);
      }
      float(value) {
        throw new Error("float not supported" + value);
      }
      double(value) {
        throw new Error("double not supported" + value);
      }
      bytes(value) {
        const len = value.length >>> 0;
        if (!len)
          return this._push(varint_1.writeByte, 1, 0);
        return this.uint32(len)._push(writeBytes, len, value);
      }
      string(value) {
        const len = (0, utf8_1.utf8Length)(value);
        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);
      }
    };
    exports.BinaryWriter = BinaryWriter;
    function writeBytes(val, buf, pos) {
      if (typeof Uint8Array !== "undefined") {
        buf.set(val, pos);
      } else {
        for (let i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      }
    }
    function pool(alloc, slice, size) {
      const SIZE = size || 8192;
      const MAX = SIZE >>> 1;
      let slab = null;
      let offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        const buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromJsonTimestamp = exports.fromTimestamp = exports.toTimestamp = exports.isRpc = exports.setPaginationParams = exports.isObject = exports.isSet = exports.fromDuration = exports.toDuration = exports.omitDefault = exports.base64FromBytes = exports.bytesFromBase64 = void 0;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    exports.bytesFromBase64 = bytesFromBase64;
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
      });
      return btoa(bin.join(""));
    }
    exports.base64FromBytes = base64FromBytes;
    function omitDefault(input) {
      if (typeof input === "string") {
        return input === "" ? void 0 : input;
      }
      if (typeof input === "number") {
        return input === 0 ? void 0 : input;
      }
      if (typeof input === "boolean") {
        return input === false ? void 0 : input;
      }
      if (typeof input === "bigint") {
        return input === BigInt(0) ? void 0 : input;
      }
      throw new Error(`Got unsupported type ${typeof input}`);
    }
    exports.omitDefault = omitDefault;
    function toDuration(duration) {
      return {
        seconds: BigInt(Math.floor(parseInt(duration) / 1e9)),
        nanos: parseInt(duration) % 1e9
      };
    }
    exports.toDuration = toDuration;
    function fromDuration(duration) {
      return (parseInt(duration.seconds.toString()) * 1e9 + duration.nanos).toString();
    }
    exports.fromDuration = fromDuration;
    function isSet(value) {
      return value !== null && value !== void 0;
    }
    exports.isSet = isSet;
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    exports.isObject = isObject;
    var setPaginationParams = (options, pagination) => {
      if (!pagination) {
        return options;
      }
      if (typeof (pagination == null ? void 0 : pagination.countTotal) !== "undefined") {
        options.params["pagination.count_total"] = pagination.countTotal;
      }
      if (typeof (pagination == null ? void 0 : pagination.key) !== "undefined") {
        options.params["pagination.key"] = Buffer.from(pagination.key).toString("base64");
      }
      if (typeof (pagination == null ? void 0 : pagination.limit) !== "undefined") {
        options.params["pagination.limit"] = pagination.limit.toString();
      }
      if (typeof (pagination == null ? void 0 : pagination.offset) !== "undefined") {
        options.params["pagination.offset"] = pagination.offset.toString();
      }
      if (typeof (pagination == null ? void 0 : pagination.reverse) !== "undefined") {
        options.params["pagination.reverse"] = pagination.reverse;
      }
      return options;
    };
    exports.setPaginationParams = setPaginationParams;
    function isRpc(rpc) {
      return rpc !== null && rpc !== void 0 && typeof rpc.request === "function";
    }
    exports.isRpc = isRpc;
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return {
        seconds,
        nanos
      };
    }
    exports.toTimestamp = toTimestamp;
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    exports.fromTimestamp = fromTimestamp;
    var timestampFromJSON = (object) => {
      return {
        seconds: isSet(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),
        nanos: isSet(object.nanos) ? Number(object.nanos) : 0
      };
    };
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestampFromJSON(o);
      }
    }
    exports.fromJsonTimestamp = fromJsonTimestamp;
    function numberToLong(number) {
      return BigInt(Math.trunc(number));
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/any.js
var require_any = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/any.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Any = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return {
        typeUrl: "",
        value: new Uint8Array()
      };
    }
    exports.Any = {
      typeUrl: "/google.protobuf.Any",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAny();
        if ((0, helpers_1.isSet)(object.typeUrl))
          obj.typeUrl = String(object.typeUrl);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return {
        signatures: []
      };
    }
    exports.MultiSignature = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMultiSignature();
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMultiSignature();
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return {
        extraBitsStored: 0,
        elems: new Uint8Array()
      };
    }
    exports.CompactBitArray = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompactBitArray();
        if ((0, helpers_1.isSet)(object.extraBitsStored))
          obj.extraBitsStored = Number(object.extraBitsStored);
        if ((0, helpers_1.isSet)(object.elems))
          obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompactBitArray();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;
    var multisig_1 = require_multisig();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode || (exports.SignMode = SignMode = {}));
    function signModeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
          return SignMode.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object) {
      switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_DIRECT_AUX:
          return "SIGN_MODE_DIRECT_AUX";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return {
        signatures: []
      };
    }
    exports.SignatureDescriptors = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptors();
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignatureDescriptors();
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => exports.SignatureDescriptor.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return {
        publicKey: void 0,
        data: void 0,
        sequence: BigInt(0)
      };
    }
    exports.SignatureDescriptor = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = exports.SignatureDescriptor_Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = exports.SignatureDescriptor_Data.fromPartial(object.data);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports.SignatureDescriptor_Data = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports.SignatureDescriptor_Data_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports.SignatureDescriptor_Data_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return {
        mode: 0,
        signature: new Uint8Array()
      };
    }
    exports.SignatureDescriptor_Data_Single = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = signModeFromJSON(object.mode);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = object.mode ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return {
        bitarray: void 0,
        signatures: []
      };
    }
    exports.SignatureDescriptor_Data_Multi = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor_Data.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignatureDescriptor_Data_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => exports.SignatureDescriptor_Data.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js
var require_coin = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports.Coin = {
      typeUrl: "/cosmos.base.v1beta1.Coin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCoin();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseDecCoin() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports.DecCoin = {
      typeUrl: "/cosmos.base.v1beta1.DecCoin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecCoin();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseIntProto() {
      return {
        int: ""
      };
    }
    exports.IntProto = {
      typeUrl: "/cosmos.base.v1beta1.IntProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIntProto();
        if ((0, helpers_1.isSet)(object.int))
          obj.int = String(object.int);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
      }
    };
    function createBaseDecProto() {
      return {
        dec: ""
      };
    }
    exports.DecProto = {
      typeUrl: "/cosmos.base.v1beta1.DecProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecProto();
        if ((0, helpers_1.isSet)(object.dec))
          obj.dec = String(object.dec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js
var require_tx = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuxSignerData = exports.Tip = exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDocDirectAux = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var signing_1 = require_signing();
    var multisig_1 = require_multisig();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return {
        body: void 0,
        authInfo: void 0,
        signatures: []
      };
    }
    exports.Tx = {
      typeUrl: "/cosmos.tx.v1beta1.Tx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.body !== void 0) {
          exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTx();
        if ((0, helpers_1.isSet)(object.body))
          obj.body = exports.TxBody.fromJSON(object.body);
        if ((0, helpers_1.isSet)(object.authInfo))
          obj.authInfo = exports.AuthInfo.fromJSON(object.authInfo);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseTx();
        if (object.body !== void 0 && object.body !== null) {
          message.body = exports.TxBody.fromPartial(object.body);
        }
        if (object.authInfo !== void 0 && object.authInfo !== null) {
          message.authInfo = exports.AuthInfo.fromPartial(object.authInfo);
        }
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports.TxRaw = {
      typeUrl: "/cosmos.tx.v1beta1.TxRaw",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxRaw();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseTxRaw();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: BigInt(0)
      };
    }
    exports.SignDoc = {
      typeUrl: "/cosmos.tx.v1beta1.SignDoc",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDoc();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDoc();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        return message;
      }
    };
    function createBaseSignDocDirectAux() {
      return {
        bodyBytes: new Uint8Array(),
        publicKey: void 0,
        chainId: "",
        accountNumber: BigInt(0),
        sequence: BigInt(0),
        tip: void 0
      };
    }
    exports.SignDocDirectAux = {
      typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.sequence);
        }
        if (message.tip !== void 0) {
          exports.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            case 5:
              message.sequence = reader.uint64();
              break;
            case 6:
              message.tip = exports.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDocDirectAux();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.tip !== void 0 && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: BigInt(0),
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports.TxBody = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v of message.extensionOptions) {
          any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (const v of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = reader.uint64();
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxBody();
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = BigInt(object.timeoutHeight.toString());
        if (Array.isArray(object == null ? void 0 : object.extensionOptions))
          obj.extensionOptions = object.extensionOptions.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.nonCriticalExtensionOptions))
          obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseTxBody();
        message.messages = ((_a2 = object.messages) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        message.memo = object.memo ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = BigInt(object.timeoutHeight.toString());
        }
        message.extensionOptions = ((_b = object.extensionOptions) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.nonCriticalExtensionOptions = ((_c = object.nonCriticalExtensionOptions) == null ? void 0 : _c.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return {
        signerInfos: [],
        fee: void 0,
        tip: void 0
      };
    }
    exports.AuthInfo = {
      typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signerInfos) {
          exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        if (message.tip !== void 0) {
          exports.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports.Fee.decode(reader, reader.uint32());
              break;
            case 3:
              message.tip = exports.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuthInfo();
        if (Array.isArray(object == null ? void 0 : object.signerInfos))
          obj.signerInfos = object.signerInfos.map((e) => exports.SignerInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.fee))
          obj.fee = exports.Fee.fromJSON(object.fee);
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : void 0);
        message.tip !== void 0 && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseAuthInfo();
        message.signerInfos = ((_a2 = object.signerInfos) == null ? void 0 : _a2.map((e) => exports.SignerInfo.fromPartial(e))) || [];
        if (object.fee !== void 0 && object.fee !== null) {
          message.fee = exports.Fee.fromPartial(object.fee);
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseSignerInfo() {
      return {
        publicKey: void 0,
        modeInfo: void 0,
        sequence: BigInt(0)
      };
    }
    exports.SignerInfo = {
      typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignerInfo();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.modeInfo))
          obj.modeInfo = exports.ModeInfo.fromJSON(object.modeInfo);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignerInfo();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.modeInfo !== void 0 && object.modeInfo !== null) {
          message.modeInfo = exports.ModeInfo.fromPartial(object.modeInfo);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModeInfo() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports.ModeInfo = {
      typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports.ModeInfo_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports.ModeInfo_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports.ModeInfo_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports.ModeInfo_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return {
        mode: 0
      };
    }
    exports.ModeInfo_Single = {
      typeUrl: "/cosmos.tx.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Single();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return {
        bitarray: void 0,
        modeInfos: []
      };
    }
    exports.ModeInfo_Multi = {
      typeUrl: "/cosmos.tx.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.modeInfos) {
          exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object == null ? void 0 : object.modeInfos))
          obj.modeInfos = object.modeInfos.map((e) => exports.ModeInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseModeInfo_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.modeInfos = ((_a2 = object.modeInfos) == null ? void 0 : _a2.map((e) => exports.ModeInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFee() {
      return {
        amount: [],
        gasLimit: BigInt(0),
        payer: "",
        granter: ""
      };
    }
    exports.Fee = {
      typeUrl: "/cosmos.tx.v1beta1.Fee",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = reader.uint64();
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFee();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.gasLimit))
          obj.gasLimit = BigInt(object.gasLimit.toString());
        if ((0, helpers_1.isSet)(object.payer))
          obj.payer = String(object.payer);
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseFee();
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.gasLimit !== void 0 && object.gasLimit !== null) {
          message.gasLimit = BigInt(object.gasLimit.toString());
        }
        message.payer = object.payer ?? "";
        message.granter = object.granter ?? "";
        return message;
      }
    };
    function createBaseTip() {
      return {
        amount: [],
        tipper: ""
      };
    }
    exports.Tip = {
      typeUrl: "/cosmos.tx.v1beta1.Tip",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.tipper !== "") {
          writer.uint32(18).string(message.tipper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTip();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.tipper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTip();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.tipper))
          obj.tipper = String(object.tipper);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.tipper !== void 0 && (obj.tipper = message.tipper);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseTip();
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.tipper = object.tipper ?? "";
        return message;
      }
    };
    function createBaseAuxSignerData() {
      return {
        address: "",
        signDoc: void 0,
        mode: 0,
        sig: new Uint8Array()
      };
    }
    exports.AuxSignerData = {
      typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.signDoc !== void 0) {
          exports.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.sig.length !== 0) {
          writer.uint32(34).bytes(message.sig);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.signDoc = exports.SignDocDirectAux.decode(reader, reader.uint32());
              break;
            case 3:
              message.mode = reader.int32();
              break;
            case 4:
              message.sig = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuxSignerData();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.signDoc))
          obj.signDoc = exports.SignDocDirectAux.fromJSON(object.signDoc);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        if ((0, helpers_1.isSet)(object.sig))
          obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.signDoc !== void 0 && (obj.signDoc = message.signDoc ? exports.SignDocDirectAux.toJSON(message.signDoc) : void 0);
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== void 0 && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== void 0 ? message.sig : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuxSignerData();
        message.address = object.address ?? "";
        if (object.signDoc !== void 0 && object.signDoc !== null) {
          message.signDoc = exports.SignDocDirectAux.fromPartial(object.signDoc);
        }
        message.mode = object.mode ?? 0;
        message.sig = object.sig ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTxRaw = decodeTxRaw;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/ascii.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = toAscii;
    exports.fromAscii = fromAscii;
    function toAscii(input) {
      const toNums = (str) => str.split("").map((x) => {
        const charCode = x.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error(`Cannot encode character that is out of printable ASCII range: ${charCode}`);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    function fromAscii(data2) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
        if (x < 32 || x > 126) {
          throw new Error(`Cannot decode character that is out of printable ASCII range: ${x}`);
        }
        return String.fromCharCode(x);
      });
      return fromNums(Array.from(data2)).join("");
    }
  }
});

// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/base64.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBase64 = toBase64;
    exports.fromBase64 = fromBase64;
    var base64js = __importStar(require_base64_js());
    function toBase64(data2) {
      return base64js.fromByteArray(data2);
    }
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
  }
});

// node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string") throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8) return str + " too short";
      if (str.length > LIMIT) return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1) return "No separator character for " + str;
      if (split === 0) return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6) return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string") return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
      }
      if (chk !== 1) return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
    }
    function decode(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
      throw new Error(res);
    }
    function convert(data2, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data2.length; ++i) {
        value = value << inBits | data2[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode,
      encode,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/bech32.js
var require_bech322 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/bech32.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBech32 = toBech32;
    exports.fromBech32 = fromBech32;
    exports.normalizeBech32 = normalizeBech32;
    var bech32 = __importStar(require_bech32());
    function toBech32(prefix, data2, limit) {
      const address = bech32.encode(prefix, bech32.toWords(data2), limit);
      return address;
    }
    function fromBech32(address, limit = Infinity) {
      const decodedAddress = bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
      };
    }
    function normalizeBech32(address) {
      const { prefix, data: data2 } = fromBech32(address);
      return toBech32(prefix, data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHex = toHex;
    exports.fromHex = fromHex;
    function toHex(data2) {
      let out = "";
      for (const byte of data2) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i = 0; i < out.length; i++) {
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/rfc3339.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRfc3339 = fromRfc3339;
    exports.toRfc3339 = toRfc3339;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str) {
      const matches = rfc3339Matcher.exec(str);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const date = /* @__PURE__ */ new Date();
      date.setUTCFullYear(year, month - 1, day);
      date.setUTCHours(hour, minute, second, milliSeconds);
      return new Date(date.getTime() - tzOffset * 1e3);
    }
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/utf8.js
var require_utf82 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = toUtf8;
    exports.fromUtf8 = fromUtf8;
    function toUtf8(str) {
      return new TextEncoder().encode(str);
    }
    function fromUtf8(data2, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/index.js
var require_build2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.36.1/node_modules/@cosmjs/encoding/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = exports.toRfc3339 = exports.fromRfc3339 = exports.toHex = exports.fromHex = exports.toBech32 = exports.normalizeBech32 = exports.fromBech32 = exports.toBase64 = exports.fromBase64 = exports.toAscii = exports.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech322();
    Object.defineProperty(exports, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf82();
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayContentEquals = arrayContentEquals;
    exports.arrayContentStartsWith = arrayContentStartsWith;
    function arrayContentEquals(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    function arrayContentStartsWith(a, b) {
      if (a.length < b.length)
        return false;
      for (let i = 0; i < b.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = assert;
    exports.assertDefined = assertDefined;
    exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg ?? "value is undefined");
      }
    }
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg ?? "value is undefined or null");
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = sleep;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/typechecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNonNullObject = isNonNullObject;
    exports.isUint8Array = isUint8Array;
    exports.isDefined = isDefined;
    function isNonNullObject(data2) {
      return typeof data2 === "object" && data2 !== null;
    }
    function isUint8Array(data2) {
      if (!isNonNullObject(data2))
        return false;
      if (Object.prototype.toString.call(data2) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data2))
          return false;
      }
      return true;
    }
    function isDefined(value) {
      return value !== void 0;
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/index.js
var require_build3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.36.1/node_modules/@cosmjs/utils/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUint8Array = exports.isNonNullObject = exports.isDefined = exports.sleep = exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      abytes(data2);
      return data2;
    }
    function kdfInputToBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      abytes(data2);
      return data2;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash2);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = pbkdf22;
    exports.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash2);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf22(hash2, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { view, buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data2);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data2.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports.HashMD = HashMD;
    exports.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
    exports.add = add;
    exports.fromBig = fromBig;
    exports.split = split;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports.SHA224 = SHA224;
    var K512 = (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh = (() => K512[0])();
    var SHA512_Kl = (() => K512[1])();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports.SHA384 = SHA384;
    var T224_IV = Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports.SHA512_256 = SHA512_256;
    exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSubtle = getSubtle;
    exports.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
    exports.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
    exports.pbkdf2Sha512 = pbkdf2Sha512;
    var utils_1 = require_build3();
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    async function getSubtle() {
      var _a2;
      return (_a2 = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : _a2.subtle;
    }
    async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(subtle, "Argument subtle is falsy");
      (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
      (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
      (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
      return subtle.importKey("raw", secret, { name: "PBKDF2" }, false, ["deriveBits"]).then((key) => subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: { name: "SHA-512" }
      }, key, keylen * 8).then((buffer) => new Uint8Array(buffer)));
    }
    async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
      return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, secret, salt, { c: iterations, dkLen: keylen });
    }
    async function pbkdf2Sha512(secret, salt, iterations, keylen) {
      const subtle = await getSubtle();
      if (subtle) {
        return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
      } else {
        return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toRealUint8Array = toRealUint8Array;
    function toRealUint8Array(data2) {
      if (data2 instanceof Uint8Array)
        return data2;
      else
        return Uint8Array.from(data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/sha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha512 = exports.Sha256 = void 0;
    exports.sha256 = sha2562;
    exports.sha512 = sha5122;
    var sha2_1 = require_sha2();
    var utils_1 = require_utils2();
    var Sha256 = class {
      constructor(firstData) {
        __publicField(this, "blockSize", 512 / 8);
        __publicField(this, "impl", sha2_1.sha256.create());
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha256 = Sha256;
    function sha2562(data2) {
      return new Sha256(data2).digest();
    }
    var Sha512 = class {
      constructor(firstData) {
        __publicField(this, "blockSize", 1024 / 8);
        __publicField(this, "impl", sha2_1.sha512.create());
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha512 = Sha512;
    function sha5122(data2) {
      return new Sha512(data2).digest();
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/bip39.js
var require_bip39 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/bip39.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bip39 = exports.EnglishMnemonic = void 0;
    exports.entropyToMnemonic = entropyToMnemonic;
    exports.mnemonicToEntropy = mnemonicToEntropy;
    var encoding_1 = require_build2();
    var pbkdf2_1 = require_pbkdf22();
    var sha_1 = require_sha();
    var wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    function bytesToBitstring(bytes) {
      return Array.from(bytes).map((byte) => byte.toString(2).padStart(8, "0")).join("");
    }
    function deriveChecksumBits(entropy) {
      const entropyLengthBits = entropy.length * 8;
      const checksumLengthBits = entropyLengthBits / 32;
      const hash2 = (0, sha_1.sha256)(entropy);
      return bytesToBitstring(hash2).slice(0, checksumLengthBits);
    }
    function bitstringToByte(bin) {
      return parseInt(bin, 2);
    }
    var allowedEntropyLengths = [16, 20, 24, 28, 32];
    var allowedWordLengths = [12, 15, 18, 21, 24];
    function entropyToMnemonic(entropy) {
      if (allowedEntropyLengths.indexOf(entropy.length) === -1) {
        throw new Error("invalid input length");
      }
      const entropyBits = bytesToBitstring(entropy);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{11})/g);
      const words = chunks.map((binary) => {
        const index = bitstringToByte(binary);
        return wordlist[index];
      });
      return words.join(" ");
    }
    var invalidNumberOfWords = "Invalid number of words";
    var wordNotInWordlist = "Found word that is not in the wordlist";
    var invalidEntropy = "Invalid entropy";
    var invalidChecksum = "Invalid mnemonic checksum";
    function normalize(str) {
      return str.normalize("NFKD");
    }
    function mnemonicToEntropy(mnemonic) {
      const words = normalize(mnemonic).split(" ");
      if (!allowedWordLengths.includes(words.length)) {
        throw new Error(invalidNumberOfWords);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(wordNotInWordlist);
        }
        return index.toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
      if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
        throw new Error(invalidEntropy);
      }
      const entropy = Uint8Array.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(invalidChecksum);
      }
      return entropy;
    }
    var _EnglishMnemonic = class _EnglishMnemonic {
      constructor(mnemonic) {
        __publicField(this, "data");
        if (!_EnglishMnemonic.mnemonicMatcher.test(mnemonic)) {
          throw new Error("Invalid mnemonic format");
        }
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [12, 15, 18, 21, 24];
        if (allowedWordsLengths.indexOf(words.length) === -1) {
          throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        }
        for (const word of words) {
          if (_EnglishMnemonic.wordlist.indexOf(word) === -1) {
            throw new Error("Mnemonic contains invalid word");
          }
        }
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    __publicField(_EnglishMnemonic, "wordlist", wordlist);
    // list of space separated lower case words (1 or more)
    __publicField(_EnglishMnemonic, "mnemonicMatcher", /^[a-z]+( [a-z]+)*$/);
    var EnglishMnemonic = _EnglishMnemonic;
    exports.EnglishMnemonic = EnglishMnemonic;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
      }
      static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
      }
      static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
      }
    };
    exports.Bip39 = Bip39;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hmac = void 0;
    var Hmac = class {
      constructor(hashFunctionConstructor, originalKey) {
        __publicField(this, "blockSize");
        __publicField(this, "messageHasher");
        __publicField(this, "oKeyPad");
        __publicField(this, "iKeyPad");
        __publicField(this, "hash");
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data2) => new hashFunctionConstructor().update(data2).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data2) {
        this.messageHasher.update(data2);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports.Hmac = Hmac;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
    exports.keccakP = keccakP;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
    var SHA3_IOTA_H = IOTAS[0];
    var SHA3_IOTA_L = IOTAS[1];
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      (0, utils_ts_1.clean)(B);
    }
    var Keccak = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { blockLen, state } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data2[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = (() => genShake(31, 168, 128 / 8))();
    exports.shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keccak256 = void 0;
    exports.keccak256 = keccak256;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils2();
    var Keccak256 = class {
      constructor(firstData) {
        __publicField(this, "blockSize", 512 / 8);
        __publicField(this, "impl", sha3_1.keccak_256.create());
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Keccak256 = Keccak256;
    function keccak256(data2) {
      return new Keccak256(data2).digest();
    }
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapCipher = exports.Hash = exports.nextTick = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.abool = abool;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.overlapBytes = overlapBytes;
    exports.complexOverlapBytes = complexOverlapBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.equalBytes = equalBytes;
    exports.getOutput = getOutput;
    exports.setBigUint64 = setBigUint64;
    exports.u64Lengths = u64Lengths;
    exports.isAligned32 = isAligned32;
    exports.copyBytes = copyBytes;
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var hasHexBuiltin = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : "0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      else if (isBytes(data2))
        data2 = copyBytes(data2);
      else
        throw new Error("Uint8Array expected, got " + typeof data2);
      return data2;
    }
    function overlapBytes(a, b) {
      return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
      a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
      b.byteOffset < a.byteOffset + a.byteLength;
    }
    function complexOverlapBytes(input, output) {
      if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
        throw new Error("complex overlap of input and output is not supported");
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts == null || typeof opts !== "object")
        throw new Error("options must be defined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    var wrapCipher = (params, constructor) => {
      function wrappedCipher(key, ...args) {
        abytes(key);
        if (!exports.isLE)
          throw new Error("Non little-endian hardware is not yet supported");
        if (params.nonceLength !== void 0) {
          const nonce = args[0];
          if (!nonce)
            throw new Error("nonce / iv required");
          if (params.varSizeNonce)
            abytes(nonce);
          else
            abytes(nonce, params.nonceLength);
        }
        const tagl = params.tagLength;
        if (tagl && args[1] !== void 0) {
          abytes(args[1]);
        }
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
          if (output !== void 0) {
            if (fnLength !== 2)
              throw new Error("cipher output not supported");
            abytes(output);
          }
        };
        let called = false;
        const wrCipher = {
          encrypt(data2, output) {
            if (called)
              throw new Error("cannot encrypt() twice with same key + nonce");
            called = true;
            abytes(data2);
            checkOutput(cipher.encrypt.length, output);
            return cipher.encrypt(data2, output);
          },
          decrypt(data2, output) {
            abytes(data2);
            if (tagl && data2.length < tagl)
              throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
            checkOutput(cipher.decrypt.length, output);
            return cipher.decrypt(data2, output);
          }
        };
        return wrCipher;
      }
      Object.assign(wrappedCipher, params);
      return wrappedCipher;
    };
    exports.wrapCipher = wrapCipher;
    function getOutput(expectedLength, out, onlyAligned = true) {
      if (out === void 0)
        return new Uint8Array(expectedLength);
      if (out.length !== expectedLength)
        throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
      if (onlyAligned && !isAligned32(out))
        throw new Error("invalid output, must be aligned");
      return out;
    }
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function u64Lengths(dataLength, aadLength, isLE) {
      abool(isLE);
      const num = new Uint8Array(16);
      const view = createView(num);
      setBigUint64(view, 0, BigInt(aadLength), isLE);
      setBigUint64(view, 8, BigInt(dataLength), isLE);
      return num;
    }
    function isAligned32(bytes) {
      return bytes.byteOffset % 4 === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_arx.js
var require_arx = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_arx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rotl = rotl;
    exports.createCipher = createCipher;
    var utils_ts_1 = require_utils3();
    var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
    var sigma16 = _utf8ToBytes("expand 16-byte k");
    var sigma32 = _utf8ToBytes("expand 32-byte k");
    var sigma16_32 = (0, utils_ts_1.u32)(sigma16);
    var sigma32_32 = (0, utils_ts_1.u32)(sigma32);
    function rotl(a, b) {
      return a << b | a >>> 32 - b;
    }
    function isAligned32(b) {
      return b.byteOffset % 4 === 0;
    }
    var BLOCK_LEN = 64;
    var BLOCK_LEN32 = 16;
    var MAX_COUNTER = 2 ** 32 - 1;
    var U32_EMPTY = new Uint32Array();
    function runCipher(core, sigma, key, nonce, data2, output, counter, rounds) {
      const len = data2.length;
      const block = new Uint8Array(BLOCK_LEN);
      const b32 = (0, utils_ts_1.u32)(block);
      const isAligned = isAligned32(data2) && isAligned32(output);
      const d32 = isAligned ? (0, utils_ts_1.u32)(data2) : U32_EMPTY;
      const o32 = isAligned ? (0, utils_ts_1.u32)(output) : U32_EMPTY;
      for (let pos = 0; pos < len; counter++) {
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        if (isAligned && take === BLOCK_LEN) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0)
            throw new Error("arx: invalid block position");
          for (let j = 0, posj; j < BLOCK_LEN32; j++) {
            posj = pos32 + j;
            o32[posj] = d32[posj] ^ b32[j];
          }
          pos += BLOCK_LEN;
          continue;
        }
        for (let j = 0, posj; j < take; j++) {
          posj = pos + j;
          output[posj] = data2[posj] ^ block[j];
        }
        pos += take;
      }
    }
    function createCipher(core, opts) {
      const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_ts_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
      if (typeof core !== "function")
        throw new Error("core must be a function");
      (0, utils_ts_1.anumber)(counterLength);
      (0, utils_ts_1.anumber)(rounds);
      (0, utils_ts_1.abool)(counterRight);
      (0, utils_ts_1.abool)(allowShortKeys);
      return (key, nonce, data2, output, counter = 0) => {
        (0, utils_ts_1.abytes)(key);
        (0, utils_ts_1.abytes)(nonce);
        (0, utils_ts_1.abytes)(data2);
        const len = data2.length;
        if (output === void 0)
          output = new Uint8Array(len);
        (0, utils_ts_1.abytes)(output);
        (0, utils_ts_1.anumber)(counter);
        if (counter < 0 || counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        if (output.length < len)
          throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        let l = key.length;
        let k;
        let sigma;
        if (l === 32) {
          toClean.push(k = (0, utils_ts_1.copyBytes)(key));
          sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
          k = new Uint8Array(32);
          k.set(key);
          k.set(key, 16);
          sigma = sigma16_32;
          toClean.push(k);
        } else {
          throw new Error(`arx: invalid 32-byte key, got length=${l}`);
        }
        if (!isAligned32(nonce))
          toClean.push(nonce = (0, utils_ts_1.copyBytes)(nonce));
        const k32 = (0, utils_ts_1.u32)(k);
        if (extendNonceFn) {
          if (nonce.length !== 24)
            throw new Error(`arx: extended nonce must be 24 bytes`);
          extendNonceFn(sigma, k32, (0, utils_ts_1.u32)(nonce.subarray(0, 16)), k32);
          nonce = nonce.subarray(16);
        }
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
          throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        if (nonceNcLen !== 12) {
          const nc = new Uint8Array(12);
          nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
          nonce = nc;
          toClean.push(nonce);
        }
        const n32 = (0, utils_ts_1.u32)(nonce);
        runCipher(core, sigma, k32, n32, data2, output, counter, rounds);
        (0, utils_ts_1.clean)(...toClean);
        return output;
      };
    }
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poly1305 = void 0;
    exports.wrapConstructorWithKey = wrapConstructorWithKey;
    var utils_ts_1 = require_utils3();
    var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
    var Poly1305 = class {
      constructor(key) {
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = (0, utils_ts_1.toBytes)(key);
        (0, utils_ts_1.abytes)(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        this.r[0] = t0 & 8191;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        for (let i = 0; i < 8; i++)
          this.pad[i] = u8to16(key, 16 + 2 * i);
      }
      process(data2, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data2, offset + 0);
        const t1 = u8to16(data2, offset + 2);
        const t2 = u8to16(data2, offset + 4);
        const t3 = u8to16(data2, offset + 6);
        const t4 = u8to16(data2, offset + 8);
        const t5 = u8to16(data2, offset + 10);
        const t6 = u8to16(data2, offset + 12);
        const t7 = u8to16(data2, offset + 14);
        let h0 = h[0] + (t0 & 8191);
        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
        let h5 = h[5] + (t4 >>> 1 & 8191);
        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
        let h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
      }
      finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 8191;
        for (let i = 2; i < 10; i++) {
          h[i] += c;
          c = h[i] >>> 13;
          h[i] &= 8191;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 8191;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 8191;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (let i = 1; i < 10; i++) {
          g[i] = h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        let mask = (c ^ 1) - 1;
        for (let i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (let i = 0; i < 10; i++)
          h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 65535;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
        let f = h[0] + pad[0];
        h[0] = f & 65535;
        for (let i = 1; i < 8; i++) {
          f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
          h[i] = f & 65535;
        }
        (0, utils_ts_1.clean)(g);
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(data2, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(buffer, 0, false);
            this.pos = 0;
          }
        }
        return this;
      }
      destroy() {
        (0, utils_ts_1.clean)(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
          buffer[pos++] = 1;
          for (; pos < 16; pos++)
            buffer[pos] = 0;
          this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i = 0; i < 8; i++) {
          out[opos++] = h[i] >>> 0;
          out[opos++] = h[i] >>> 8;
        }
        return out;
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    };
    function wrapConstructorWithKey(hashCons) {
      const hashC = (msg, key) => hashCons(key).update((0, utils_ts_1.toBytes)(msg)).digest();
      const tmp = hashCons(new Uint8Array(32));
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (key) => hashCons(key);
      return hashC;
    }
    exports.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/chacha.js
var require_chacha = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/chacha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = void 0;
    exports.hchacha = hchacha;
    var _arx_ts_1 = require_arx();
    var _poly1305_ts_1 = require_poly1305();
    var utils_ts_1 = require_utils3();
    function chachaCore(s, k, n, out, cnt, rounds = 20) {
      let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let r = 0; r < rounds; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi = 0;
      out[oi++] = y00 + x00 | 0;
      out[oi++] = y01 + x01 | 0;
      out[oi++] = y02 + x02 | 0;
      out[oi++] = y03 + x03 | 0;
      out[oi++] = y04 + x04 | 0;
      out[oi++] = y05 + x05 | 0;
      out[oi++] = y06 + x06 | 0;
      out[oi++] = y07 + x07 | 0;
      out[oi++] = y08 + x08 | 0;
      out[oi++] = y09 + x09 | 0;
      out[oi++] = y10 + x10 | 0;
      out[oi++] = y11 + x11 | 0;
      out[oi++] = y12 + x12 | 0;
      out[oi++] = y13 + x13 | 0;
      out[oi++] = y14 + x14 | 0;
      out[oi++] = y15 + x15 | 0;
    }
    function hchacha(s, k, i, o32) {
      let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
      for (let r = 0; r < 20; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi = 0;
      o32[oi++] = x00;
      o32[oi++] = x01;
      o32[oi++] = x02;
      o32[oi++] = x03;
      o32[oi++] = x12;
      o32[oi++] = x13;
      o32[oi++] = x14;
      o32[oi++] = x15;
    }
    exports.chacha20orig = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      allowShortKeys: true
    });
    exports.chacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      allowShortKeys: false
    });
    exports.xchacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      extendNonceFn: hchacha,
      allowShortKeys: false
    });
    exports.chacha8 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 8
    });
    exports.chacha12 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 12
    });
    var ZEROS16 = new Uint8Array(16);
    var updatePadded = (h, msg) => {
      h.update(msg);
      const left = msg.length % 16;
      if (left)
        h.update(ZEROS16.subarray(left));
    };
    var ZEROS32 = new Uint8Array(32);
    function computeTag(fn, key, nonce, data2, AAD) {
      const authKey = fn(key, nonce, ZEROS32);
      const h = _poly1305_ts_1.poly1305.create(authKey);
      if (AAD)
        updatePadded(h, AAD);
      updatePadded(h, data2);
      const num = (0, utils_ts_1.u64Lengths)(data2.length, AAD ? AAD.length : 0, true);
      h.update(num);
      const res = h.digest();
      (0, utils_ts_1.clean)(authKey, num);
      return res;
    }
    var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
      const tagLength = 16;
      return {
        encrypt(plaintext, output) {
          const plength = plaintext.length;
          output = (0, utils_ts_1.getOutput)(plength + tagLength, output, false);
          output.set(plaintext);
          const oPlain = output.subarray(0, -tagLength);
          xorStream(key, nonce, oPlain, oPlain, 1);
          const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
          output.set(tag, plength);
          (0, utils_ts_1.clean)(tag);
          return output;
        },
        decrypt(ciphertext, output) {
          output = (0, utils_ts_1.getOutput)(ciphertext.length - tagLength, output, false);
          const data2 = ciphertext.subarray(0, -tagLength);
          const passedTag = ciphertext.subarray(-tagLength);
          const tag = computeTag(xorStream, key, nonce, data2, AAD);
          if (!(0, utils_ts_1.equalBytes)(passedTag, tag))
            throw new Error("invalid tag");
          output.set(ciphertext.subarray(0, -tagLength));
          xorStream(key, nonce, output, output, 1);
          (0, utils_ts_1.clean)(tag);
          return output;
        }
      };
    };
    exports._poly1305_aead = _poly1305_aead;
    exports.chacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports._poly1305_aead)(exports.chacha20));
    exports.xchacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports._poly1305_aead)(exports.xchacha20));
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    exports.abool = abool;
    exports._abool2 = _abool2;
    exports._abytes2 = _abytes2;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.equalBytes = equalBytes;
    exports.copyBytes = copyBytes;
    exports.asciiToBytes = asciiToBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.isHash = isHash;
    exports._validateObject = _validateObject;
    exports.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function _abool2(value, title = "") {
      if (typeof value !== "boolean") {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + "expected boolean, got type=" + typeof value);
      }
      return value;
    }
    function _abytes2(value, length, title = "") {
      const bytes = (0, utils_js_1.isBytes)(value);
      const len = value == null ? void 0 : value.length;
      const needsLen = length !== void 0;
      if (!bytes || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    function asciiToBytes(ascii) {
      return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
          throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
      });
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_1n << BigInt(n)) - _1n;
    exports.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _7n = BigInt(7);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      return FpPow(Field(modulo), num, power);
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function assertIsSquare(Fp, root, n) {
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n, p1div4);
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n2 = Fp.mul(n, _2n);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp, n) => {
        let tv1 = Fp.pow(n, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c2);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n);
        const e2 = Fp.eql(Fp.sqr(tv3), n);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n)
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n;
      let S = 0;
      while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
      }
      let Z = _2n;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
          return n;
        if (FpLegendre(Fp, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n)
        return sqrt3mod4;
      if (P % _8n === _5n)
        return sqrt5mod8;
      if (P % _16n === _9n)
        return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return Fp.ONE;
      if (power === _1n)
        return num;
      let p = Fp.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modFromBytes = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === "boolean")
          modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
          if (modFromBytes)
            scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = void 0;
    exports.negateCt = negateCt;
    exports.normalizeZ = normalizeZ;
    exports.mulEndoUnsafe = mulEndoUnsafe;
    exports.pippenger = pippenger;
    exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports.validateBasic = validateBasic;
    exports._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
      return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n)
        throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports.wNAF = wNAF;
    function mulEndoUnsafe(Point, point, k1, k2) {
      let acc = point;
      let p1 = Point.ZERO;
      let p2 = Point.ZERO;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
          p1 = p1.add(acc);
        if (k2 & _1n)
          p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      return { p1, p2 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field, isLE) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order, { isLE });
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
      if (FpFnLE === void 0)
        FpFnLE = type === "edwards";
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE[p];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
      const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp.isValid(CURVE[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      CURVE = Object.freeze(Object.assign({}, CURVE));
      return { CURVE, Fp, Fn };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimeEdwardsPoint = void 0;
    exports.edwards = edwards;
    exports.eddsa = eddsa;
    exports.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    function isEdValidXY(Fp, CURVE, x, y) {
      const x2 = Fp.sqr(x);
      const y2 = Fp.sqr(y);
      const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
      return Fp.eql(left, right);
    }
    function edwards(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
      const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
      const modP = (n) => Fp.create(n);
      const uvRatio = extraOpts.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
        } catch (e) {
          return { isValid: false, value: _0n };
        }
      });
      if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(Z);
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
          throw new Error("bad point: ZERO");
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(X, Y, Z, T) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y);
          this.Z = acoord("z", Z, true);
          this.T = acoord("t", T);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        static fromAffine(p) {
          if (p instanceof Point)
            throw new Error("extended point not allowed");
          const { x, y } = p || {};
          acoord("x", x);
          acoord("y", y);
          return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
          const len = Fp.BYTES;
          const { a, d } = CURVE;
          bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
          (0, utils_ts_1._abool2)(zip215, "zip215");
          const normed = (0, utils_ts_1.copyBytes)(bytes);
          const lastByte = bytes[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid)
            throw new Error("bad point: invalid y coordinate");
          const isXOdd = (x & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n && isLastByteOdd)
            throw new Error("bad point: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_2n);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: expected 1 <= sc < curve.n");
          const { p, f } = wnaf.cached(this, scalar, (p2) => (0, curve_ts_1.normalizeZ)(Point, p2));
          return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          if (!Fn.isValid(scalar))
            throw new Error("invalid scalar: expected 0 <= sc < curve.n");
          if (scalar === _0n)
            return Point.ZERO;
          if (this.is0() || scalar === _1n)
            return this;
          return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = Fp.toBytes(y);
          bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
          return bytes;
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        toRawBytes() {
          return this.toBytes();
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
      Point.BASE.precompute(8);
      return Point;
    }
    var PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
      }
      static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
    exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
    function eddsa(Point, cHash, eddsaOpts = {}) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash } = eddsaOpts;
      const { BASE, Fp, Fn } = Point;
      const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
        (0, utils_ts_1._abool2)(phflag, "phflag");
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data2;
      });
      function modN_LE(hash2) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash2));
      }
      function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg);
        const R = BASE.multiply(r).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = Fn.create(r + k * scalar);
        if (!Fn.isValid(s))
          throw new Error("sign failed: invalid s");
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
      }
      const verifyOpts = { zip215: true };
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, lengths.publicKey);
        if (zip215 !== void 0)
          (0, utils_ts_1._abool2)(zip215, "zip215");
        if (prehash)
          msg = prehash(msg);
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
          A = Point.fromBytes(publicKey, zip215);
          R = Point.fromBytes(r, zip215);
          SB = BASE.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      const _size = Fp.BYTES;
      const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size
      };
      function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
      }
      function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point.fromBytes(key, zip215);
        } catch (error) {
          return false;
        }
      }
      const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
          const { y } = Point.fromBytes(publicKey);
          const size = lengths.publicKey;
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
          return Fp.toBytes(u);
        },
        toMontgomerySecret(secretKey) {
          const size = lengths.secretKey;
          (0, utils_ts_1._abytes2)(secretKey, size);
          const hashed = cHash(secretKey.subarray(0, size));
          return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths
      });
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
      const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
      };
      return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const Point = eddsa2.Point;
      const legacy = Object.assign({}, eddsa2, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES
      });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, hash2, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._DST_scalar = void 0;
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p, k, m, hash: hash2, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
          return Point.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map(u[0]);
          const u1 = map(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u = hash_to_field(msg, 1, opts);
          const u0 = map(u[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N = Point.Fn.ORDER;
          const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
          return hash_to_field(msg, 1, opts)[0][0];
        }
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.montgomery = montgomery;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
      const maxScalar = minScalar + maxAdded + _1n;
      const modP = (n) => (0, modular_ts_1.mod)(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)("u", u, _0n, P);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k >> t & _1n;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen
      };
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
      };
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
    exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    var ed25519_CURVE = (() => ({
      p: ed25519_CURVE_p,
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    }))();
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ed25519_CURVE_p;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
      const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
      const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
      const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
      const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
      const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
      const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
      const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
      const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio(u, v) {
      const P = ed25519_CURVE_p;
      const v3 = (0, modular_ts_1.mod)(v * v * v, P);
      const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_ts_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    var Fp = (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
    var Fn = (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
    var ed25519Defaults = (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data2, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
    }
    exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha2_js_1.sha512
    })))();
    exports.x25519 = (() => {
      const P = Fp.ORDER;
      return (0, montgomery_ts_1.montgomery)({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    var ELL2_C1 = (() => (ed25519_CURVE_p + _3n) / _8n)();
    var ELL2_C2 = (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
      return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
    }
    exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: ed25519_CURVE_p,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha512
    }))();
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
    function calcElligatorRistrettoMap(r0) {
      const { d } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod = (n) => Fp.create(n);
      const r = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r) * mod(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
      let s_ = mod(s * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
      const s2 = s * s;
      const W0 = mod((s + s) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s2);
      const W3 = mod(_1n + s2);
      return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    function ristretto255_map(bytes) {
      (0, utils_js_1.abytes)(bytes, 64);
      const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new _RistrettoPoint(R1.add(R2));
    }
    var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64));
      }
      static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
          throw new Error("invalid ristretto255 encoding 1");
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32));
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y));
        const u2 = mod(X * Y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * T);
        let D;
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
          let _x = mod(Y * SQRT_M1);
          let _y = mod(X * SQRT_M1);
          X = _x;
          Y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
          Y = mod(-Y);
        let s = mod((Z - Y) * D);
        if ((0, modular_ts_1.isNegativeLE)(s, P))
          s = mod(-s);
        return Fp.toBytes(s);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n) => Fp.create(n);
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
    exports.ristretto255 = { Point: _RistrettoPoint };
    exports.ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = (options == null ? void 0 : options.DST) || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
      }
    };
    exports.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    function edwardsToMontgomeryPub(edwardsPub) {
      return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
    }
    exports.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
    }
    exports.RistrettoPoint = _RistrettoPoint;
    exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
    exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
    exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
  }
});

// node_modules/.pnpm/hash-wasm@4.12.0/node_modules/hash-wasm/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  adler32: () => adler32,
  argon2Verify: () => argon2Verify,
  argon2d: () => argon2d,
  argon2i: () => argon2i,
  argon2id: () => argon2id,
  bcrypt: () => bcrypt,
  bcryptVerify: () => bcryptVerify,
  blake2b: () => blake2b,
  blake2s: () => blake2s,
  blake3: () => blake3,
  crc32: () => crc32,
  crc64: () => crc64,
  createAdler32: () => createAdler32,
  createBLAKE2b: () => createBLAKE2b,
  createBLAKE2s: () => createBLAKE2s,
  createBLAKE3: () => createBLAKE3,
  createCRC32: () => createCRC32,
  createCRC64: () => createCRC64,
  createHMAC: () => createHMAC,
  createKeccak: () => createKeccak,
  createMD4: () => createMD4,
  createMD5: () => createMD5,
  createRIPEMD160: () => createRIPEMD160,
  createSHA1: () => createSHA1,
  createSHA224: () => createSHA224,
  createSHA256: () => createSHA256,
  createSHA3: () => createSHA3,
  createSHA384: () => createSHA384,
  createSHA512: () => createSHA512,
  createSM3: () => createSM3,
  createWhirlpool: () => createWhirlpool,
  createXXHash128: () => createXXHash128,
  createXXHash3: () => createXXHash3,
  createXXHash32: () => createXXHash32,
  createXXHash64: () => createXXHash64,
  keccak: () => keccak,
  md4: () => md4,
  md5: () => md5,
  pbkdf2: () => pbkdf2,
  ripemd160: () => ripemd160,
  scrypt: () => scrypt,
  sha1: () => sha1,
  sha224: () => sha224,
  sha256: () => sha256,
  sha3: () => sha3,
  sha384: () => sha384,
  sha512: () => sha512,
  sm3: () => sm3,
  whirlpool: () => whirlpool,
  xxhash128: () => xxhash128,
  xxhash3: () => xxhash3,
  xxhash32: () => xxhash32,
  xxhash64: () => xxhash64
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  return global;
}
function intArrayToString(arr, len) {
  return String.fromCharCode(...arr.subarray(0, len));
}
function hexCharCodesToInt(a, b) {
  return (a & 15) + (a >> 6 | a >> 3 & 8) << 4 | (b & 15) + (b >> 6 | b >> 3 & 8);
}
function writeHexToUInt8(buf, str) {
  const size = str.length >> 1;
  for (let i = 0; i < size; i++) {
    const index = i << 1;
    buf[i] = hexCharCodesToInt(str.charCodeAt(index), str.charCodeAt(index + 1));
  }
}
function hexStringEqualsUInt8(str, buf) {
  if (str.length !== buf.length * 2) {
    return false;
  }
  for (let i = 0; i < buf.length; i++) {
    const strIndex = i << 1;
    if (buf[i] !== hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {
      return false;
    }
  }
  return true;
}
function getDigestHex(tmpBuffer, input, hashLength) {
  let p = 0;
  for (let i = 0; i < hashLength; i++) {
    let nibble = input[i] >>> 4;
    tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
    nibble = input[i] & 15;
    tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
  }
  return String.fromCharCode.apply(null, tmpBuffer);
}
function encodeBase64(data2, pad = true) {
  const len = data2.length;
  const extraBytes = len % 3;
  const parts = [];
  const len2 = len - extraBytes;
  for (let i = 0; i < len2; i += 3) {
    const tmp = (data2[i] << 16 & 16711680) + (data2[i + 1] << 8 & 65280) + (data2[i + 2] & 255);
    const triplet = base64Chars.charAt(tmp >> 18 & 63) + base64Chars.charAt(tmp >> 12 & 63) + base64Chars.charAt(tmp >> 6 & 63) + base64Chars.charAt(tmp & 63);
    parts.push(triplet);
  }
  if (extraBytes === 1) {
    const tmp = data2[len - 1];
    const a = base64Chars.charAt(tmp >> 2);
    const b = base64Chars.charAt(tmp << 4 & 63);
    parts.push(`${a}${b}`);
    if (pad) {
      parts.push("==");
    }
  } else if (extraBytes === 2) {
    const tmp = (data2[len - 2] << 8) + data2[len - 1];
    const a = base64Chars.charAt(tmp >> 10);
    const b = base64Chars.charAt(tmp >> 4 & 63);
    const c = base64Chars.charAt(tmp << 2 & 63);
    parts.push(`${a}${b}${c}`);
    if (pad) {
      parts.push("=");
    }
  }
  return parts.join("");
}
function getDecodeBase64Length(data2) {
  let bufferLength = Math.floor(data2.length * 0.75);
  const len = data2.length;
  if (data2[len - 1] === "=") {
    bufferLength -= 1;
    if (data2[len - 2] === "=") {
      bufferLength -= 1;
    }
  }
  return bufferLength;
}
function decodeBase64(data2) {
  const bufferLength = getDecodeBase64Length(data2);
  const len = data2.length;
  const bytes = new Uint8Array(bufferLength);
  let p = 0;
  for (let i = 0; i < len; i += 4) {
    const encoded1 = base64Lookup[data2.charCodeAt(i)];
    const encoded2 = base64Lookup[data2.charCodeAt(i + 1)];
    const encoded3 = base64Lookup[data2.charCodeAt(i + 2)];
    const encoded4 = base64Lookup[data2.charCodeAt(i + 3)];
    bytes[p] = encoded1 << 2 | encoded2 >> 4;
    p += 1;
    bytes[p] = (encoded2 & 15) << 4 | encoded3 >> 2;
    p += 1;
    bytes[p] = (encoded3 & 3) << 6 | encoded4 & 63;
    p += 1;
  }
  return bytes;
}
function WASMInterface(binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === "undefined") {
      throw new Error("WebAssembly is not supported in this environment!");
    }
    const writeMemory = (data2, offset = 0) => {
      memoryView.set(data2, offset);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance.exports;
    const setMemorySize = (totalSize) => {
      wasmInstance.exports.Hash_SetMemorySize(totalSize);
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
      const view = new DataView(wasmInstance.exports.memory.buffer);
      const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
      return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
      if (!wasmModuleCache.has(binary.name)) {
        const asm = decodeBase64(binary.data);
        const promise = WebAssembly.compile(asm);
        wasmModuleCache.set(binary.name, promise);
      }
      const module = yield wasmModuleCache.get(binary.name);
      wasmInstance = yield WebAssembly.instantiate(module, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    }));
    const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
      if (!wasmInstance) {
        yield loadWASMPromise;
      }
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
    });
    const init = (bits = null) => {
      initialized = true;
      wasmInstance.exports.Hash_Init(bits);
    };
    const updateUInt8Array = (data2) => {
      let read = 0;
      while (read < data2.length) {
        const chunk = data2.subarray(read, read + MAX_HEAP);
        read += chunk.length;
        memoryView.set(chunk);
        wasmInstance.exports.Hash_Update(chunk.length);
      }
    };
    const update = (data2) => {
      if (!initialized) {
        throw new Error("update() called before init()");
      }
      const Uint8Buffer = getUInt8Buffer(data2);
      updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding = null) => {
      if (!initialized) {
        throw new Error("digest() called before init()");
      }
      initialized = false;
      wasmInstance.exports.Hash_Final(padding);
      if (outputType === "binary") {
        return memoryView.slice(0, hashLength);
      }
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    const save = () => {
      if (!initialized) {
        throw new Error("save() can only be called after init() and before digest()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
      const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
      writeHexToUInt8(prefixedState, binary.hash);
      prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
      return prefixedState;
    };
    const load = (state) => {
      if (!(state instanceof Uint8Array)) {
        throw new Error("load() expects an Uint8Array generated by save()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      if (state.length !== overallLength) {
        throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
      }
      if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
        throw new Error("This state was written by an incompatible hash implementation");
      }
      const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
      new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
      initialized = true;
    };
    const isDataShort = (data2) => {
      if (typeof data2 === "string") {
        return data2.length < MAX_HEAP / 4;
      }
      return data2.byteLength < MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary.name) {
      case "argon2":
      case "scrypt":
        canSimplify = () => true;
        break;
      case "blake2b":
      case "blake2s":
        canSimplify = (data2, initParam) => initParam <= 512 && isDataShort(data2);
        break;
      case "blake3":
        canSimplify = (data2, initParam) => initParam === 0 && isDataShort(data2);
        break;
      case "xxhash64":
      // cannot simplify
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        canSimplify = () => false;
        break;
    }
    const calculate = (data2, initParam = null, digestParam = null) => {
      if (!canSimplify(data2, initParam)) {
        init(initParam);
        update(data2);
        return digest("hex", digestParam);
      }
      const buffer = getUInt8Buffer(data2);
      memoryView.set(buffer);
      wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    yield setupInterface();
    return {
      getMemory,
      writeMemory,
      getExports,
      setMemorySize,
      init,
      update,
      digest,
      save,
      load,
      calculate,
      hashLength
    };
  });
}
function lockedCreate(mutex2, binary, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    const unlock = yield mutex2.lock();
    const wasm = yield WASMInterface(binary, hashLength);
    unlock();
    return wasm;
  });
}
function adler32(data2) {
  if (wasmCache$l === null) {
    return lockedCreate(mutex$l, wasmJson$l, 4).then((wasm) => {
      wasmCache$l = wasm;
      return wasmCache$l.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$l.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createAdler32() {
  return WASMInterface(wasmJson$l, 4).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function validateBits$4(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 512");
  }
  return null;
}
function getInitParam$1(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2b(data2, bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$k === null || wasmCache$k.hashLength !== hashLength) {
    return lockedCreate(mutex$k, wasmJson$j, hashLength).then((wasm) => {
      wasmCache$k = wasm;
      if (initParam > 512) {
        wasmCache$k.writeMemory(keyBuffer);
      }
      return wasmCache$k.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$k.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$k.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2b(bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$j, outputSize).then((wasm) => {
    if (initParam > 512) {
      wasm.writeMemory(keyBuffer);
    }
    wasm.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        return obj;
      } : () => {
        wasm.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: outputSize
    };
    return obj;
  });
}
function encodeResult(salt, options, res) {
  const parameters = [
    `m=${options.memorySize}`,
    `t=${options.iterations}`,
    `p=${options.parallelism}`
  ].join(",");
  return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;
}
function int32LE(x) {
  uint32View.setInt32(0, x, true);
  return new Uint8Array(uint32View.buffer);
}
function hashFunc(blake512, buf, len) {
  return __awaiter(this, void 0, void 0, function* () {
    if (len <= 64) {
      const blake = yield createBLAKE2b(len * 8);
      blake.update(int32LE(len));
      blake.update(buf);
      return blake.digest("binary");
    }
    const r = Math.ceil(len / 32) - 2;
    const ret = new Uint8Array(len);
    blake512.init();
    blake512.update(int32LE(len));
    blake512.update(buf);
    let vp = blake512.digest("binary");
    ret.set(vp.subarray(0, 32), 0);
    for (let i = 1; i < r; i++) {
      blake512.init();
      blake512.update(vp);
      vp = blake512.digest("binary");
      ret.set(vp.subarray(0, 32), i * 32);
    }
    const partialBytesNeeded = len - 32 * r;
    let blakeSmall;
    if (partialBytesNeeded === 64) {
      blakeSmall = blake512;
      blakeSmall.init();
    } else {
      blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);
    }
    blakeSmall.update(vp);
    vp = blakeSmall.digest("binary");
    ret.set(vp.subarray(0, partialBytesNeeded), r * 32);
    return ret;
  });
}
function getHashType(type) {
  switch (type) {
    case "d":
      return 0;
    case "i":
      return 1;
    default:
      return 2;
  }
}
function argon2Internal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    var _a2;
    const { parallelism, iterations, hashLength } = options;
    const password = getUInt8Buffer(options.password);
    const salt = getUInt8Buffer(options.salt);
    const version = 19;
    const hashType = getHashType(options.hashType);
    const { memorySize } = options;
    const secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
    const [argon2Interface, blake512] = yield Promise.all([
      WASMInterface(wasmJson$k, 1024),
      createBLAKE2b(512)
    ]);
    argon2Interface.setMemorySize(memorySize * 1024 + 1024);
    const initVector = new Uint8Array(24);
    const initVectorView = new DataView(initVector.buffer);
    initVectorView.setInt32(0, parallelism, true);
    initVectorView.setInt32(4, hashLength, true);
    initVectorView.setInt32(8, memorySize, true);
    initVectorView.setInt32(12, iterations, true);
    initVectorView.setInt32(16, version, true);
    initVectorView.setInt32(20, hashType, true);
    argon2Interface.writeMemory(initVector, memorySize * 1024);
    blake512.init();
    blake512.update(initVector);
    blake512.update(int32LE(password.length));
    blake512.update(password);
    blake512.update(int32LE(salt.length));
    blake512.update(salt);
    blake512.update(int32LE(secret.length));
    blake512.update(secret);
    blake512.update(int32LE(0));
    const segments = Math.floor(memorySize / (parallelism * 4));
    const lanes = segments * 4;
    const param = new Uint8Array(72);
    const H0 = blake512.digest("binary");
    param.set(H0);
    for (let lane = 0; lane < parallelism; lane++) {
      param.set(int32LE(0), 64);
      param.set(int32LE(lane), 68);
      let position = lane * lanes;
      let chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
      position += 1;
      param.set(int32LE(1), 64);
      chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
    }
    const C = new Uint8Array(1024);
    writeHexToUInt8(C, argon2Interface.calculate(new Uint8Array([]), memorySize));
    const res = yield hashFunc(blake512, C, hashLength);
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, res, hashLength);
    }
    if (options.outputType === "encoded") {
      return encodeResult(salt, options, res);
    }
    return res;
  });
}
function argon2i(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "i" }));
  });
}
function argon2id(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "id" }));
  });
}
function argon2d(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "d" }));
  });
}
function argon2Verify(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateVerifyOptions$1(options);
    const params = getHashParameters(options.password, options.hash, options.secret);
    validateOptions$3(params);
    const hashStart = options.hash.lastIndexOf("$") + 1;
    const result = yield argon2Internal(params);
    return result.substring(hashStart) === options.hash.substring(hashStart);
  });
}
function validateBits$3(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 256 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 256");
  }
  return null;
}
function getInitParam(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2s(data2, bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$j === null || wasmCache$j.hashLength !== hashLength) {
    return lockedCreate(mutex$j, wasmJson$i, hashLength).then((wasm) => {
      wasmCache$j = wasm;
      if (initParam > 512) {
        wasmCache$j.writeMemory(keyBuffer);
      }
      return wasmCache$j.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$j.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$j.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2s(bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$i, outputSize).then((wasm) => {
    if (initParam > 512) {
      wasm.writeMemory(keyBuffer);
    }
    wasm.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        return obj;
      } : () => {
        wasm.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits$2(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ...");
  }
  return null;
}
function blake3(data2, bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const hashLength = bits / 8;
  const digestParam = hashLength;
  if (wasmCache$i === null || wasmCache$i.hashLength !== hashLength) {
    return lockedCreate(mutex$i, wasmJson$h, hashLength).then((wasm) => {
      wasmCache$i = wasm;
      if (initParam === 32) {
        wasmCache$i.writeMemory(keyBuffer);
      }
      return wasmCache$i.calculate(data2, initParam, digestParam);
    });
  }
  try {
    if (initParam === 32) {
      wasmCache$i.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$i.calculate(data2, initParam, digestParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE3(bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const outputSize = bits / 8;
  const digestParam = outputSize;
  return WASMInterface(wasmJson$h, outputSize).then((wasm) => {
    if (initParam === 32) {
      wasm.writeMemory(keyBuffer);
    }
    wasm.init(initParam);
    const obj = {
      init: initParam === 32 ? () => {
        wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        return obj;
      } : () => {
        wasm.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType, digestParam),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validatePoly(poly) {
  if (!Number.isInteger(poly) || poly < 0 || poly > 4294967295) {
    return new Error("Polynomial must be a valid 32-bit long unsigned integer");
  }
  return null;
}
function crc32(data2, polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  if (wasmCache$h === null) {
    return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm) => {
      wasmCache$h = wasm;
      return wasmCache$h.calculate(data2, polynomial);
    });
  }
  try {
    const hash2 = wasmCache$h.calculate(data2, polynomial);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createCRC32(polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  return WASMInterface(wasmJson$g, 4).then((wasm) => {
    wasm.init(polynomial);
    const obj = {
      init: () => {
        wasm.init(polynomial);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function parsePoly(poly) {
  const errText = "Polynomial must be provided as a 16 char long hex string";
  if (typeof poly !== "string" || poly.length !== 16) {
    return { hi: 0, lo: 0, err: new Error(errText) };
  }
  const hi = Number(`0x${poly.slice(0, 8)}`);
  const lo = Number(`0x${poly.slice(8)}`);
  if (Number.isNaN(hi) || Number.isNaN(lo)) {
    return { hi, lo, err: new Error(errText) };
  }
  return { hi, lo, err: null };
}
function writePoly(arr, lo, hi) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, lo, true);
  buffer.setUint32(4, hi, true);
}
function crc64(data2, polynomial = "c96c5795d7870f42") {
  const { hi, lo, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  if (wasmCache$g === null) {
    return lockedCreate(mutex$g, wasmJson$f, 8).then((wasm) => {
      wasmCache$g = wasm;
      writePoly(polyBuffer.buffer, lo, hi);
      wasmCache$g.writeMemory(polyBuffer);
      return wasmCache$g.calculate(data2);
    });
  }
  try {
    writePoly(polyBuffer.buffer, lo, hi);
    wasmCache$g.writeMemory(polyBuffer);
    const hash2 = wasmCache$g.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err2) {
    return Promise.reject(err2);
  }
}
function createCRC64(polynomial = "c96c5795d7870f42") {
  const { hi, lo, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  return WASMInterface(wasmJson$f, 8).then((wasm) => {
    const instanceBuffer = new Uint8Array(8);
    writePoly(instanceBuffer.buffer, lo, hi);
    wasm.writeMemory(instanceBuffer);
    wasm.init();
    const obj = {
      init: () => {
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 8,
      digestSize: 8
    };
    return obj;
  });
}
function md4(data2) {
  if (wasmCache$f === null) {
    return lockedCreate(mutex$f, wasmJson$e, 16).then((wasm) => {
      wasmCache$f = wasm;
      return wasmCache$f.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$f.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD4() {
  return WASMInterface(wasmJson$e, 16).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function md5(data2) {
  if (wasmCache$e === null) {
    return lockedCreate(mutex$e, wasmJson$d, 16).then((wasm) => {
      wasmCache$e = wasm;
      return wasmCache$e.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$e.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD5() {
  return WASMInterface(wasmJson$d, 16).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function sha1(data2) {
  if (wasmCache$d === null) {
    return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm) => {
      wasmCache$d = wasm;
      return wasmCache$d.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$d.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA1() {
  return WASMInterface(wasmJson$c, 20).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function validateBits$1(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function sha3(data2, bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$c === null || wasmCache$c.hashLength !== hashLength) {
    return lockedCreate(mutex$c, wasmJson$b, hashLength).then((wasm) => {
      wasmCache$c = wasm;
      return wasmCache$c.calculate(data2, bits, 6);
    });
  }
  try {
    const hash2 = wasmCache$c.calculate(data2, bits, 6);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA3(bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm) => {
    wasm.init(bits);
    const obj = {
      init: () => {
        wasm.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType, 6),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function keccak(data2, bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$b === null || wasmCache$b.hashLength !== hashLength) {
    return lockedCreate(mutex$b, wasmJson$b, hashLength).then((wasm) => {
      wasmCache$b = wasm;
      return wasmCache$b.calculate(data2, bits, 1);
    });
  }
  try {
    const hash2 = wasmCache$b.calculate(data2, bits, 1);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createKeccak(bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm) => {
    wasm.init(bits);
    const obj = {
      init: () => {
        wasm.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType, 1),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function sha224(data2) {
  if (wasmCache$a === null) {
    return lockedCreate(mutex$a, wasmJson$a, 28).then((wasm) => {
      wasmCache$a = wasm;
      return wasmCache$a.calculate(data2, 224);
    });
  }
  try {
    const hash2 = wasmCache$a.calculate(data2, 224);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA224() {
  return WASMInterface(wasmJson$a, 28).then((wasm) => {
    wasm.init(224);
    const obj = {
      init: () => {
        wasm.init(224);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 28
    };
    return obj;
  });
}
function sha256(data2) {
  if (wasmCache$9 === null) {
    return lockedCreate(mutex$9, wasmJson$a, 32).then((wasm) => {
      wasmCache$9 = wasm;
      return wasmCache$9.calculate(data2, 256);
    });
  }
  try {
    const hash2 = wasmCache$9.calculate(data2, 256);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA256() {
  return WASMInterface(wasmJson$a, 32).then((wasm) => {
    wasm.init(256);
    const obj = {
      init: () => {
        wasm.init(256);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
function sha384(data2) {
  if (wasmCache$8 === null) {
    return lockedCreate(mutex$8, wasmJson$9, 48).then((wasm) => {
      wasmCache$8 = wasm;
      return wasmCache$8.calculate(data2, 384);
    });
  }
  try {
    const hash2 = wasmCache$8.calculate(data2, 384);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA384() {
  return WASMInterface(wasmJson$9, 48).then((wasm) => {
    wasm.init(384);
    const obj = {
      init: () => {
        wasm.init(384);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 48
    };
    return obj;
  });
}
function sha512(data2) {
  if (wasmCache$7 === null) {
    return lockedCreate(mutex$7, wasmJson$9, 64).then((wasm) => {
      wasmCache$7 = wasm;
      return wasmCache$7.calculate(data2, 512);
    });
  }
  try {
    const hash2 = wasmCache$7.calculate(data2, 512);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA512() {
  return WASMInterface(wasmJson$9, 64).then((wasm) => {
    wasm.init(512);
    const obj = {
      init: () => {
        wasm.init(512);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 64
    };
    return obj;
  });
}
function validateSeed$3(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be a valid 32-bit long unsigned integer.");
  }
  return null;
}
function xxhash32(data2, seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  if (wasmCache$6 === null) {
    return lockedCreate(mutex$6, wasmJson$8, 4).then((wasm) => {
      wasmCache$6 = wasm;
      return wasmCache$6.calculate(data2, seed);
    });
  }
  try {
    const hash2 = wasmCache$6.calculate(data2, seed);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash32(seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  return WASMInterface(wasmJson$8, 4).then((wasm) => {
    wasm.init(seed);
    const obj = {
      init: () => {
        wasm.init(seed);
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 16,
      digestSize: 4
    };
    return obj;
  });
}
function validateSeed$2(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$2(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash64(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  if (wasmCache$5 === null) {
    return lockedCreate(mutex$5, wasmJson$7, 8).then((wasm) => {
      wasmCache$5 = wasm;
      writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
      wasmCache$5.writeMemory(seedBuffer$2);
      return wasmCache$5.calculate(data2);
    });
  }
  try {
    writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
    wasmCache$5.writeMemory(seedBuffer$2);
    const hash2 = wasmCache$5.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash64(seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  return WASMInterface(wasmJson$7, 8).then((wasm) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$2(instanceBuffer.buffer, seedLow, seedHigh);
    wasm.writeMemory(instanceBuffer);
    wasm.init();
    const obj = {
      init: () => {
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 32,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed$1(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$1(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash3(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  if (wasmCache$4 === null) {
    return lockedCreate(mutex$4, wasmJson$6, 8).then((wasm) => {
      wasmCache$4 = wasm;
      writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
      wasmCache$4.writeMemory(seedBuffer$1);
      return wasmCache$4.calculate(data2);
    });
  }
  try {
    writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
    wasmCache$4.writeMemory(seedBuffer$1);
    const hash2 = wasmCache$4.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash3(seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  return WASMInterface(wasmJson$6, 8).then((wasm) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$1(instanceBuffer.buffer, seedLow, seedHigh);
    wasm.writeMemory(instanceBuffer);
    wasm.init();
    const obj = {
      init: () => {
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash128(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  if (wasmCache$3 === null) {
    return lockedCreate(mutex$3, wasmJson$5, 16).then((wasm) => {
      wasmCache$3 = wasm;
      writeSeed(seedBuffer.buffer, seedLow, seedHigh);
      wasmCache$3.writeMemory(seedBuffer);
      return wasmCache$3.calculate(data2);
    });
  }
  try {
    writeSeed(seedBuffer.buffer, seedLow, seedHigh);
    wasmCache$3.writeMemory(seedBuffer);
    const hash2 = wasmCache$3.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash128(seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  return WASMInterface(wasmJson$5, 16).then((wasm) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed(instanceBuffer.buffer, seedLow, seedHigh);
    wasm.writeMemory(instanceBuffer);
    wasm.init();
    const obj = {
      init: () => {
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 16
    };
    return obj;
  });
}
function ripemd160(data2) {
  if (wasmCache$2 === null) {
    return lockedCreate(mutex$2, wasmJson$4, 20).then((wasm) => {
      wasmCache$2 = wasm;
      return wasmCache$2.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$2.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createRIPEMD160() {
  return WASMInterface(wasmJson$4, 20).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function calculateKeyBuffer(hasher, key) {
  const { blockSize } = hasher;
  const buf = getUInt8Buffer(key);
  if (buf.length > blockSize) {
    hasher.update(buf);
    const uintArr = hasher.digest("binary");
    hasher.init();
    return uintArr;
  }
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
}
function calculateHmac(hasher, key) {
  hasher.init();
  const { blockSize } = hasher;
  const keyBuf = calculateKeyBuffer(hasher, key);
  const keyBuffer = new Uint8Array(blockSize);
  keyBuffer.set(keyBuf);
  const opad = new Uint8Array(blockSize);
  for (let i = 0; i < blockSize; i++) {
    const v = keyBuffer[i];
    opad[i] = v ^ 92;
    keyBuffer[i] = v ^ 54;
  }
  hasher.update(keyBuffer);
  const obj = {
    init: () => {
      hasher.init();
      hasher.update(keyBuffer);
      return obj;
    },
    update: (data2) => {
      hasher.update(data2);
      return obj;
    },
    digest: (outputType) => {
      const uintArr = hasher.digest("binary");
      hasher.init();
      hasher.update(opad);
      hasher.update(uintArr);
      return hasher.digest(outputType);
    },
    save: () => {
      throw new Error("save() not supported");
    },
    load: () => {
      throw new Error("load() not supported");
    },
    blockSize: hasher.blockSize,
    digestSize: hasher.digestSize
  };
  return obj;
}
function createHMAC(hash2, key) {
  if (!hash2 || !hash2.then) {
    throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), "key").');
  }
  return hash2.then((hasher) => calculateHmac(hasher, key));
}
function calculatePBKDF2(digest, salt, iterations, hashLength, outputType) {
  return __awaiter(this, void 0, void 0, function* () {
    const DK = new Uint8Array(hashLength);
    const block1 = new Uint8Array(salt.length + 4);
    const block1View = new DataView(block1.buffer);
    const saltBuffer = getUInt8Buffer(salt);
    const saltUIntBuffer = new Uint8Array(saltBuffer.buffer, saltBuffer.byteOffset, saltBuffer.length);
    block1.set(saltUIntBuffer);
    let destPos = 0;
    const hLen = digest.digestSize;
    const l = Math.ceil(hashLength / hLen);
    let T = null;
    let U = null;
    for (let i = 1; i <= l; i++) {
      block1View.setUint32(salt.length, i);
      digest.init();
      digest.update(block1);
      T = digest.digest("binary");
      U = T.slice();
      for (let j = 1; j < iterations; j++) {
        digest.init();
        digest.update(U);
        U = digest.digest("binary");
        for (let k = 0; k < hLen; k++) {
          T[k] ^= U[k];
        }
      }
      DK.set(T.subarray(0, hashLength - destPos), destPos);
      destPos += hLen;
    }
    if (outputType === "binary") {
      return DK;
    }
    const digestChars = new Uint8Array(hashLength * 2);
    return getDigestHex(digestChars, DK, hashLength);
  });
}
function pbkdf2(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$2(options);
    const hmac = yield createHMAC(options.hashFunction, options.password);
    return calculatePBKDF2(hmac, options.salt, options.iterations, options.hashLength, options.outputType);
  });
}
function scryptInternal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const { costFactor, blockSize, parallelism, hashLength } = options;
    const SHA256Hasher = createSHA256();
    const blockData = yield pbkdf2({
      password: options.password,
      salt: options.salt,
      iterations: 1,
      hashLength: 128 * blockSize * parallelism,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    const scryptInterface = yield WASMInterface(wasmJson$3, 0);
    const VSize = 128 * blockSize * costFactor;
    const XYSize = 256 * blockSize;
    scryptInterface.setMemorySize(blockData.length + VSize + XYSize);
    scryptInterface.writeMemory(blockData, 0);
    scryptInterface.getExports().scrypt(blockSize, costFactor, parallelism);
    const expensiveSalt = scryptInterface.getMemory().subarray(0, 128 * blockSize * parallelism);
    const outputData = yield pbkdf2({
      password: options.password,
      salt: expensiveSalt,
      iterations: 1,
      hashLength,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, outputData, hashLength);
    }
    return outputData;
  });
}
function scrypt(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$1(options);
    return scryptInternal(options);
  });
}
function bcryptInternal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const { costFactor, password, salt } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(salt), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 16);
    const shouldEncode = options.outputType === "encoded" ? 1 : 0;
    bcryptInterface.getExports().bcrypt(passwordBuffer.length, costFactor, shouldEncode);
    const memory = bcryptInterface.getMemory();
    if (options.outputType === "encoded") {
      return intArrayToString(memory, 60);
    }
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(24 * 2);
      return getDigestHex(digestChars, memory, 24);
    }
    return memory.slice(0, 24);
  });
}
function bcrypt(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions(options);
    return bcryptInternal(options);
  });
}
function bcryptVerify(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateVerifyOptions(options);
    const { hash: hash2, password } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(hash2), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 60);
    return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);
  });
}
function whirlpool(data2) {
  if (wasmCache$1 === null) {
    return lockedCreate(mutex$1, wasmJson$1, 64).then((wasm) => {
      wasmCache$1 = wasm;
      return wasmCache$1.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$1.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createWhirlpool() {
  return WASMInterface(wasmJson$1, 64).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 64
    };
    return obj;
  });
}
function sm3(data2) {
  if (wasmCache === null) {
    return lockedCreate(mutex, wasmJson, 32).then((wasm) => {
      wasmCache = wasm;
      return wasmCache.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSM3() {
  return WASMInterface(wasmJson, 32).then((wasm) => {
    wasm.init();
    const obj = {
      init: () => {
        wasm.init();
        return obj;
      },
      update: (data2) => {
        wasm.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm.digest(outputType),
      save: () => wasm.save(),
      load: (data2) => {
        wasm.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
var name$l, data$l, hash$l, wasmJson$l, Mutex, _a, globalObject, nodeBuffer, textEncoder, alpha, digit, getUInt8Buffer, base64Chars, base64Lookup, MAX_HEAP, WASM_FUNC_HASH_LENGTH, wasmMutex, wasmModuleCache, mutex$l, wasmCache$l, name$k, data$k, hash$k, wasmJson$k, name$j, data$j, hash$j, wasmJson$j, mutex$k, wasmCache$k, uint32View, validateOptions$3, getHashParameters, validateVerifyOptions$1, name$i, data$i, hash$i, wasmJson$i, mutex$j, wasmCache$j, name$h, data$h, hash$h, wasmJson$h, mutex$i, wasmCache$i, name$g, data$g, hash$g, wasmJson$g, mutex$h, wasmCache$h, name$f, data$f, hash$f, wasmJson$f, mutex$g, wasmCache$g, polyBuffer, name$e, data$e, hash$e, wasmJson$e, mutex$f, wasmCache$f, name$d, data$d, hash$d, wasmJson$d, mutex$e, wasmCache$e, name$c, data$c, hash$c, wasmJson$c, mutex$d, wasmCache$d, name$b, data$b, hash$b, wasmJson$b, mutex$c, wasmCache$c, mutex$b, wasmCache$b, name$a, data$a, hash$a, wasmJson$a, mutex$a, wasmCache$a, mutex$9, wasmCache$9, name$9, data$9, hash$9, wasmJson$9, mutex$8, wasmCache$8, mutex$7, wasmCache$7, name$8, data$8, hash$8, wasmJson$8, mutex$6, wasmCache$6, name$7, data$7, hash$7, wasmJson$7, mutex$5, wasmCache$5, seedBuffer$2, name$6, data$6, hash$6, wasmJson$6, mutex$4, wasmCache$4, seedBuffer$1, name$5, data$5, hash$5, wasmJson$5, mutex$3, wasmCache$3, seedBuffer, name$4, data$4, hash$4, wasmJson$4, mutex$2, wasmCache$2, validateOptions$2, name$3, data$3, hash$3, wasmJson$3, isPowerOfTwo, validateOptions$1, name$2, data$2, hash$2, wasmJson$2, validateOptions, validateHashCharacters, validateVerifyOptions, name$1, data$1, hash$1, wasmJson$1, mutex$1, wasmCache$1, name, data, hash, wasmJson, mutex, wasmCache;
var init_index_esm = __esm({
  "node_modules/.pnpm/hash-wasm@4.12.0/node_modules/hash-wasm/dist/index.esm.js"() {
    name$l = "adler32";
    data$l = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAgUEAQECAgYOAn8BQYCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEK6wkGBQBBgAkLCgBBAEEBNgKECAvjCAEHf0EAKAKECCIBQf//A3EhAiABQRB2IQMCQAJAIABBAUcNACACQQAtAIAJaiIBQY+AfGogASABQfD/A0sbIgEgA2oiBEEQdCIFQYCAPGogBSAEQfD/A0sbIAFyIQEMAQsCQAJAAkACQAJAIABBEEkNAEGACSEGIABBsCtJDQFBgAkhBgNAQQAhBQNAIAYgBWoiASgCACIEQf8BcSACaiICIANqIAIgBEEIdkH/AXFqIgJqIAIgBEEQdkH/AXFqIgJqIAIgBEEYdmoiAmogAiABQQRqKAIAIgRB/wFxaiICaiACIARBCHZB/wFxaiICaiACIARBEHZB/wFxaiICaiACIARBGHZqIgJqIAIgAUEIaigCACIEQf8BcWoiAmogAiAEQQh2Qf8BcWoiAmogAiAEQRB2Qf8BcWoiAmogAiAEQRh2aiIEaiAEIAFBDGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiAmohAyAFQRBqIgVBsCtHDQALIANB8f8DcCEDIAJB8f8DcCECIAZBsCtqIQYgAEHQVGoiAEGvK0sNAAsgAEUNBCAAQQ9LDQEMAgsCQCAARQ0AAkACQCAAQQNxIgUNAEGACSEBIAAhBAwBCyAAQXxxIQRBACEBA0AgAiABQYAJai0AAGoiAiADaiEDIAUgAUEBaiIBRw0ACyAFQYAJaiEBCyAAQQRJDQADQCACIAEtAABqIgUgAS0AAWoiBiABLQACaiIAIAFBA2otAABqIgIgACAGIAUgA2pqamohAyABQQRqIQEgBEF8aiIEDQALCyACQY+AfGogAiACQfD/A0sbIANB8f8DcEEQdHIhAQwECwNAIAYoAgAiAUH/AXEgAmoiBCADaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgRqIAQgBkEEaigCACIBQf8BcWoiBGogBCABQQh2Qf8BcWoiBGogBCABQRB2Qf8BcWoiBGogBCABQRh2aiIEaiAEIAZBCGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiBGogBCAGQQxqKAIAIgFB/wFxaiIEaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgJqIQMgBkEQaiEGIABBcGoiAEEPSw0ACyAARQ0BCyAAQX9qIQcCQCAAQQNxIgVFDQAgAEF8cSEAIAUhBCAGIQEDQCACIAEtAABqIgIgA2ohAyABQQFqIQEgBEF/aiIEDQALIAYgBWohBgsgB0EDSQ0AA0AgAiAGLQAAaiIBIAYtAAFqIgQgBi0AAmoiBSAGQQNqLQAAaiICIAUgBCABIANqampqIQMgBkEEaiEGIABBfGoiAA0ACwsgA0Hx/wNwIQMgAkHx/wNwIQILIAIgA0EQdHIhAQtBACABNgKECAsxAQF/QQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwUAQYQICzsAQQBBATYChAggABACQQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwsVAgBBgAgLBAQAAAAAQYQICwQBAAAA";
    hash$l = "02ddbd17";
    wasmJson$l = {
      name: name$l,
      data: data$l,
      hash: hash$l
    };
    Mutex = class {
      constructor() {
        this.mutex = Promise.resolve();
      }
      lock() {
        let begin = () => {
        };
        this.mutex = this.mutex.then(() => new Promise(begin));
        return new Promise((res) => {
          begin = res;
        });
      }
      dispatch(fn) {
        return __awaiter(this, void 0, void 0, function* () {
          const unlock = yield this.lock();
          try {
            return yield Promise.resolve(fn());
          } finally {
            unlock();
          }
        });
      }
    };
    globalObject = getGlobal();
    nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
    textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
    alpha = "a".charCodeAt(0) - 10;
    digit = "0".charCodeAt(0);
    getUInt8Buffer = nodeBuffer !== null ? (data2) => {
      if (typeof data2 === "string") {
        const buf = nodeBuffer.from(data2, "utf8");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
      if (nodeBuffer.isBuffer(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.length);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    } : (data2) => {
      if (typeof data2 === "string") {
        return textEncoder.encode(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    };
    base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    base64Lookup = new Uint8Array(256);
    for (let i = 0; i < base64Chars.length; i++) {
      base64Lookup[base64Chars.charCodeAt(i)] = i;
    }
    MAX_HEAP = 16 * 1024;
    WASM_FUNC_HASH_LENGTH = 4;
    wasmMutex = new Mutex();
    wasmModuleCache = /* @__PURE__ */ new Map();
    mutex$l = new Mutex();
    wasmCache$l = null;
    name$k = "argon2";
    data$k = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkD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";
    hash$k = "e4cdc523";
    wasmJson$k = {
      name: name$k,
      data: data$k,
      hash: hash$k
    };
    name$j = "blake2b";
    data$j = "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";
    hash$j = "c6f286e6";
    wasmJson$j = {
      name: name$j,
      data: data$j,
      hash: hash$j
    };
    mutex$k = new Mutex();
    wasmCache$k = null;
    uint32View = new DataView(new ArrayBuffer(4));
    validateOptions$3 = (options) => {
      var _a2;
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.password) {
        throw new Error("Password must be specified");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password must be specified");
      }
      if (!options.salt) {
        throw new Error("Salt must be specified");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length < 8) {
        throw new Error("Salt should be at least 8 bytes long");
      }
      options.secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 4) {
        throw new Error("Hash length should be at least 4 bytes.");
      }
      if (!Number.isInteger(options.memorySize)) {
        throw new Error("Memory size should be specified.");
      }
      if (options.memorySize < 8 * options.parallelism) {
        throw new Error("Memory size should be at least 8 * parallelism.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    getHashParameters = (password, encoded, secret) => {
      const regex = /^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/;
      const match = encoded.match(regex);
      if (!match) {
        throw new Error("Invalid hash");
      }
      const [, hashType, version, parameters, salt, hash2] = match;
      if (version !== "19") {
        throw new Error(`Unsupported version: ${version}`);
      }
      const parsedParameters = {};
      const paramMap = { m: "memorySize", p: "parallelism", t: "iterations" };
      for (const x of parameters.split(",")) {
        const [n, v] = x.split("=");
        parsedParameters[paramMap[n]] = Number(v);
      }
      return Object.assign(Object.assign({}, parsedParameters), {
        password,
        secret,
        hashType,
        salt: decodeBase64(salt),
        hashLength: getDecodeBase64Length(hash2),
        outputType: "encoded"
      });
    };
    validateVerifyOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
    };
    name$i = "blake2s";
    data$i = "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";
    hash$i = "5c0ff166";
    wasmJson$i = {
      name: name$i,
      data: data$i,
      hash: hash$i
    };
    mutex$j = new Mutex();
    wasmCache$j = null;
    name$h = "blake3";
    data$h = "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IQEgAkFAaiICQcAASw0ACwsCQEHAACAHQf8BcSIGayIFIAIgBSACSRsiCUUNACAJQQNxIQtBACEFAkAgCUEESQ0AIAAgBmohByAJQfwAcSEIQQAhBQNAIAcgBWoiAkEoaiABIAVqIgotAAA6AAAgAkEpaiAKQQFqLQAAOgAAIAJBKmogCkECai0AADoAACACQStqIApBA2otAAA6AAAgCCAFQQRqIgVHDQALCwJAIAtFDQAgASAFaiEBIAUgBmogAGpBKGohBQNAIAUgAS0AADoAACABQQFqIQEgBUEBaiEFIAtBf2oiCw0ACwsgAC0AaCEHCyAAIAcgCWo6AGggA0HAAGokAAveAwQFfwN+BX8GfiMAQdABayIBJAACQCAAe6ciAkEALQCQigEiA08NAEEALQCKigFBBHIhBCABQShqIQVBACkDmIkBIQBBACkDkIkBIQZBACkDiIkBIQdBACkDgIkBIQggAyEJA0AgASAANwMYIAEgBjcDECABIAc3AwggASAINwMAIAEgA0EFdCIDQdGJAWoiCikDADcDKCABIANB2YkBaiILKQMANwMwIAEgA0HhiQFqIgwpAwA3AzggASADQemJAWoiDSkDADcDQCABIANB8YkBaikDADcDSCABIANB+YkBaikDADcDUCABIANBgYoBaikDADcDWCADQYmKAWopAwAhDiABQcAAOgBoIAEgDjcDYCABQgA3AyAgASAEOgBpIAEgADcDiAEgASAGNwOAASABIAc3A3ggASAINwNwIAFBkAFqIAFB8ABqIAVBwABCACAEQf8BcRACIAEpA7ABIQ4gASkDkAEhDyABKQO4ASEQIAEpA5gBIREgASkDwAEhEiABKQOgASETIA0gASkDyAEgASkDqAGFNwMAIAwgEiAThTcDACALIBAgEYU3AwAgCiAOIA+FNwMAIAlBf2oiCUH/AXEiAyACSw0AC0EAIAk6AJCKAQsgAUHQAWokAAvHCQIKfwV+IwBB4AJrIgUkAAJAAkAgAUGACEsNACAFIAA2AvwBIAVB/AFqIAFBgAhGIgZBECACQQEgA0EBQQIgBBABIAZBCnQiByABTw0BIAVB4ABqIgZCADcDACAFQdgAaiIIQgA3AwAgBUHQAGoiCUIANwMAIAVByABqIgpCADcDACAFQcAAaiILQgA3AwAgBUE4aiIMQgA3AwAgBUEwaiINQgA3AwAgBSADOgBqIAVCADcDKCAFQQA7AWggBUEAKQOAiQE3AwAgBUEAKQOIiQE3AwggBUEAKQOQiQE3AxAgBUEAKQOYiQE3AxggBSABQYAIRiIOrSACfDcDICAFIAAgB2pBACABIA4bEAQgBUGIAWpBMGogDSkDADcDACAFQYgBakE4aiAMKQMANwMAIAUgBSkDACIPNwOIASAFIAUpAwgiEDcDkAEgBSAFKQMQIhE3A5gBIAUgBSkDGCISNwOgASAFIAUpAyg3A7ABIAUtAGohACAFLQBpIQcgBSkDICECIAUtAGghASAFQYgBakHAAGogCykDADcDACAFQYgBakHIAGogCikDADcDACAFQYgBakHQAGogCSkDADcDACAFQYgBakHYAGogCCkDADcDACAFQYgBakHgAGogBikDADcDACAFIAE6APABIAUgAjcDqAEgBSAAIAdFckECciIAOgDxASAFIBI3A5gCIAUgETcDkAIgBSAQNwOIAiAFIA83A4ACIAVBoAJqIAVBgAJqIAVBsAFqIAEgAiAAQf8BcRACIAUpA8ACIQIgBSkDoAIhDyAFKQPIAiEQIAUpA6gCIREgBSkD0AIhEiAFKQOwAiETIAQgDkEFdGoiASAFKQPYAiAFKQO4AoU3AxggASASIBOFNwMQIAEgECARhTcDCCABIAIgD4U3AwBBAkEBIA4bIQYMAQsgAEIBIAFBf2pBCnZBAXKteUI/hYYiD6dBCnQiDiACIAMgBRAGIQcgACAOaiABIA5rIA9C////AYMgAnwgAyAFQcAAQSAgDkGACEsbahAGIQECQCAHQQFHDQAgBCAFKQMANwMAIAQgBSkDCDcDCCAEIAUpAxA3AxAgBCAFKQMYNwMYIAQgBSkDIDcDICAEIAUpAyg3AyggBCAFKQMwNwMwIAQgBSkDODcDOEECIQYMAQtBACEGQQAhAAJAIAEgB2oiCUECSQ0AIAlBfmoiCkEBdkEBaiIGQQNxIQ5BACEHAkAgCkEGSQ0AIAZB/P///wdxIQhBACEHIAVBiAFqIQEgBSEAA0AgASAANgIAIAFBDGogAEHAAWo2AgAgAUEIaiAAQYABajYCACABQQRqIABBwABqNgIAIABBgAJqIQAgAUEQaiEBIAggB0EEaiIHRw0ACwsgCkF+cSEIAkAgDkUNACAFIAdBBnRqIQEgBUGIAWogB0ECdGohAANAIAAgATYCACABQcAAaiEBIABBBGohACAOQX9qIg4NAAsLIAhBAmohAAsgBUGIAWogBkEBQgBBACADQQRyQQBBACAEEAEgACAJTw0AIAQgBkEFdGoiASAFIAZBBnRqIgApAwA3AwAgASAAKQMINwMIIAEgACkDEDcDECABIAApAxg3AxggBkEBaiEGCyAFQeACaiQAIAYLrRAIAn8EfgF/AX4EfwR+BH8EfiMAQfABayIBJAACQCAARQ0AAkBBAC0AkIoBIgINACABQTBqQQApA9CJATcDACABQThqQQApA9iJATcDACABQQApA6CJASIDNwMAIAFBACkDqIkBIgQ3AwggAUEAKQOwiQEiBTcDECABQQApA7iJASIGNwMYIAFBACkDyIkBNwMoQQAtAIqKASECQQAtAImKASEHQQApA8CJASEIQQAtAIiKASEJIAFBwABqQQApA+CJATcDACABQcgAakEAKQPoiQE3AwAgAUHQAGpBACkD8IkBNwMAIAFB2ABqQQApA/iJATcDACABQeAAakEAKQOAigE3AwAgASAJOgBoIAEgCDcDICABIAIgB0VyIgJBAnI6AGkgAUEoaiEKQgAhCEGACSELIAJBCnJB/wFxIQwDQCABQbABaiABIAogCUH/AXEgCCAMEAIgASABKQPQASINIAEpA7ABhTcDcCABIAEpA9gBIg4gASkDuAGFNwN4IAEgASkD4AEiDyABKQPAAYU3A4ABIAEgASkD6AEiECAGhTcDqAEgASAPIAWFNwOgASABIA4gBIU3A5gBIAEgDSADhTcDkAEgASAQIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQAMAgsLAkACQAJAQQAtAImKASIHQQZ0QQBBAC0AiIoBIhFrRg0AIAEgEToAaCABQQApA4CKATcDYCABQQApA/iJATcDWCABQQApA/CJATcDUCABQQApA+iJATcDSCABQQApA+CJATcDQCABQQApA9iJATcDOCABQQApA9CJATcDMCABQQApA8iJATcDKCABQQApA8CJASIINwMgIAFBACkDuIkBIgM3AxggAUEAKQOwiQEiBDcDECABQQApA6iJASIFNwMIIAFBACkDoIkBIgY3AwAgAUEALQCKigEiEyAHRXJBAnIiCzoAaSATQQRyIRNBACkDmIkBIQ1BACkDkIkBIQ5BACkDiIkBIQ9BACkDgIkBIRAMAQtBwAAhESABQcAAOgBoQgAhCCABQgA3AyAgAUEAKQOYiQEiDTcDGCABQQApA5CJASIONwMQIAFBACkDiIkBIg83AwggAUEAKQOAiQEiEDcDACABQQAtAIqKAUEEciITOgBpIAEgAkF+aiICQQV0IgdByYoBaikDADcDYCABIAdBwYoBaikDADcDWCABIAdBuYoBaikDADcDUCABIAdBsYoBaikDADcDSCABIAdBqYoBaikDADcDQCABIAdBoYoBaikDADcDOCABIAdBmYoBaikDADcDMCABIAdBkYoBaikDADcDKCATIQsgECEGIA8hBSAOIQQgDSEDIAJFDQELIAJBf2oiB0EFdCIUQZGKAWopAwAhFSAUQZmKAWopAwAhFiAUQaGKAWopAwAhFyAUQamKAWopAwAhGCABIAM3A4gBIAEgBDcDgAEgASAFNwN4IAEgBjcDcCABQbABaiABQfAAaiABQShqIhQgESAIIAtB/wFxEAIgASATOgBpIAFBwAA6AGggASAYNwNAIAEgFzcDOCABIBY3AzAgASAVNwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggB0UNACACQQV0QemJAWohAiATQf8BcSERA0AgAkFoaikDACEIIAJBcGopAwAhAyACQXhqKQMAIQQgAikDACEFIAEgDTcDiAEgASAONwOAASABIA83A3ggASAQNwNwIAFBsAFqIAFB8ABqIBRBwABCACAREAIgASATOgBpIAFBwAA6AGggASAFNwNAIAEgBDcDOCABIAM3AzAgASAINwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggAkFgaiECIAdBf2oiBw0ACwsgAUEoaiEJQgAhCEGACSELIBNBCHJB/wFxIQoDQCABQbABaiABIAlBwAAgCCAKEAIgASABKQPQASIDIAEpA7ABhTcDcCABIAEpA9gBIgQgASkDuAGFNwN4IAEgASkD4AEiBSABKQPAAYU3A4ABIAEgDSABKQPoASIGhTcDqAEgASAOIAWFNwOgASABIA8gBIU3A5gBIAEgECADhTcDkAEgASAGIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQALCyABQfABaiQAC6MCAQR+AkACQCAAQSBGDQBCq7OP/JGjs/DbACEBQv+kuYjFkdqCm38hAkLy5rvjo6f9p6V/IQNC58yn0NbQ67O7fyEEQQAhAAwBC0EAKQOYCSEBQQApA5AJIQJBACkDiAkhA0EAKQOACSEEQRAhAAtBACAAOgCKigFBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEIANwPAiQFBACABNwO4iQFBACACNwOwiQFBACADNwOoiQFBACAENwOgiQFBACABNwOYiQFBACACNwOQiQFBACADNwOIiQFBACAENwOAiQFBAEEAOgCQigFBAEEAOwGIigELBgAgABADCwYAIAAQBwsGAEGAiQELqwIBBH4CQAJAIAFBIEYNAEKrs4/8kaOz8NsAIQNC/6S5iMWR2oKbfyEEQvLmu+Ojp/2npX8hBULnzKfQ1tDrs7t/IQZBACEBDAELQQApA5gJIQNBACkDkAkhBEEAKQOICSEFQQApA4AJIQZBECEBC0EAIAE6AIqKAUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQgA3A8CJAUEAIAM3A7iJAUEAIAQ3A7CJAUEAIAU3A6iJAUEAIAY3A6CJAUEAIAM3A5iJAUEAIAQ3A5CJAUEAIAU3A4iJAUEAIAY3A4CJAUEAQQA6AJCKAUEAQQA7AYiKASAAEAMgAhAHCwsLAQBBgAgLBHgHAAA=";
    hash$h = "215d875f";
    wasmJson$h = {
      name: name$h,
      data: data$h,
      hash: hash$h
    };
    mutex$i = new Mutex();
    wasmCache$i = null;
    name$g = "crc32";
    data$g = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
    hash$g = "d2eba587";
    wasmJson$g = {
      name: name$g,
      data: data$g,
      hash: hash$g
    };
    mutex$h = new Mutex();
    wasmCache$h = null;
    name$f = "crc64";
    data$f = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQZCJBgt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKgwgGBQBBgAkL9QMDAX4BfwJ+AkBBACkDgIkCQQApA4AJIgBRDQBBgIkBIQFCACECA0AgAUIAQgBCAEIAQgBCAEIAQgAgAkIBg30gAIMgAkIBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIU3AwAgAUEIaiEBIAJCAXwiAkKAAlINAAtBACEBA0AgAUGImQFqIAFBiIkBaikDACICp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiKkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiLkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiMkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiNkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiOkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiPkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhTcDACABQQhqIgFB+A9HDQALQQAgADcDgIkCC0EAQgA3A4iJAguUAwIBfgJ/QQApA4iJAkJ/hSEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAIpAwAgAYUiAUIwiKdB/wFxQQN0QYCZAWopAwAgAUI4iKdBA3RBgIkBaikDAIUgAUIoiKdB/wFxQQN0QYCpAWopAwCFIAFCIIinQf8BcUEDdEGAuQFqKQMAhSABpyIDQRV2QfgPcUGAyQFqKQMAhSADQQ12QfgPcUGA2QFqKQMAhSADQQV2QfgPcUGA6QFqKQMAhSADQf8BcUEDdEGA+QFqKQMAhSEBIAJBCGohAiAAQXhqIgBBB0sNAAsLAkAgAEUNAAJAAkAgAEEBcQ0AIAAhAwwBCyABQv8BgyACMQAAhadBA3RBgIkBaikDACABQgiIhSEBIAJBAWohAiAAQX9qIQMLIABBAUYNAANAIAFC/wGDIAIxAACFp0EDdEGAiQFqKQMAIAFCCIiFIgFC/wGDIAJBAWoxAACFp0EDdEGAiQFqKQMAIAFCCIiFIQEgAkECaiECIANBfmoiAw0ACwtBACABQn+FNwOIiQILZAEBfkEAQQApA4iJAiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGIiQILAgALCwsBAEGACAsECAAAAA==";
    hash$f = "c5ac6c16";
    wasmJson$f = {
      name: name$f,
      data: data$f,
      hash: hash$f
    };
    mutex$g = new Mutex();
    wasmCache$g = null;
    polyBuffer = new Uint8Array(8);
    name$e = "md4";
    data$e = "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";
    hash$e = "bd8ce7c7";
    wasmJson$e = {
      name: name$e,
      data: data$e,
      hash: hash$e
    };
    mutex$f = new Mutex();
    wasmCache$f = null;
    name$d = "md5";
    data$d = "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";
    hash$d = "e6508e4b";
    wasmJson$d = {
      name: name$d,
      data: data$d,
      hash: hash$d
    };
    mutex$e = new Mutex();
    wasmCache$e = null;
    name$c = "sha1";
    data$c = "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";
    hash$c = "6b530c24";
    wasmJson$c = {
      name: name$c,
      data: data$c,
      hash: hash$c
    };
    mutex$d = new Mutex();
    wasmCache$d = null;
    name$b = "sha3";
    data$b = "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";
    hash$b = "fb24e536";
    wasmJson$b = {
      name: name$b,
      data: data$b,
      hash: hash$b
    };
    mutex$c = new Mutex();
    wasmCache$c = null;
    mutex$b = new Mutex();
    wasmCache$b = null;
    name$a = "sha256";
    data$a = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQfCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKnEoHBQBBgAkLnQEAQQBCADcDwIkBQQBBHEEgIABB4AFGIgAbNgLoiQFBAEKnn+anxvST/b5/Qquzj/yRo7Pw2wAgABs3A+CJAUEAQrGWgP6fooWs6ABC/6S5iMWR2oKbfyAAGzcD2IkBQQBCl7rDg5Onlod3QvLmu+Ojp/2npX8gABs3A9CJAUEAQti9loj8oLW+NkLnzKfQ1tDrs7t/IAAbNwPIiQEL7wICAX4Gf0EAQQApA8CJASIBIACtfDcDwIkBAkACQAJAIAGnQT9xIgINAEGACSEDDAELAkBBwAAgAmsiBCAAIAQgAEkbIgNFDQAgA0EDcSEFIAJBgIkBaiEGQQAhAgJAIANBBEkNACADQfwAcSEHQQAhAgNAIAYgAmoiAyACQYAJai0AADoAACADQQFqIAJBgQlqLQAAOgAAIANBAmogAkGCCWotAAA6AAAgA0EDaiACQYMJai0AADoAACAHIAJBBGoiAkcNAAsLIAVFDQADQCAGIAJqIAJBgAlqLQAAOgAAIAJBAWohAiAFQX9qIgUNAAsLIAAgBEkNAUGAiQEQAyAAIARrIQAgBEGACWohAwsCQCAAQcAASQ0AA0AgAxADIANBwABqIQMgAEFAaiIAQT9LDQALCyAARQ0AQQAhAkEAIQUDQCACQYCJAWogAyACai0AADoAACACQQFqIQIgACAFQQFqIgVB/wFxSw0ACwsLoz4BRX9BACAAKAI8IgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyIgFBGXcgAUEOd3MgAUEDdnMgACgCOCICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciICaiAAKAIgIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgRBGXcgBEEOd3MgBEEDdnMgACgCHCIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIFaiAAKAIEIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgZBGXcgBkEOd3MgBkEDdnMgACgCACIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIHaiAAKAIkIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIghqIAJBD3cgAkENd3MgAkEKdnNqIgNqIAAoAhgiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiCkEZdyAKQQ53cyAKQQN2cyAAKAIUIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIgtqIAJqIAAoAhAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDEEZdyAMQQ53cyAMQQN2cyAAKAIMIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIg1qIAAoAjAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDmogACgCCCIJQRh0IAlBgP4DcUEIdHIgCUEIdkGA/gNxIAlBGHZyciIPQRl3IA9BDndzIA9BA3ZzIAZqIAAoAigiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiEGogAUEPdyABQQ13cyABQQp2c2oiCUEPdyAJQQ13cyAJQQp2c2oiEUEPdyARQQ13cyARQQp2c2oiEkEPdyASQQ13cyASQQp2c2oiE2ogACgCNCIUQRh0IBRBgP4DcUEIdHIgFEEIdkGA/gNxIBRBGHZyciIVQRl3IBVBDndzIBVBA3ZzIA5qIBJqIAAoAiwiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnIiFkEZdyAWQQ53cyAWQQN2cyAQaiARaiAIQRl3IAhBDndzIAhBA3ZzIARqIAlqIAVBGXcgBUEOd3MgBUEDdnMgCmogAWogC0EZdyALQQ53cyALQQN2cyAMaiAVaiANQRl3IA1BDndzIA1BA3ZzIA9qIBZqIANBD3cgA0ENd3MgA0EKdnNqIhRBD3cgFEENd3MgFEEKdnNqIhdBD3cgF0ENd3MgF0EKdnNqIhhBD3cgGEENd3MgGEEKdnNqIhlBD3cgGUENd3MgGUEKdnNqIhpBD3cgGkENd3MgGkEKdnNqIhtBD3cgG0ENd3MgG0EKdnNqIhxBGXcgHEEOd3MgHEEDdnMgAkEZdyACQQ53cyACQQN2cyAVaiAYaiAOQRl3IA5BDndzIA5BA3ZzIBZqIBdqIBBBGXcgEEEOd3MgEEEDdnMgCGogFGogE0EPdyATQQ13cyATQQp2c2oiHUEPdyAdQQ13cyAdQQp2c2oiHkEPdyAeQQ13cyAeQQp2c2oiH2ogE0EZdyATQQ53cyATQQN2cyAYaiADQRl3IANBDndzIANBA3ZzIAFqIBlqIB9BD3cgH0ENd3MgH0EKdnNqIiBqIBJBGXcgEkEOd3MgEkEDdnMgF2ogH2ogEUEZdyARQQ53cyARQQN2cyAUaiAeaiAJQRl3IAlBDndzIAlBA3ZzIANqIB1qIBxBD3cgHEENd3MgHEEKdnNqIiFBD3cgIUENd3MgIUEKdnNqIiJBD3cgIkENd3MgIkEKdnNqIiNBD3cgI0ENd3MgI0EKdnNqIiRqIBtBGXcgG0EOd3MgG0EDdnMgHmogI2ogGkEZdyAaQQ53cyAaQQN2cyAdaiAiaiAZQRl3IBlBDndzIBlBA3ZzIBNqICFqIBhBGXcgGEEOd3MgGEEDdnMgEmogHGogF0EZdyAXQQ53cyAXQQN2cyARaiAbaiAUQRl3IBRBDndzIBRBA3ZzIAlqIBpqICBBD3cgIEENd3MgIEEKdnNqIiVBD3cgJUENd3MgJUEKdnNqIiZBD3cgJkENd3MgJkEKdnNqIidBD3cgJ0ENd3MgJ0EKdnNqIihBD3cgKEENd3MgKEEKdnNqIilBD3cgKUENd3MgKUEKdnNqIipBD3cgKkENd3MgKkEKdnNqIitBGXcgK0EOd3MgK0EDdnMgH0EZdyAfQQ53cyAfQQN2cyAbaiAnaiAeQRl3IB5BDndzIB5BA3ZzIBpqICZqIB1BGXcgHUEOd3MgHUEDdnMgGWogJWogJEEPdyAkQQ13cyAkQQp2c2oiLEEPdyAsQQ13cyAsQQp2c2oiLUEPdyAtQQ13cyAtQQp2c2oiLmogJEEZdyAkQQ53cyAkQQN2cyAnaiAgQRl3ICBBDndzICBBA3ZzIBxqIChqIC5BD3cgLkENd3MgLkEKdnNqIi9qICNBGXcgI0EOd3MgI0EDdnMgJmogLmogIkEZdyAiQQ53cyAiQQN2cyAlaiAtaiAhQRl3ICFBDndzICFBA3ZzICBqICxqICtBD3cgK0ENd3MgK0EKdnNqIjBBD3cgMEENd3MgMEEKdnNqIjFBD3cgMUENd3MgMUEKdnNqIjJBD3cgMkENd3MgMkEKdnNqIjNqICpBGXcgKkEOd3MgKkEDdnMgLWogMmogKUEZdyApQQ53cyApQQN2cyAsaiAxaiAoQRl3IChBDndzIChBA3ZzICRqIDBqICdBGXcgJ0EOd3MgJ0EDdnMgI2ogK2ogJkEZdyAmQQ53cyAmQQN2cyAiaiAqaiAlQRl3ICVBDndzICVBA3ZzICFqIClqIC9BD3cgL0ENd3MgL0EKdnNqIjRBD3cgNEENd3MgNEEKdnNqIjVBD3cgNUENd3MgNUEKdnNqIjZBD3cgNkENd3MgNkEKdnNqIjdBD3cgN0ENd3MgN0EKdnNqIjhBD3cgOEENd3MgOEEKdnNqIjlBD3cgOUENd3MgOUEKdnNqIjogOCA0IC4gLCAhIBsgGSADIA4gBEEAKALYiQEiO0EadyA7QRV3cyA7QQd3c0EAKALkiQEiPGpBACgC4IkBIj1BACgC3IkBIj5zIDtxID1zaiAHakGY36iUBGoiB0EAKALUiQEiP2oiACAMaiA7IA1qID4gD2ogPSAGaiAAID4gO3NxID5zaiAAQRp3IABBFXdzIABBB3dzakGRid2JB2oiQEEAKALQiQEiQWoiDCAAIDtzcSA7c2ogDEEadyAMQRV3cyAMQQd3c2pBz/eDrntqIkJBACgCzIkBIkNqIg0gDCAAc3EgAHNqIA1BGncgDUEVd3MgDUEHd3NqQaW3181+aiJEQQAoAsiJASIAaiIPIA0gDHNxIAxzaiAPQRp3IA9BFXdzIA9BB3dzakHbhNvKA2oiRSBBIEMgAHNxIEMgAHFzIABBHncgAEETd3MgAEEKd3NqIAdqIgZqIgdqIAUgD2ogCiANaiALIAxqIAcgDyANc3EgDXNqIAdBGncgB0EVd3MgB0EHd3NqQfGjxM8FaiIKIAYgAHMgQ3EgBiAAcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pBpIX+kXlqIgsgDCAGcyAAcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIPIAQgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakHVvfHYemoiQCANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIERqIgZqIgcgDyAEc3EgBHNqIAdBGncgB0EVd3MgB0EHd3NqQZjVnsB9aiJCIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogRWoiDGoiBWogFiAHaiAQIA9qIAggBGogBSAHIA9zcSAPc2ogBUEadyAFQRV3cyAFQQd3c2pBgbaNlAFqIgggDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiAKaiINaiIPIAUgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakG+i8ahAmoiDiANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAtqIgZqIgcgDyAFc3EgBXNqIAdBGncgB0EVd3MgB0EHd3NqQcP7sagFaiIQIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pB9Lr5lQdqIhYgDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIFaiABIARqIAIgB2ogFSAPaiAFIAQgB3NxIAdzaiAFQRp3IAVBFXdzIAVBB3dzakH+4/qGeGoiByANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAhqIgFqIgYgBSAEc3EgBHNqIAZBGncgBkEVd3MgBkEHd3NqQaeN8N55aiIEIAEgDXMgDHEgASANcXMgAUEedyABQRN3cyABQQp3c2ogDmoiAmoiDCAGIAVzcSAFc2ogDEEadyAMQRV3cyAMQQd3c2pB9OLvjHxqIgUgAiABcyANcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAQaiIDaiINIAwgBnNxIAZzaiANQRp3IA1BFXdzIA1BB3dzakHB0+2kfmoiCCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBZqIgFqIg8gF2ogESANaiAUIAxqIAkgBmogDyANIAxzcSAMc2ogD0EadyAPQRV3cyAPQQd3c2pBho/5/X5qIgYgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAHaiICaiIJIA8gDXNxIA1zaiAJQRp3IAlBFXdzIAlBB3dzakHGu4b+AGoiDCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIARqIgNqIhEgCSAPc3EgD3NqIBFBGncgEUEVd3MgEUEHd3NqQczDsqACaiINIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogBWoiAWoiFCARIAlzcSAJc2ogFEEadyAUQRV3cyAUQQd3c2pB79ik7wJqIg8gASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAIaiICaiIXaiATIBRqIBggEWogEiAJaiAXIBQgEXNxIBFzaiAXQRp3IBdBFXdzIBdBB3dzakGqidLTBGoiGCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIAZqIgNqIgkgFyAUc3EgFHNqIAlBGncgCUEVd3MgCUEHd3NqQdzTwuUFaiIUIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogDGoiAWoiESAJIBdzcSAXc2ogEUEadyARQRV3cyARQQd3c2pB2pHmtwdqIhcgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiANaiICaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakHSovnBeWoiGSACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIA9qIgNqIhNqIB4gEmogGiARaiAdIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQe2Mx8F6aiIaIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGGoiAWoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pByM+MgHtqIhggASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAUaiICaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakHH/+X6e2oiFCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBdqIgNqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQfOXgLd8aiIXIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGWoiAWoiE2ogICASaiAcIBFqIB8gCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJz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";
    hash$a = "8c18dd94";
    wasmJson$a = {
      name: name$a,
      data: data$a,
      hash: hash$a
    };
    mutex$a = new Mutex();
    wasmCache$a = null;
    mutex$9 = new Mutex();
    wasmCache$9 = null;
    name$9 = "sha512";
    data$9 = "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";
    hash$9 = "f2e40eb1";
    wasmJson$9 = {
      name: name$9,
      data: data$9,
      hash: hash$9
    };
    mutex$8 = new Mutex();
    wasmCache$8 = null;
    mutex$7 = new Mutex();
    wasmCache$7 = null;
    name$8 = "xxhash32";
    data$8 = "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";
    hash$8 = "4bb12485";
    wasmJson$8 = {
      name: name$8,
      data: data$8,
      hash: hash$8
    };
    mutex$6 = new Mutex();
    wasmCache$6 = null;
    name$7 = "xxhash64";
    data$7 = "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";
    hash$7 = "177fbfa3";
    wasmJson$7 = {
      name: name$7,
      data: data$7,
      hash: hash$7
    };
    mutex$5 = new Mutex();
    wasmCache$5 = null;
    seedBuffer$2 = new Uint8Array(8);
    name$6 = "xxhash3";
    data$6 = "AGFzbQEAAAABNAhgAAF/YAR/f39/AGAHf39/f39/fwBgBH9+fn4BfmAEf39/fgF+YAN/f34BfmAAAGABfwADDg0AAQIDBAUFBQYHBgAGBQQBAQICBg4CfwFBwI4FC38AQcAJCwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQr6QQ0FAEGACgvkAwMPfgF/AX4CQCADRQ0AIAApAzAhBCAAKQM4IQUgACkDICEGIAApAyghByAAKQMQIQggACkDGCEJIAApAwAhCiAAKQMIIQsDQCAFIAFBMGopAwAiDHwgAkE4aikDACABQThqKQMAIg2FIgVCIIggBUL/////D4N+fCEFIAcgAUEgaikDACIOfCACQShqKQMAIAFBKGopAwAiD4UiB0IgiCAHQv////8Pg358IQcgCSABQRBqKQMAIhB8IAJBGGopAwAgAUEYaikDACIRhSIJQiCIIAlC/////w+DfnwhCSALIAEpAwAiEnwgAkEIaiITKQMAIAFBCGopAwAiFIUiC0IgiCALQv////8Pg358IQsgAkEwaikDACAMhSIMQiCIIAxC/////w+DfiAEfCANfCEEIAJBIGopAwAgDoUiDEIgiCAMQv////8Pg34gBnwgD3whBiACQRBqKQMAIBCFIgxCIIggDEL/////D4N+IAh8IBF8IQggAikDACAShSIMQiCIIAxC/////w+DfiAKfCAUfCEKIAFBwABqIQEgEyECIANBf2oiAw0ACyAAIAk3AxggACAKNwMAIAAgCzcDCCAAIAc3AyggACAINwMQIAAgBTcDOCAAIAY3AyAgACAENwMwCwveAgIBfwF+AkAgBCACIAEoAgAiB2siAkkNACAAIAMgBSAHQQN0aiACEAEgACAFIAZqIgcpAwAgACkDACIIQi+IhSAIhUKx893xCX43AwAgACAHKQMIIAApAwgiCEIviIUgCIVCsfPd8Ql+NwMIIAAgBykDECAAKQMQIghCL4iFIAiFQrHz3fEJfjcDECAAIAcpAxggACkDGCIIQi+IhSAIhUKx893xCX43AxggACAHKQMgIAApAyAiCEIviIUgCIVCsfPd8Ql+NwMgIAAgBykDKCAAKQMoIghCL4iFIAiFQrHz3fEJfjcDKCAAIAcpAzAgACkDMCIIQi+IhSAIhUKx893xCX43AzAgACAHKQM4IAApAzgiCEIviIUgCIVCsfPd8Ql+NwM4IAAgAyACQQZ0aiAFIAQgAmsiBxABIAEgBzYCAA8LIAAgAyAFIAdBA3RqIAQQASABIAcgBGo2AgALhQEBAX8gAiABhSADpyIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycq1CIIYgA4V9QQA1AoCMAUIghiAAQfyLAWo1AgCEhSIDQjGJIANCGImFIAOFQqW+4/TRjIfZn39+IgNCI4ggAK18IAOFQqW+4/TRjIfZn39+IgNCHIggA4ULZwAgAiABc60gA3wiA0IhiEEALQCAjAFBEHQgAEEIdHIgAEEBdkGAjAFqLQAAQRh0ciAAQf+LAWotAAByrYUgA4VCz9bTvtLHq9lCfiIDQh2IIAOFQvnz3fGZ9pmrFn4iA0IgiCADhQuJAwEEfgJAIABBCUkNAEEAKQOAjAEgASkDICABKQMYhSACfIUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAArXwgAEH4iwFqKQMAIAEpAzAgASkDKIUgAn2FIgJ8IAJC/////w+DIgQgA0IgiCIFfiIGQv////8PgyACQiCIIgIgA0L/////D4MiA358IAQgA34iA0IgiHwiBEIghiADQv////8Pg4QgBkIgiCACIAV+fCAEQiCIfIV8IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFDwsCQCAAQQRJDQAgACABQQhqKQMAIAFBEGopAwAgAhADDwsCQCAARQ0AIAAgASgCACABQQRqKAIAIAIQBA8LIAEpAzggASkDQIUgAoUiA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC94IAQZ+IACtQoeVr6+Ytt6bnn9+IQMCQCAAQSFJDQACQCAAQcEASQ0AAkAgAEHhAEkNACABKQNoIAJ9QQApA7iMAYUiBEL/////D4MiBSABKQNgIAJ8QQApA7CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDeCACfSAAQciLAWopAwCFIgNC/////w+DIgQgASkDcCACfCAAQcCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQNIIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQNAIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDWCACfSAAQdiLAWopAwCFIgNC/////w+DIgQgASkDUCACfCAAQdCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMoIAJ9QQApA5iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA5CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDOCACfSAAQeiLAWopAwCFIgNC/////w+DIgQgASkDMCACfCAAQeCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMIIAJ9QQApA4iMAYUiBEL/////D4MiBSABKQMAIAJ8QQApA4CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDGCACfSAAQfiLAWopAwCFIgNC/////w+DIgQgASkDECACfCAAQfCLAWopAwCFIgJCIIgiBX4iBkL/////D4MgA0IgiCIDIAJC/////w+DIgJ+fCAEIAJ+IgJCIIh8IgRCIIYgAkL/////D4OEIAZCIIggAyAFfnwgBEIgiHyFfCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQv8CgQBfwV+An8BfkEAIQMgASkDeCACfUEAKQP4jAGFIgRC/////w+DIgUgASkDcCACfEEAKQPwjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpA2ggAn1BACkD6IwBhSIEQv////8PgyIFIAEpA2AgAnxBACkD4IwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQNYIAJ9QQApA9iMAYUiBEL/////D4MiBSABKQNQIAJ8QQApA9CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDSCACfUEAKQPIjAGFIgRC/////w+DIgUgASkDQCACfEEAKQPAjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAzggAn1BACkDuIwBhSIEQv////8PgyIFIAEpAzAgAnxBACkDsIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQMoIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDGCACfUEAKQOYjAGFIgRC/////w+DIgUgASkDECACfEEAKQOQjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAwggAn1BACkDiIwBhSIEQv////8PgyIFIAEpAwAgAnxBACkDgIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSAArUKHla+vmLbem55/fnx8fHx8fHx8IgRCJYggBIVC+fPd8ZnymasWfiIEQiCIIASFIQQCQCAAQZABSA0AIABBBHZBeGohCQNAIAEgA2oiCkELaikDACACfSADQYiNAWopAwCFIgVC/////w+DIgYgCkEDaikDACACfCADQYCNAWopAwCFIgdCIIgiCH4iC0L/////D4MgBUIgiCIFIAdC/////w+DIgd+fCAGIAd+IgZCIIh8IgdCIIYgBkL/////D4OEIAtCIIggBSAIfnwgB0IgiHyFIAR8IQQgA0EQaiEDIAlBf2oiCQ0ACwsgASkDfyACfSAAQfiLAWopAwCFIgVC/////w+DIgYgASkDdyACfCAAQfCLAWopAwCFIgJCIIgiB34iCEL/////D4MgBUIgiCIFIAJC/////w+DIgJ+fCAGIAJ+IgJCIIh8IgZCIIYgAkL/////D4OEIAhCIIggBSAHfnwgBkIgiHyFIAR8IgJCJYggAoVC+fPd8ZnymasWfiICQiCIIAKFC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAA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QQApA4CKATcDACACQQApA4iKATcDCCACQQApA5CKATcDECACQQApA5iKATcDGCACQQApA6CKATcDICACQQApA6iKATcDKCACQQApA7CKASIFNwMwIAJBACkDuIoBIgY3AzgCQAJAQQAoAoCOASIHQcAASQ0AIAJBACgCiI4BNgJAIAIgAkHAAGpBACgCmI4BQYCMASAHQX9qQQZ2IANBACgCnI4BIgAQAiADIABqIgBBeWopAwAhCCAAKQMJIQkgACkDGSEKIAApAykhCyAHQcCLAWopAwAhBSAAKQMBIQwgB0HIiwFqKQMAIQYgB0HQiwFqKQMAIQ0gACkDESEOIAdB2IsBaikDACEPIAdB4IsBaikDACEQIAApAyEhESAHQeiLAWopAwAhEiACKQMAIRMgAikDECEUIAIpAyAhFSACKQMwIRYgAikDCCEXIAIpAxghGCACKQMoIRkgAiACKQM4IAdB8IsBaikDACIafCAAKQMxIAdB+IsBaikDACIbhSIcQiCIIBxC/////w+Dfnw3AzggGSAQfCARIBKFIhFCIIggEUL/////D4N+fCERIBggDXwgDiAPhSIOQiCIIA5C/////w+DfnwhDiAXIAV8IAwgBoUiDEIgiCAMQv////8Pg358IQwgGyAWIAsgGoUiC0IgiCALQv////8Pg358fCELIBIgFSAKIBCFIhBCIIggEEL/////D4N+fHwhECAPIBQgCSANhSINQiCIIA1C/////w+Dfnx8IRIgBiATIAggBYUiBUIgiCAFQv////8Pg358fCEIDAELIAdBwI0BaiEdQcAAIAdrIR4gAkHAAGohAAJAAkACQCAHQThNDQAgHiEfDAELAkACQEE4IAdrQQN2QQFqQQdxIh8NACACQcAAaiEAIB4hHwwBCyACQcAAaiEAIB9BA3QiICEfA0AgACAdKQMANwMAIABBCGohACAdQQhqIR0gH0F4aiIfDQALQcAAIAcgIGprIR8LAkAgBw0AA0AgACAdKQMANwMAIABBCGogHUEIaikDADcDACAAQRBqIB1BEGopAwA3AwAgAEEYaiAdQRhqKQMANwMAIABBIGogHUEgaikDADcDACAAQShqIB1BKGopAwA3AwAgAEEwaiAdQTBqKQMANwMAIABBOGogHUE4aikDADcDACAAQcAAaiEAIB1BwABqIR0gH0FAaiIfQQdLDQALCyAfRQ0BCyAfQX9qISECQCAfQQdxIiBFDQAgH0F4cSEfA0AgACAdLQAAOgAAIABBAWohACAdQQFqIR0gIEF/aiIgDQALCyAhQQdJDQADQCAAIB0pAAA3AAAgAEEIaiEAIB1BCGohHSAfQXhqIh8NAAsLIAJBwABqIB5qIR1BgIwBIQACQAJAAkAgB0EISQ0AAkAgB0E4akEDdkEBakEHcSIfDQAMAgsgH0EDdCEgQYCMASEAA0AgHSAAKQMANwMAIB1BCGohHSAAQQhqIQAgH0F/aiIfDQALIAcgIGshBwsgB0UNAQJAAkAgB0EHcSIgDQAgByEfDAELIAdBeHEhHwNAIB0gAC0AADoAACAdQQFqIR0gAEEBaiEAICBBf2oiIA0ACwsgB0EISQ0BCwNAIB0gACkAADcAACAdQQhqIR0gAEEIaiEAIB9BeGoiHw0ACwsgA0EAKAKcjgFqIgBBeWopAwAhCiAAKQMJIRMgACkDGSEUIAApAykhCyAAKQMBIQwgACkDESEOIAApAyEhESACKQMAIRUgAikDECEWIAIpAyAhFyACKQMIIRggAikDQCENIAIpA0ghDyACKQMYIRkgAikDUCESIAIpA1ghCCACKQMoIRogAikDYCEQIAIpA2ghCSACIAYgAikDcCIbfCAAKQMxIAIpA3giBoUiHEIgiCAcQv////8Pg358NwM4IBogEHwgESAJhSIRQiCIIBFC/////w+DfnwhESAZIBJ8IA4gCIUiDkIgiCAOQv////8Pg358IQ4gGCANfCAMIA+FIgxCIIggDEL/////D4N+fCEMIAYgCyAbhSILQiCIIAtC/////w+DfiAFfHwhCyAJIBcgFCAQhSIFQiCIIAVC/////w+Dfnx8IRAgCCAWIBMgEoUiBUIgiCAFQv////8Pg358fCESIA8gFSAKIA2FIgVCIIggBUL/////D4N+fHwhCAsgAykDQyACKQM4hSIFQv////8PgyIGIAMpAzsgC4UiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDMyARhSIFQv////8PgyIGIAMpAysgEIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDIyAOhSIFQv////8PgyIGIAMpAxsgEoUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDEyAMhSIFQv////8PgyIGIAMpAwsgCIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgBEKHla+vmLbem55/fnx8fHwiBEIliCAEhUL5893xmfKZqxZ+IgRCIIggBIUhBAwBCyAEpyEAAkBBACkDoI4BIgRQDQACQCAAQRBLDQAgAEGACCAEEAUhBAwCCwJAIABBgAFLDQAgAEGACCAEEAYhBAwCCyAAQYAIIAQQByEEDAELAkAgAEEQSw0AIAAgA0IAEAUhBAwBCwJAIABBgAFLDQAgACADQgAQBiEEDAELIAAgA0IAEAchBAtBACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwOACiABJAALBgBBgIoBCwIACwvMAQEAQYAIC8QBuP5sOSOkS758AYEs9yGtHN7UbemDkJfbckCkpLezZx/LeeZOzMDleIJa0H3M/3IhuAhGdPdDJI7gNZDmgTomTDwoUruRwwDLiNBlixtTLqNxZEiXog35TjgZ70ap3qzYqPp2P+OcND/53LvHxwtPHYpR4EvNtFkxyJ9+ydl4c2TqxayDNNPrw8WBoP/6E2PrFw3dUbfw2knTFlUmKdRonisWvlh9R6H8j/i40XrQMc5FyzqPlRYEKK/X+8q7S0B+QAIAAA==";
    hash$6 = "5a2fbdbb";
    wasmJson$6 = {
      name: name$6,
      data: data$6,
      hash: hash$6
    };
    mutex$4 = new Mutex();
    wasmCache$4 = null;
    seedBuffer$1 = new Uint8Array(8);
    name$5 = "xxhash128";
    data$5 = "AGFzbQEAAAABKwdgAAF/YAR/f39/AGAHf39/f39/fwBgA39/fgF+YAR/f39+AGAAAGABfwADDQwAAQIDBAQEBQYFAAUFBAEBAgIGDgJ/AUHAjgULfwBBwAkLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAcLSGFzaF9VcGRhdGUACApIYXNoX0ZpbmFsAAkNSGFzaF9HZXRTdGF0ZQAKDkhhc2hfQ2FsY3VsYXRlAAsKU1RBVEVfU0laRQMBCqBNDAUAQYAKC+QDAw9+AX8BfgJAIANFDQAgACkDMCEEIAApAzghBSAAKQMgIQYgACkDKCEHIAApAxAhCCAAKQMYIQkgACkDACEKIAApAwghCwNAIAUgAUEwaikDACIMfCACQThqKQMAIAFBOGopAwAiDYUiBUIgiCAFQv////8Pg358IQUgByABQSBqKQMAIg58IAJBKGopAwAgAUEoaikDACIPhSIHQiCIIAdC/////w+DfnwhByAJIAFBEGopAwAiEHwgAkEYaikDACABQRhqKQMAIhGFIglCIIggCUL/////D4N+fCEJIAsgASkDACISfCACQQhqIhMpAwAgAUEIaikDACIUhSILQiCIIAtC/////w+DfnwhCyACQTBqKQMAIAyFIgxCIIggDEL/////D4N+IAR8IA18IQQgAkEgaikDACAOhSIMQiCIIAxC/////w+DfiAGfCAPfCEGIAJBEGopAwAgEIUiDEIgiCAMQv////8Pg34gCHwgEXwhCCACKQMAIBKFIgxCIIggDEL/////D4N+IAp8IBR8IQogAUHAAGohASATIQIgA0F/aiIDDQALIAAgCTcDGCAAIAo3AwAgACALNwMIIAAgBzcDKCAAIAg3AxAgACAFNwM4IAAgBjcDICAAIAQ3AzALC94CAgF/AX4CQCAEIAIgASgCACIHayICSQ0AIAAgAyAFIAdBA3RqIAIQASAAIAUgBmoiBykDACAAKQMAIghCL4iFIAiFQrHz3fEJfjcDACAAIAcpAwggACkDCCIIQi+IhSAIhUKx893xCX43AwggACAHKQMQIAApAxAiCEIviIUgCIVCsfPd8Ql+NwMQIAAgBykDGCAAKQMYIghCL4iFIAiFQrHz3fEJfjcDGCAAIAcpAyAgACkDICIIQi+IhSAIhUKx893xCX43AyAgACAHKQMoIAApAygiCEIviIUgCIVCsfPd8Ql+NwMoIAAgBykDMCAAKQMwIghCL4iFIAiFQrHz3fEJfjcDMCAAIAcpAzggACkDOCIIQi+IhSAIhUKx893xCX43AzggACADIAJBBnRqIAUgBCACayIHEAEgASAHNgIADwsgACADIAUgB0EDdGogBBABIAEgByAEajYCAAvtAwEFfiABKQM4IAApAziFIgNC/////w+DIgQgASkDMCAAKQMwhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMoIAApAyiFIgNC/////w+DIgQgASkDICAAKQMghSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMYIAApAxiFIgNC/////w+DIgQgASkDECAAKQMQhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMIIAApAwiFIgNC/////w+DIgQgASkDACAAKQMAhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSACfHx8fCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQu6CAIFfgN/AkAgAUEJSQ0AIAAgAUH4iwFqKQMAIgQgAikDOCACKQMwhSADfIUiBUL/////D4NC95Svrwh+IAVCgICAgHCDfEEAKQOAjAEgAikDKCACKQMghSADfYUgBIUiA0IgiCIEQrHz3fEJfnwgBEKHla+vCH4iBEIgiHwgBEL/////D4MgA0L/////D4MiA0Kx893xCX58IANCh5Wvrwh+IgRCIIh8IgVCIIh8IgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgBEL/////D4MgAUF/aq1CNoaEIAVCIIZ8hSIEQiCIIgVCz9bTvgJ+IgZC/////w+DIARC/////w+DIgRCvdzKlQx+fCAEQs/W074CfiIEQiCIfCIHQiCGIghCJYggCCAEQv////8Pg4SFQvnz3fGZ8pmrFn4iBEIgiCAEhTcDACAAIAVCvdzKlQx+IANCz9bTvtLHq9lCfnwgBkIgiHwgB0IgiHwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4U3AwgPCwJAIAFBBEkNACAAIAIpAxggAikDEIUgA6ciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnKtQiCGIAOFfCABQfyLAWo1AgBCIIZBADUCgIwBhIUiA0IgiCIEIAFBAnRBh5Wvr3hqrSIFfiIGQiCIIARCsfPd8Ql+fCAGQv////8PgyADQv////8PgyIDQrHz3fEJfnwgAyAFfiIDQiCIfCIEQiCIfCAEQiCGIANC/////w+DhCIEQgGGfCIDQiWIIAOFQvnz3fGZ8pmrFn4iBUIgiCAFhTcDCCAAIANCA4ggBIUiA0IjiCADhUKlvuP00YyH2Z9/fiIDQhyIIAOFNwMADwsCQCABRQ0AIAAgAigCBCACKAIAc60gA3wiBEIhiEEALQCAjAFBEHQgAUEIdHIiCSABQQF2QYCMAWotAABBGHRyIgogAUH/iwFqLQAAIgFyIguthSAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMAIAAgAigCDCACKAIIc60gA30iA0IhiCABQRh0IAtBgP4DcUEIdHIgCUEIdkGA/gNxIApBGHZyckENd62FIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwgPCyAAIAIpA1AgAikDWIUgA4UiBEIhiCAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMIIAAgAikDQCACKQNIhSADhSIDQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwALwwoBCn4gAa0iBEKHla+vmLbem55/fiEFAkACQCABQSFPDQBCACEGDAELQgAhBwJAIAFBwQBJDQBCACEHAkAgAUHhAEkNACACQfgAaikDACADfSABQciLAWopAwAiCIUiB0L/////D4MiCSACKQNwIAN8IAFBwIsBaikDACIKhSILQiCIIgx+Ig1CIIggB0IgiCIHIAx+fCANQv////8PgyAHIAtC/////w+DIgt+fCAJIAt+IgdCIIh8IglCIIh8QQApA7iMASILQQApA7CMASIMfIUgCUIghiAHQv////8Pg4SFIQcgAkHoAGopAwAgA30gC4UiCUL/////D4MiCyACKQNgIAN8IAyFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCALIAx+IgtCIIh8IgxCIIYgC0L/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAV8IAggCnyFIQULIAJB2ABqKQMAIAN9IAFB2IsBaikDACIIhSIJQv////8PgyIKIAIpA1AgA3wgAUHQiwFqKQMAIguFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCAKIAx+IgpCIIh8IgxCIIYgCkL/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAd8QQApA6iMASIJQQApA6CMASIKfIUhByACQcgAaikDACADfSAJhSIJQv////8PgyIMIAIpA0AgA3wgCoUiCkIgiCINfiIGQv////8PgyAJQiCIIgkgCkL/////D4MiCn58IAwgCn4iCkIgiHwiDEIghiAKQv////8Pg4QgBkIgiCAJIA1+fCAMQiCIfIUgBXwgCCALfIUhBQsgAkE4aikDACADfSABQeiLAWopAwAiCIUiCUL/////D4MiCiACKQMwIAN8IAFB4IsBaikDACILhSIMQiCIIg1+IgZC/////w+DIAlCIIgiCSAMQv////8PgyIMfnwgCiAMfiIKQiCIfCIMQiCGIApC/////w+DhCAGQiCIIAkgDX58IAxCIIh8hSAHfEEAKQOYjAEiB0EAKQOQjAEiCXyFIQYgAkEoaikDACADfSAHhSIHQv////8PgyIKIAIpAyAgA3wgCYUiCUIgiCIMfiINQv////8PgyAHQiCIIgcgCUL/////D4MiCX58IAogCX4iCUIgiHwiCkIghiAJQv////8Pg4QgDUIgiCAHIAx+fCAKQiCIfIUgBXwgCCALfIUhBQsgACACQRhqKQMAIAN9IAFB+IsBaikDACIHhSIIQv////8PgyIJIAIpAxAgA3wgAUHwiwFqKQMAIgqFIgtCIIgiDH4iDUL/////D4MgCEIgiCIIIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAZ8QQApA4iMASIIQQApA4CMASIJfIUiCyACQQhqKQMAIAN9IAiFIghC/////w+DIgwgAikDACADfCAJhSIJQiCIIg1+IgZC/////w+DIAhCIIgiCCAJQv////8PgyIJfnwgDCAJfiIJQiCIfCIMQiCGIAlC/////w+DhCAGQiCIIAggDX58IAxCIIh8hSAFfCAHIAp8hSIFfCIHQiWIIAeFQvnz3fGZ8pmrFn4iB0IgiCAHhTcDACAAQgAgBUKHla+vmLbem55/fiAEIAN9Qs/W077Sx6vZQn58IAtC49zKlfzO8vWFf358IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFfTcDCAuhDwMBfxR+An9BACEEIAJB+ABqKQMAIAN9QQApA/iMASIFhSIGQv////8PgyIHIAIpA3AgA3xBACkD8IwBIgiFIglCIIgiCn4iC0L/////D4MgBkIgiCIGIAlC/////w+DIgl+fCAHIAl+IgdCIIh8IglCIIYgB0L/////D4OEIAtCIIggBiAKfnwgCUIgiHyFIAJB2ABqKQMAIAN9QQApA9iMASIHhSIGQv////8PgyIJIAIpA1AgA3xBACkD0IwBIgqFIgtCIIgiDH4iDUL/////D4MgBkIgiCIGIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAJBOGopAwAgA31BACkDuIwBIgmFIgZC/////w+DIgsgAikDMCADfEEAKQOwjAEiDIUiDUIgiCIOfiIPQv////8PgyAGQiCIIgYgDUL/////D4MiDX58IAsgDX4iC0IgiHwiDUIghiALQv////8Pg4QgD0IgiCAGIA5+fCANQiCIfIUgAkEYaikDACADfUEAKQOYjAEiC4UiBkL/////D4MiDSACKQMQIAN8QQApA5CMASIOhSIPQiCIIhB+IhFC/////w+DIAZCIIgiBiAPQv////8PgyIPfnwgDSAPfiINQiCIfCIPQiCGIA1C/////w+DhCARQiCIIAYgEH58IA9CIIh8hUEAKQOIjAEiDUEAKQOAjAEiD3yFfEEAKQOojAEiEEEAKQOgjAEiEXyFfEEAKQPIjAEiEkEAKQPAjAEiE3yFfEEAKQPojAEiFEEAKQPgjAEiFXyFIgZCJYggBoVC+fPd8ZnymasWfiIGQiCIIAaFIQYgAkHoAGopAwAgA30gFIUiFEL/////D4MiFiACKQNgIAN8IBWFIhVCIIgiF34iGEL/////D4MgFEIgiCIUIBVC/////w+DIhV+fCAWIBV+IhVCIIh8IhZCIIYgFUL/////D4OEIBhCIIggFCAXfnwgFkIgiHyFIAJByABqKQMAIAN9IBKFIhJC/////w+DIhQgAikDQCADfCAThSITQiCIIhV+IhZC/////w+DIBJCIIgiEiATQv////8PgyITfnwgFCATfiITQiCIfCIUQiCGIBNC/////w+DhCAWQiCIIBIgFX58IBRCIIh8hSACQShqKQMAIAN9IBCFIhBC/////w+DIhIgAikDICADfCARhSIRQiCIIhN+IhRC/////w+DIBBCIIgiECARQv////8PgyIRfnwgEiARfiIRQiCIfCISQiCGIBFC/////w+DhCAUQiCIIBAgE358IBJCIIh8hSACQQhqKQMAIAN9IA2FIg1C/////w+DIhAgAikDACADfCAPhSIPQiCIIhF+IhJC/////w+DIA1CIIgiDSAPQv////8PgyIPfnwgECAPfiIPQiCIfCIQQiCGIA9C/////w+DhCASQiCIIA0gEX58IBBCIIh8hSABrSIPQoeVr6+Ytt6bnn9+fCALIA58hXwgCSAMfIV8IAcgCnyFfCAFIAh8hSIFQiWIIAWFQvnz3fGZ8pmrFn4iBUIgiCAFhSEFAkAgAUGgAUgNACABQQV2QXxqIRkDQCACIARqIhpBG2opAwAgA30gBEGYjQFqKQMAIgeFIghC/////w+DIgkgGkETaikDACADfCAEQZCNAWopAwAiCoUiC0IgiCIMfiINQv////8PgyAIQiCIIgggC0L/////D4MiC358IAkgC34iCUIgiHwiC0IghiAJQv////8Pg4QgDUIgiCAIIAx+fCALQiCIfIUgBnwgBEGIjQFqKQMAIgggBEGAjQFqKQMAIgl8hSEGIBpBC2opAwAgA30gCIUiCEL/////D4MiCyAaQQNqKQMAIAN8IAmFIglCIIgiDH4iDUL/////D4MgCEIgiCIIIAlC/////w+DIgl+fCALIAl+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAV8IAcgCnyFIQUgBEEgaiEEIBlBf2oiGQ0ACwsgACACQf8AaikDACADfCABQeiLAWopAwAiB4UiCEL/////D4MiCSACKQN3IAN9IAFB4IsBaikDACIKhSILQiCIIgx+Ig1C/////w+DIAhCIIgiCCALQv////8PgyILfnwgCSALfiIJQiCIfCILQiCGIAlC/////w+DhCANQiCIIAggDH58IAtCIIh8hSAGfCABQfiLAWopAwAiBiABQfCLAWopAwAiCHyFIgkgAkHvAGopAwAgA3wgBoUiBkL/////D4MiCyACKQNnIAN9IAiFIghCIIgiDH4iDUL/////D4MgBkIgiCIGIAhC/////w+DIgh+fCALIAh+IghCIIh8IgtCIIYgCEL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAV8IAcgCnyFIgZ8IgVCJYggBYVC+fPd8ZnymasWfiIFQiCIIAWFNwMAIABCACAGQoeVr6+Ytt6bnn9+IA8gA31Cz9bTvtLHq9lCfnwgCULj3MqV/M7y9YV/fnwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4V9NwMIC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iL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AkHAAGogDGohC0GAjAEhAAJAAkACQCAHQQhJDQACQCAHQThqQQN2QQFqQQdxIg0NAAwCCyANQQN0IQ5BgIwBIQADQCALIAApAwA3AwAgC0EIaiELIABBCGohACANQX9qIg0NAAsgByAOayEHCyAHRQ0BAkACQCAHQQdxIg4NACAHIQ0MAQsgB0F4cSENA0AgCyAALQAAOgAAIAtBAWohCyAAQQFqIQAgDkF/aiIODQALCyAHQQhJDQELA0AgCyAAKQAANwAAIAtBCGohCyAAQQhqIQAgDUF4aiINDQALCyACIAIpAwggAikDQCIIfCADQQAoApyOAWoiACkDASACKQNIIgmFIgpCIIggCkL/////D4N+fDcDCCACIAIpAxggAikDUCIKfCAAKQMRIAIpA1giEIUiEUIgiCARQv////8Pg358NwMYIAIgECAKIAApAwmFIgpCIIggCkL/////D4N+IAIpAxB8fDcDECACIAkgCCAAQXlqKQMAhSIIQiCIIAhC/////w+DfiACKQMAfHw3AwAgACkDGSEIIAIpAyAhCSACIAIpAyggAikDYCIKfCAAKQMhIAIpA2giEIUiEUIgiCARQv////8Pg358NwMoIAIgECAJIAggCoUiCEIgiCAIQv////8Pg358fDcDICACIAYgAikDcCIIfCAAKQMxIAIpA3giBoUiCUIgiCAJQv////8Pg358NwM4IAIgBiAIIAApAymFIghCIIggCEL/////D4N+IAV8fDcDMAsgAiACIANBC2ogBEKHla+vmLbem55/fhADNwNAIAIgAiADQQAoApyOAWpBdWogBELP1tO+0ser2UJ+Qn+FEAM3A0gMAQsgBKchAAJAQQApA6COASIEUA0AAkAgAEEQSw0AIAJBwABqIABBgAggBBAEDAILAkAgAEGAAUsNACACQcAAaiAAQYAIIAQQBQwCCyACQcAAaiAAQYAIIAQQBgwBCwJAIABBEEsNACACQcAAaiAAIANCABAEDAELAkAgAEGAAUsNACACQcAAaiAAIANCABAFDAELIAJBwABqIAAgA0IAEAYLQQAgAikDcDcDuApBACACKQNgNwOoCkEAIAIpA1A3A5gKQQAgAkH4AGopAwA3A8AKQQAgAkHoAGopAwA3A7AKQQAgAkHYAGopAwA3A6AKQQAgAikDSCIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIgQ3A4AKQQAgBDcDkApBACACKQNAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQ3A4gKIAEkAAsGAEGAigELAgALC8wBAQBBgAgLxAG4/mw5I6RLvnwBgSz3Ia0c3tRt6YOQl9tyQKSkt7NnH8t55k7MwOV4glrQfcz/ciG4CEZ090MkjuA1kOaBOiZMPChSu5HDAMuI0GWLG1Muo3FkSJeiDflOOBnvRqnerNio+nY/45w0P/ncu8fHC08dilHgS820WTHIn37J2XhzZOrFrIM00+vDxYGg//oTY+sXDd1Rt/DaSdMWVSYp1GieKxa+WH1HofyP+LjRetAxzkXLOo+VFgQor9f7yrtLQH5AAgAA";
    hash$5 = "b9ab74e2";
    wasmJson$5 = {
      name: name$5,
      data: data$5,
      hash: hash$5
    };
    mutex$3 = new Mutex();
    wasmCache$3 = null;
    seedBuffer = new Uint8Array(8);
    name$4 = "ripemd160";
    data$4 = "AGFzbQEAAAABEQRgAAF/YAAAYAF/AGACf38AAwkIAAECAwIBAAIFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB4MBCQZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAABEHJpcGVtZDE2MF91cGRhdGUAAwtIYXNoX1VwZGF0ZQAECkhhc2hfRmluYWwABQ1IYXNoX0dldFN0YXRlAAYOSGFzaF9DYWxjdWxhdGUABwpTVEFURV9TSVpFAwEKzzIIBQBBgAkLOgBBAEHww8uefDYCmIkBQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQuPLAEhf0EAIAAoAiQiASAAKAIAIgIgACgCECIDIAIgACgCLCIEIAAoAgwiBSAAKAIEIgYgACgCPCIHIAIgACgCMCIIIAcgACgCCCIJQQAoAoiJASIKQQAoApCJASILQQAoApSJASIMQX9zckEAKAKMiQEiDXNqIAAoAhQiDmpB5peKhQVqQQh3QQAoApiJASIPaiIQQQp3IhFqIAEgDUEKdyISaiACIAtBCnciE2ogDCAAKAIcIhRqIA8gACgCOCIVaiAQIA0gE0F/c3JzakHml4qFBWpBCXcgDGoiFiAQIBJBf3Nyc2pB5peKhQVqQQl3IBNqIhAgFiARQX9zcnNqQeaXioUFakELdyASaiIXIBAgFkEKdyIWQX9zcnNqQeaXioUFakENdyARaiIYIBcgEEEKdyIZQX9zcnNqQeaXioUFakEPdyAWaiIaQQp3IhtqIAAoAhgiECAYQQp3IhxqIAAoAjQiESAXQQp3IhdqIAMgGWogBCAWaiAaIBggF0F/c3JzakHml4qFBWpBD3cgGWoiFiAaIBxBf3Nyc2pB5peKhQVqQQV3IBdqIhcgFiAbQX9zcnNqQeaXioUFakEHdyAcaiIYIBcgFkEKdyIZQX9zcnNqQeaXioUFakEHdyAbaiIaIBggF0EKdyIXQX9zcnNqQeaXioUFakEIdyAZaiIbQQp3IhxqIAUgGkEKdyIdaiAAKAIoIhYgGEEKdyIYaiAGIBdqIAAoAiAiACAZaiAbIBogGEF/c3JzakHml4qFBWpBC3cgF2oiFyAbIB1Bf3Nyc2pB5peKhQVqQQ53IBhqIhggFyAcQX9zcnNqQeaXioUFakEOdyAdaiIZIBggF0EKdyIaQX9zcnNqQeaXioUFakEMdyAcaiIbIBkgGEEKdyIcQX9zcnNqQeaXioUFakEGdyAaaiIdQQp3IhdqIAUgGUEKdyIYaiAQIBpqIBsgGEF/c3FqIB0gGHFqQaSit+IFakEJdyAcaiIaIBdBf3NxaiAEIBxqIB0gG0EKdyIZQX9zcWogGiAZcWpBpKK34gVqQQ13IBhqIhsgF3FqQaSit+IFakEPdyAZaiIcIBtBCnciGEF/c3FqIBQgGWogGyAaQQp3IhlBf3NxaiAcIBlxakGkorfiBWpBB3cgF2oiGyAYcWpBpKK34gVqQQx3IBlqIh1BCnciF2ogFiAcQQp3IhpqIBEgGWogGyAaQX9zcWogHSAacWpBpKK34gVqQQh3IBhqIhwgF0F/c3FqIA4gGGogHSAbQQp3IhhBf3NxaiAcIBhxakGkorfiBWpBCXcgGmoiGiAXcWpBpKK34gVqQQt3IBhqIhsgGkEKdyIZQX9zcWogFSAYaiAaIBxBCnciGEF/c3FqIBsgGHFqQaSit+IFakEHdyAXaiIcIBlxakGkorfiBWpBB3cgGGoiHUEKdyIXaiADIBtBCnciGmogACAYaiAcIBpBf3NxaiAdIBpxakGkorfiBWpBDHcgGWoiGyAXQX9zcWogCCAZaiAdIBxBCnciGEF/c3FqIBsgGHFqQaSit+IFakEHdyAaaiIaIBdxakGkorfiBWpBBncgGGoiHCAaQQp3IhlBf3NxaiABIBhqIBogG0EKdyIYQX9zcWogHCAYcWpBpKK34gVqQQ93IBdqIhogGXFqQaSit+IFakENdyAYaiIbQQp3Ih1qIAYgGkEKdyIeaiAOIBxBCnciF2ogByAZaiAJIBhqIBogF0F/c3FqIBsgF3FqQaSit+IFakELdyAZaiIYIBtBf3NyIB5zakHz/cDrBmpBCXcgF2oiFyAYQX9zciAdc2pB8/3A6wZqQQd3IB5qIhkgF0F/c3IgGEEKdyIYc2pB8/3A6wZqQQ93IB1qIhogGUF/c3IgF0EKdyIXc2pB8/3A6wZqQQt3IBhqIhtBCnciHGogASAaQQp3Ih1qIBAgGUEKdyIZaiAVIBdqIBQgGGogGyAaQX9zciAZc2pB8/3A6wZqQQh3IBdqIhcgG0F/c3IgHXNqQfP9wOsGakEGdyAZaiIYIBdBf3NyIBxzakHz/cDrBmpBBncgHWoiGSAYQX9zciAXQQp3IhdzakHz/cDrBmpBDncgHGoiGiAZQX9zciAYQQp3IhhzakHz/cDrBmpBDHcgF2oiG0EKdyIcaiAWIBpBCnciHWogCSAZQQp3IhlqIAggGGogACAXaiAbIBpBf3NyIBlzakHz/cDrBmpBDXcgGGoiFyAbQX9zciAdc2pB8/3A6wZqQQV3IBlqIhggF0F/c3IgHHNqQfP9wOsGakEOdyAdaiIZIBhBf3NyIBdBCnciF3NqQfP9wOsGakENdyAcaiIaIBlBf3NyIBhBCnciGHNqQfP9wOsGakENdyAXaiIbQQp3IhxqIBEgGGogAyAXaiAbIBpBf3NyIBlBCnciGXNqQfP9wOsGakEHdyAYaiIYIBtBf3NyIBpBCnciGnNqQfP9wOsGakEFdyAZaiIXQQp3IhsgECAaaiAYQQp3Ih0gACAZaiAcIBdBf3NxaiAXIBhxakHp7bXTB2pBD3cgGmoiGEF/c3FqIBggF3FqQenttdMHakEFdyAcaiIXQX9zcWogFyAYcWpB6e210wdqQQh3IB1qIhlBCnciGmogBSAbaiAXQQp3IhwgBiAdaiAYQQp3Ih0gGUF/c3FqIBkgF3FqQenttdMHakELdyAbaiIXQX9zcWogFyAZcWpB6e210wdqQQ53IB1qIhhBCnciGyAHIBxqIBdBCnciHiAEIB1qIBogGEF/c3FqIBggF3FqQenttdMHakEOdyAcaiIXQX9zcWogFyAYcWpB6e210wdqQQZ3IBpqIhhBf3NxaiAYIBdxakHp7bXTB2pBDncgHmoiGUEKdyIaaiAIIBtqIBhBCnciHCAOIB5qIBdBCnciHSAZQX9zcWogGSAYcWpB6e210wdqQQZ3IBtqIhdBf3NxaiAXIBlxakHp7bXTB2pBCXcgHWoiGEEKdyIbIBEgHGogF0EKdyIeIAkgHWogGiAYQX9zcWogGCAXcWpB6e210wdqQQx3IBxqIhdBf3NxaiAXIBhxakHp7bXTB2pBCXcgGmoiGEF/c3FqIBggF3FqQenttdMHakEMdyAeaiIZQQp3IhogB2ogFSAXQQp3IhxqIBogFiAbaiAYQQp3Ih0gFCAeaiAcIBlBf3NxaiAZIBhxakHp7bXTB2pBBXcgG2oiF0F/c3FqIBcgGXFqQenttdMHakEPdyAcaiIYQX9zcWogGCAXcWpB6e210wdqQQh3IB1qIhkgGEEKdyIbcyAdIAhqIBggF0EKdyIXcyAZc2pBCHcgGmoiGHNqQQV3IBdqIhpBCnciHCAAaiAZQQp3IhkgBmogFyAWaiAYIBlzIBpzakEMdyAbaiIXIBxzIBsgA2ogGiAYQQp3IhhzIBdzakEJdyAZaiIZc2pBDHcgGGoiGiAZQQp3IhtzIBggDmogGSAXQQp3IhdzIBpzakEFdyAcaiIYc2pBDncgF2oiGUEKdyIcIBVqIBpBCnciGiAJaiAXIBRqIBggGnMgGXNqQQZ3IBtqIhcgHHMgGyAQaiAZIBhBCnciGHMgF3NqQQh3IBpqIhlzakENdyAYaiIaIBlBCnciG3MgGCARaiAZIBdBCnciGHMgGnNqQQZ3IBxqIhlzakEFdyAYaiIcQQp3Ih0gDGogBCAWIA4gDiARIBYgDiAUIAEgACABIBAgFCAEIBAgBiAPaiATIA1zIAsgDXMgDHMgCmogAmpBC3cgD2oiF3NqQQ53IAxqIh5BCnciH2ogAyASaiAJIAxqIBcgEnMgHnNqQQ93IBNqIgwgH3MgBSATaiAeIBdBCnciE3MgDHNqQQx3IBJqIhJzakEFdyATaiIXIBJBCnciHnMgEyAOaiASIAxBCnciDHMgF3NqQQh3IB9qIhJzakEHdyAMaiITQQp3Ih9qIAEgF0EKdyIXaiAMIBRqIBIgF3MgE3NqQQl3IB5qIgwgH3MgHiAAaiATIBJBCnciEnMgDHNqQQt3IBdqIhNzakENdyASaiIXIBNBCnciHnMgEiAWaiATIAxBCnciDHMgF3NqQQ53IB9qIhJzakEPdyAMaiITQQp3Ih9qIB4gEWogEyASQQp3IiBzIAwgCGogEiAXQQp3IgxzIBNzakEGdyAeaiISc2pBB3cgDGoiE0EKdyIXICAgB2ogEyASQQp3Ih5zIAwgFWogEiAfcyATc2pBCXcgIGoiE3NqQQh3IB9qIgxBf3NxaiAMIBNxakGZ84nUBWpBB3cgHmoiEkEKdyIfaiARIBdqIAxBCnciICADIB5qIBNBCnciEyASQX9zcWogEiAMcWpBmfOJ1AVqQQZ3IBdqIgxBf3NxaiAMIBJxakGZ84nUBWpBCHcgE2oiEkEKdyIXIBYgIGogDEEKdyIeIAYgE2ogHyASQX9zcWogEiAMcWpBmfOJ1AVqQQ13ICBqIgxBf3NxaiAMIBJxakGZ84nUBWpBC3cgH2oiEkF/c3FqIBIgDHFqQZnzidQFakEJdyAeaiITQQp3Ih9qIAUgF2ogEkEKdyIgIAcgHmogDEEKdyIeIBNBf3NxaiATIBJxakGZ84nUBWpBB3cgF2oiDEF/c3FqIAwgE3FqQZnzidQFakEPdyAeaiISQQp3IhcgAiAgaiAMQQp3IiEgCCAeaiAfIBJBf3NxaiASIAxxakGZ84nUBWpBB3cgIGoiDEF/c3FqIAwgEnFqQZnzidQFakEMdyAfaiISQX9zcWogEiAMcWpBmfOJ1AVqQQ93ICFqIhNBCnciHmogCSAXaiASQQp3Ih8gDiAhaiAMQQp3IiAgE0F/c3FqIBMgEnFqQZnzidQFakEJdyAXaiIMQX9zcWogDCATcWpBmfOJ1AVqQQt3ICBqIhJBCnciEyAEIB9qIAxBCnciFyAVICBqIB4gEkF/c3FqIBIgDHFqQZnzidQFakEHdyAfaiIMQX9zcWogDCAScWpBmfOJ1AVqQQ13IB5qIhJBf3MiIHFqIBIgDHFqQZnzidQFakEMdyAXaiIeQQp3Ih9qIAMgEkEKdyISaiAVIAxBCnciDGogFiATaiAFIBdqIB4gIHIgDHNqQaHX5/YGakELdyATaiITIB5Bf3NyIBJzakGh1+f2BmpBDXcgDGoiDCATQX9zciAfc2pBodfn9gZqQQZ3IBJqIhIgDEF/c3IgE0EKdyITc2pBodfn9gZqQQd3IB9qIhcgEkF/c3IgDEEKdyIMc2pBodfn9gZqQQ53IBNqIh5BCnciH2ogCSAXQQp3IiBqIAYgEkEKdyISaiAAIAxqIAcgE2ogHiAXQX9zciASc2pBodfn9gZqQQl3IAxqIgwgHkF/c3IgIHNqQaHX5/YGakENdyASaiISIAxBf3NyIB9zakGh1+f2BmpBD3cgIGoiEyASQX9zciAMQQp3IgxzakGh1+f2BmpBDncgH2oiFyATQX9zciASQQp3IhJzakGh1+f2BmpBCHcgDGoiHkEKdyIfaiAEIBdBCnciIGogESATQQp3IhNqIBAgEmogAiAMaiAeIBdBf3NyIBNzakGh1+f2BmpBDXcgEmoiDCAeQX9zciAgc2pBodfn9gZqQQZ3IBNqIhIgDEF/c3IgH3NqQaHX5/YGakEFdyAgaiITIBJBf3NyIAxBCnciF3NqQaHX5/YGakEMdyAfaiIeIBNBf3NyIBJBCnciEnNqQaHX5/YGakEHdyAXaiIfQQp3IgxqIAEgE0EKdyITaiAIIBdqIB8gHkF/c3IgE3NqQaHX5/YGakEFdyASaiIXIAxBf3NxaiAGIBJqIB8gHkEKdyISQX9zcWogFyAScWpB3Pnu+HhqQQt3IBNqIh4gDHFqQdz57vh4akEMdyASaiIfIB5BCnciE0F/c3FqIAQgEmogHiAXQQp3IhJBf3NxaiAfIBJxakHc+e74eGpBDncgDGoiHiATcWpB3Pnu+HhqQQ93IBJqIiBBCnciDGogCCAfQQp3IhdqIAIgEmogHiAXQX9zcWogICAXcWpB3Pnu+HhqQQ53IBNqIh8gDEF/c3FqIAAgE2ogICAeQQp3IhJBf3NxaiAfIBJxakHc+e74eGpBD3cgF2oiFyAMcWpB3Pnu+HhqQQl3IBJqIh4gF0EKdyITQX9zcWogAyASaiAXIB9BCnciEkF/c3FqIB4gEnFqQdz57vh4akEIdyAMaiIfIBNxakHc+e74eGpBCXcgEmoiIEEKdyIMaiAHIB5BCnciF2ogBSASaiAfIBdBf3NxaiAgIBdxakHc+e74eGpBDncgE2oiHiAMQX9zcWogFCATaiAgIB9BCnciEkF/c3FqIB4gEnFqQdz57vh4akEFdyAXaiIXIAxxakHc+e74eGpBBncgEmoiHyAXQQp3IhNBf3NxaiAVIBJqIBcgHkEKdyISQX9zcWogHyAScWpB3Pnu+HhqQQh3IAxqIhcgE3FqQdz57vh4akEGdyASaiIeQQp3IiBqIAIgF0EKdyIOaiADIB9BCnciDGogCSATaiAeIA5Bf3NxaiAQIBJqIBcgDEF/c3FqIB4gDHFqQdz57vh4akEFdyATaiIDIA5xakHc+e74eGpBDHcgDGoiDCADICBBf3Nyc2pBzvrPynpqQQl3IA5qIg4gDCADQQp3IgNBf3Nyc2pBzvrPynpqQQ93ICBqIhIgDiAMQQp3IgxBf3Nyc2pBzvrPynpqQQV3IANqIhNBCnciF2ogCSASQQp3IhZqIAggDkEKdyIJaiAUIAxqIAEgA2ogEyASIAlBf3Nyc2pBzvrPynpqQQt3IAxqIgMgEyAWQX9zcnNqQc76z8p6akEGdyAJaiIIIAMgF0F/c3JzakHO+s/KempBCHcgFmoiCSAIIANBCnciA0F/c3JzakHO+s/KempBDXcgF2oiDiAJIAhBCnciCEF/c3JzakHO+s/KempBDHcgA2oiFEEKdyIWaiAAIA5BCnciDGogBSAJQQp3IgBqIAYgCGogFSADaiAUIA4gAEF/c3JzakHO+s/KempBBXcgCGoiAyAUIAxBf3Nyc2pBzvrPynpqQQx3IABqIgAgAyAWQX9zcnNqQc76z8p6akENdyAMaiIGIAAgA0EKdyIDQX9zcnNqQc76z8p6akEOdyAWaiIIIAYgAEEKdyIAQX9zcnNqQc76z8p6akELdyADaiIJQQp3IhVqNgKQiQFBACALIBggAmogGSAaQQp3IgJzIBxzakEPdyAbaiIOQQp3IhZqIBAgA2ogCSAIIAZBCnciA0F/c3JzakHO+s/KempBCHcgAGoiBkEKd2o2AoyJAUEAIA0gGyAFaiAcIBlBCnciBXMgDnNqQQ13IAJqIhRBCndqIAcgAGogBiAJIAhBCnciAEF/c3JzakHO+s/KempBBXcgA2oiB2o2AoiJAUEAIAAgCmogAiABaiAOIB1zIBRzakELdyAFaiIBaiARIANqIAcgBiAVQX9zcnNqQc76z8p6akEGd2o2ApiJAUEAIAAgD2ogHWogBSAEaiAUIBZzIAFzakELd2o2ApSJAQuiAwEIfwJAIAFFDQBBACECQQBBACgCgIkBIgMgAWoiBDYCgIkBIANBP3EhBQJAIAQgA08NAEEAQQAoAoSJAUEBajYChIkBCwJAIAVFDQACQCABQcAAIAVrIgZPDQAgBSECDAELIAZBA3EhB0EAIQMCQCAFQT9zQQNJDQAgBUGAiQFqIQggBkH8AHEhCUEAIQMDQCAIIANqIgJBHGogACADaiIELQAAOgAAIAJBHWogBEEBai0AADoAACACQR5qIARBAmotAAA6AAAgAkEfaiAEQQNqLQAAOgAAIAkgA0EEaiIDRw0ACwsCQCAHRQ0AIAAgA2ohAiADIAVqQZyJAWohAwNAIAMgAi0AADoAACACQQFqIQIgA0EBaiEDIAdBf2oiBw0ACwtBnIkBEAIgASAGayEBIAAgBmohAEEAIQILAkAgAUHAAEkNAANAIAAQAiAAQcAAaiEAIAFBQGoiAUE/Sw0ACwsgAUUNACACQZyJAWohA0EAIQIDQCADIAAtAAA6AAAgAEEBaiEAIANBAWohAyABIAJBAWoiAkH/AXFLDQALCwsJAEGACSAAEAMLggEBAn8jAEEQayIAJAAgAEEAKAKAiQEiAUEDdDYCCCAAQQAoAoSJAUEDdCABQR12cjYCDEGQCEE4QfgAIAFBP3EiAUE4SRsgAWsQAyAAQQhqQQgQA0EAQQAoAoiJATYCgAlBAEEAKQKMiQE3AoQJQQBBACkClIkBNwKMCSAAQRBqJAALBgBBgIkBC8EBAQF/IwBBEGsiASQAQQBB8MPLnnw2ApiJAUEAQv6568XpjpWZEDcCkIkBQQBCgcaUupbx6uZvNwKIiQFBAEIANwKAiQFBgAkgABADIAFBACgCgIkBIgBBA3Q2AgggAUEAKAKEiQFBA3QgAEEddnI2AgxBkAhBOEH4ACAAQT9xIgBBOEkbIABrEAMgAUEIakEIEANBAEEAKAKIiQE2AoAJQQBBACkCjIkBNwKECUEAQQApApSJATcCjAkgAUEQaiQACwtXAQBBgAgLUFwAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    hash$4 = "6abbce74";
    wasmJson$4 = {
      name: name$4,
      data: data$4,
      hash: hash$4
    };
    mutex$2 = new Mutex();
    wasmCache$2 = null;
    validateOptions$2 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.hashFunction || !options.hashFunction.then) {
        throw new Error('Invalid hash function is provided! Usage: pbkdf2("password", "salt", 1000, 32, createSHA1()).');
      }
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$3 = "scrypt";
    data$3 = "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cyICajYCOCAAIAAoAjwgAiAKakESdyAGc2o2AjwLvxIDFX8Bfg5/AkAgAkUNACAAQQd0IgNBQGoiBEEAKAKACCIFIAMgAmwiBmogAyABbGoiByADaiIIaiEJIAAgAkEHdCIKIAFBB3RqIgtsIQwgACALQYABamwhDSAAQQV0IgtBASALQQFLGyILQWBxIQ4gC0EBcSEPIAdBeGohECAHQXBqIREgB0FoaiESIAdBYGohEyAHQVhqIRQgB0FQaiEVIAdBSGohFiAHQUBqIRcgAa1Cf3whGCAEIAdqIRkgByAAQQh0IhpqIRsgACAKQYABamwhHCALQQRJIR1BACEeQQAhHwNAQQAoAoAIIiAgAyAfbGohIQJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgByALaiIEICMgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AIAcgIkECdCILaiAhIAtqKAIANgIACwJAIAFFDQBBACElIBwhIyAGISYDQCAFISQgACEiAkACQCAADQAgGyAXKQMANwMAIBsgFikDADcDCCAbIBUpAwA3AxAgGyAUKQMANwMYIBsgEykDADcDICAbIBIpAwA3AyggGyARKQMANwMwIBsgECkDADcDOAwBCwNAICQgJmoiCyAkIAxqIgQpAwA3AwAgC0EIaiAEQQhqKQMANwMAIAtBEGogBEEQaikDADcDACALQRhqIARBGGopAwA3AwAgC0EgaiAEQSBqKQMANwMAIAtBKGogBEEoaikDADcDACALQTBqIARBMGopAwA3AwAgC0E4aiAEQThqKQMANwMAIAtBwABqIARBwABqKQMANwMAIAtByABqIARByABqKQMANwMAIAtB0ABqIARB0ABqKQMANwMAIAtB2ABqIARB2ABqKQMANwMAIAtB4ABqIARB4ABqKQMANwMAIAtB6ABqIARB6ABqKQMANwMAIAtB8ABqIARB8ABqKQMANwMAIAtB+ABqIARB+ABqKQMANwMAICRBgAFqISQgIkF/aiIiDQALIAcgCCAbIAAQAiAFISQgACEiA0AgJCAjaiILICQgDWoiBCkDADcDACALQQhqIARBCGopAwA3AwAgC0EQaiAEQRBqKQMANwMAIAtBGGogBEEYaikDADcDACALQSBqIARBIGopAwA3AwAgC0EoaiAEQShqKQMANwMAIAtBMGogBEEwaikDADcDACALQThqIARBOGopAwA3AwAgC0HAAGogBEHAAGopAwA3AwAgC0HIAGogBEHIAGopAwA3AwAgC0HQAGogBEHQAGopAwA3AwAgC0HYAGogBEHYAGopAwA3AwAgC0HgAGogBEHgAGopAwA3AwAgC0HoAGogBEHoAGopAwA3AwAgC0HwAGogBEHwAGopAwA3AwAgC0H4AGogBEH4AGopAwA3AwAgJEGAAWohJCAiQX9qIiINAAsLIAggByAbIAAQAiAjIBpqISMgJiAaaiEmICVBAmoiJSABSQ0AC0EAISUDQAJAAkAgAA0AIBsgFykDADcDACAbIBYpAwA3AwggGyAVKQMANwMQIBsgFCkDADcDGCAbIBMpAwA3AyAgGyASKQMANwMoIBsgESkDADcDMCAbIBApAwA3AzgMAQsgACAKIBkpAgAgGIOnQQd0amwhJiAFISQgACEiA0AgJCAMaiILIAspAwAgJCAmaiIEKQMAhTcDACALQQhqIiMgIykDACAEQQhqKQMAhTcDACALQRBqIiMgIykDACAEQRBqKQMAhTcDACALQRhqIiMgIykDACAEQRhqKQMAhTcDACALQSBqIiMgIykDACAEQSBqKQMAhTcDACALQShqIiMgIykDACAEQShqKQMAhTcDACALQTBqIiMgIykDACAEQTBqKQMAhTcDACALQThqIiMgIykDACAEQThqKQMAhTcDACALQcAAaiIjICMpAwAgBEHAAGopAwCFNwMAIAtByABqIiMgIykDACAEQcgAaikDAIU3AwAgC0HQAGoiIyAjKQMAIARB0ABqKQMAhTcDACALQdgAaiIjICMpAwAgBEHYAGopAwCFNwMAIAtB4ABqIiMgIykDACAEQeAAaikDAIU3AwAgC0HoAGoiIyAjKQMAIARB6ABqKQMAhTcDACALQfAAaiIjICMpAwAgBEHwAGopAwCFNwMAIAtB+ABqIgsgCykDACAEQfgAaikDAIU3AwAgJEGAAWohJCAiQX9qIiINAAsgByAIIBsgABACIAAgCiAJKQIAIBiDp0EHdGpsISYgBSEkIAAhIgNAICQgDWoiCyALKQMAICQgJmoiBCkDAIU3AwAgC0EIaiIjICMpAwAgBEEIaikDAIU3AwAgC0EQaiIjICMpAwAgBEEQaikDAIU3AwAgC0EYaiIjICMpAwAgBEEYaikDAIU3AwAgC0EgaiIjICMpAwAgBEEgaikDAIU3AwAgC0EoaiIjICMpAwAgBEEoaikDAIU3AwAgC0EwaiIjICMpAwAgBEEwaikDAIU3AwAgC0E4aiIjICMpAwAgBEE4aikDAIU3AwAgC0HAAGoiIyAjKQMAIARBwABqKQMAhTcDACALQcgAaiIjICMpAwAgBEHIAGopAwCFNwMAIAtB0ABqIiMgIykDACAEQdAAaikDAIU3AwAgC0HYAGoiIyAjKQMAIARB2ABqKQMAhTcDACALQeAAaiIjICMpAwAgBEHgAGopAwCFNwMAIAtB6ABqIiMgIykDACAEQegAaikDAIU3AwAgC0HwAGoiIyAjKQMAIARB8ABqKQMAhTcDACALQfgAaiILIAspAwAgBEH4AGopAwCFNwMAICRBgAFqISQgIkF/aiIiDQALCyAIIAcgGyAAEAIgJUECaiIlIAFJDQALCwJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgIyALaiIEIAcgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AICEgIkECdCILaiAHIAtqKAIANgIACyAeIANqIR4gH0EBaiIfIAJHDQALCws=";
    hash$3 = "b32721f8";
    wasmJson$3 = {
      name: name$3,
      data: data$3,
      hash: hash$3
    };
    isPowerOfTwo = (v) => v && !(v & v - 1);
    validateOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.blockSize) || options.blockSize < 1) {
        throw new Error("Block size should be a positive number");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 2 || !isPowerOfTwo(options.costFactor)) {
        throw new Error("Cost factor should be a power of 2, greater than 1");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$2 = "bcrypt";
    data$2 = "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";
    hash$2 = "8bd8822d";
    wasmJson$2 = {
      name: name$2,
      data: data$2,
      hash: hash$2
    };
    validateOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 4 || options.costFactor > 31) {
        throw new Error("Cost factor should be a number between 4 and 31");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length !== 16) {
        throw new Error("Salt should be 16 bytes long");
      }
      if (options.outputType === void 0) {
        options.outputType = "encoded";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    validateHashCharacters = (hash2) => {
      if (!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(hash2)) {
        return false;
      }
      if (hash2[4] === "0" && Number(hash2[5]) < 4) {
        return false;
      }
      if (hash2[4] === "3" && Number(hash2[5]) > 1) {
        return false;
      }
      return true;
    };
    validateVerifyOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
      if (options.hash.length !== 60) {
        throw new Error("Hash should be 60 bytes long");
      }
      if (!validateHashCharacters(options.hash)) {
        throw new Error("Invalid hash");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
    };
    name$1 = "whirlpool";
    data$1 = "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";
    hash$1 = "8d8f6035";
    wasmJson$1 = {
      name: name$1,
      data: data$1,
      hash: hash$1
    };
    mutex$1 = new Mutex();
    wasmCache$1 = null;
    name = "sm3";
    data = "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";
    hash = "b6fb4b8e";
    wasmJson = {
      name,
      data,
      hash
    };
    mutex = new Mutex();
    wasmCache = null;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/libsodium.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = void 0;
    exports.isArgon2idOptions = isArgon2idOptions;
    var utils_1 = require_build3();
    var chacha_js_1 = require_chacha();
    var ed25519_js_1 = require_ed25519();
    var hash_wasm_1 = (init_index_esm(), __toCommonJS(index_esm_exports));
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    var Argon2id = class {
      static async execute(password, salt, options) {
        const opts = {
          password,
          salt,
          outputType: "binary",
          iterations: options.opsLimit,
          memorySize: options.memLimitKib,
          parallelism: 1,
          // no parallelism allowed, just like libsodium
          hashLength: options.outputLength
        };
        if (salt.length !== 16) {
          throw new Error(`Got invalid salt length ${salt.length}. Must be 16.`);
        }
        const hash2 = await (0, hash_wasm_1.argon2id)(opts);
        (0, utils_1.assert)(typeof hash2 !== "string");
        return hash2;
      }
    };
    exports.Argon2id = Argon2id;
    var Ed25519Keypair = class _Ed25519Keypair {
      constructor(privkey, pubkey) {
        __publicField(this, "privkey");
        __publicField(this, "pubkey");
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new _Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(privKey) {
        const pubKey = ed25519_js_1.ed25519.getPublicKey(privKey);
        return new Ed25519Keypair(privKey, pubKey);
      }
      static async createSignature(message, keyPair) {
        return ed25519_js_1.ed25519.sign(message, keyPair.privkey);
      }
      static async verifySignature(signature, message, pubkey) {
        return ed25519_js_1.ed25519.verify(signature, message, pubkey);
      }
    };
    exports.Ed25519 = Ed25519;
    exports.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.encrypt(message);
      }
      static async decrypt(ciphertext, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.decrypt(ciphertext);
      }
    };
    exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        const out = new Uint8Array(count);
        globalThis.crypto.getRandomValues(out);
        return out;
      }
    };
    exports.Random = Random;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K2;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K2 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K2 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K2 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K2 = 3395469782;
          }
          const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K2 + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA1 = SHA1;
    exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = Math.pow(2, 32);
    var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
    var MD5_IV = SHA1_IV.slice(0, 4);
    var MD5_W = new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = 7 * i % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.MD5 = MD5;
    exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
    var idxLR = (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    var idxL = (() => idxLR[0])();
    var idxR = (() => idxLR[1])();
    var shifts160 = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var Kl160 = Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr160 = Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      if (group === 1)
        return x & y | ~x & z;
      if (group === 2)
        return (x | ~y) ^ z;
      if (group === 3)
        return x & z | y & ~z;
      return x ^ (y | ~z);
    }
    var BUF_160 = new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/ripemd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ripemd160 = void 0;
    exports.ripemd160 = ripemd1602;
    var legacy_1 = require_legacy();
    var utils_1 = require_utils2();
    var Ripemd160 = class {
      constructor(firstData) {
        __publicField(this, "blockSize", 512 / 8);
        __publicField(this, "impl", legacy_1.ripemd160.create());
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Ripemd160 = Ripemd160;
    function ripemd1602(data2) {
      return new Ripemd160(data2).digest();
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = exports.DERErr = void 0;
    exports._splitEndoScalar = _splitEndoScalar;
    exports._normFnElement = _normFnElement;
    exports.weierstrassN = weierstrassN;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports.ecdh = ecdh;
    exports.ecdsa = ecdsa;
    exports.weierstrassPoints = weierstrassPoints;
    exports._legacyHelperEquat = _legacyHelperEquat;
    exports.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
    function _splitEndoScalar(k, basis, n) {
      const [[a1, b1], [a2, b2]] = basis;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = k - c1 * a1 - c2 * a2;
      let k2 = -c1 * b1 - c2 * b2;
      const k1neg = k1 < _0n;
      const k2neg = k2 < _0n;
      if (k1neg)
        k1 = -k1;
      if (k2neg)
        k2 = -k2;
      const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
      if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function validateSigFormat(format) {
      if (!["compact", "recovered", "der"].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
      return format;
    }
    function validateSigOpts(opts, def) {
      const optsn = {};
      for (let optName of Object.keys(def)) {
        optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
      }
      (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
      (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
      if (optsn.format !== void 0)
        validateSigFormat(optsn.format);
      return optsn;
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports.DERErr = DERErr;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data2) => {
          const { Err: E } = exports.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data2.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data2.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data2;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data2) {
          const { Err: E } = exports.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data2.length < 2 || data2[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data2[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data2.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data2.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data2.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data2) {
          const { Err: E } = exports.DER;
          if (data2[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data2[0] === 0 && !(data2[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data2);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data2 = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _normFnElement(Fn, key) {
      const { BYTES: expected } = Fn;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = extraOpts;
      if (endo) {
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
          throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
      }
      const lengths = getWLengths(Fp, Fn);
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === comp && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (length === uncomp && head === 4) {
          const L = Fp.BYTES;
          const x = Fp.fromBytes(tail.subarray(0, L));
          const y = Fp.fromBytes(tail.subarray(L, L * 2));
          if (!isValidXY(x, y))
            throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
      }
      const encodePoint = extraOpts.toBytes || pointToBytes;
      const decodePoint = extraOpts.fromBytes || pointFromBytes;
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
      }
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
          throw new Error("no endo");
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        if (Fp.eql(Z, Fp.ONE))
          return { x: X, y: Y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
          if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y, true);
          this.Z = acoord("z", Z);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
          const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
          P.assertValidity();
          return P;
        }
        static fromHex(hex) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = extraOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p, f } = mul(scalar);
            point = p;
            fake = f;
          }
          return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = extraOpts;
          const p = this;
          if (!Fn.isValid(sc))
            throw new Error("invalid scalar: out of range");
          if (sc === _0n || p.is0())
            return Point.ZERO;
          if (sc === _1n)
            return p;
          if (wnaf.hasCache(this))
            return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
            const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
            return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = extraOpts;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = extraOpts;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          this.assertValidity();
          return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
      Point.BASE.precompute(8);
      return Point;
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
    function getWLengths(Fp, Fn) {
      return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES
      };
    }
    function ecdh(Point, ecdhOpts = {}) {
      const { Fn } = Point;
      const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
      const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
      function isValidSecretKey(secretKey) {
        try {
          return !!_normFnElement(Fn, secretKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
          const l = publicKey.length;
          if (isCompressed === true && l !== comp)
            return false;
          if (isCompressed === false && l !== publicKeyUncompressed)
            return false;
          return !!Point.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"), Fn.ORDER);
      }
      function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
      }
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point)
          return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
          return void 0;
        const l = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l === publicKey || l === publicKeyUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB);
        return b.multiply(s).toBytes(isCompressed);
      }
      const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
    }
    function ecdsa(Point, hash2, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash2);
      (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
      const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: false
      };
      const defaultSigOpts_format = "compact";
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
      }
      function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
      }
      class Signature {
        constructor(r, s, recovery) {
          this.r = validateRS("r", r);
          this.s = validateRS("s", s);
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
          validateSigLength(bytes, format);
          let recid;
          if (format === "der") {
            const { r: r2, s: s2 } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
            return new Signature(r2, s2);
          }
          if (format === "recovered") {
            recid = bytes[0];
            format = "compact";
            bytes = bytes.subarray(1);
          }
          const L = Fn.BYTES;
          const r = bytes.subarray(0, L);
          const s = bytes.subarray(L, L * 2);
          return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
          const ir = Fn.inv(radj);
          const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0())
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
          validateSigFormat(format);
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
          const r = Fn.toBytes(this.r);
          const s = Fn.toBytes(this.s);
          if (format === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
          }
          return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "compact");
        }
        static fromDER(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "der");
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
        const delta = bytes.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
        return Fn.create(bits2int(bytes));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, void 0, "message");
        return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
      }
      function prepSig(message, privateKey, opts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (extraEntropy != null && extraEntropy !== false) {
          const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k))
            return;
          const ik = Fn.inv(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n)
            return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = Fn.neg(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)("message", message);
        const { seed, k2sig } = prepSig(message, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig);
        return sig;
      }
      function tryParsingSig(sg) {
        let sig = void 0;
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (isObj) {
          sig = new Signature(sg.r, sg.s);
        } else if (isHex) {
          try {
            sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
          }
          if (!sig) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
            } catch (error) {
              return false;
            }
          }
        }
        if (!sig)
          return false;
        return sig;
      }
      function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
        if (sig === false)
          return false;
        try {
          const P = Point.fromBytes(publicKey);
          if (lowS && sig.hasHighS())
            return false;
          const { r, s } = sig;
          const h = bits2int_modN(message);
          const is = Fn.inv(s);
          const u1 = Fn.create(h * is);
          const u2 = Fn.create(r * is);
          const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
          if (R.is0())
            return false;
          const v = Fn.create(R.x);
          return v === r;
        } catch (e) {
          return false;
        }
      }
      function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash: hash2
      });
    }
    function weierstrassPoints(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point);
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths,
        modFromBytes: c.wrapPrivateKey
      });
      const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
      };
      return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
    }
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _weierstrass_new_output_to_legacy(c, Point) {
      const { Fp, Fn } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      return Object.assign({}, {
        CURVE: c,
        Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c, _ecdsa) {
      const Point = _ecdsa.Point;
      return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
      });
    }
    function weierstrass(c) {
      const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, hash2, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash2) {
      return { hash: hash2 };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
      return { ...create(defHash), create };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils4();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var Pointk1 = (() => exports.secp256k1.Point)();
    var hasEven = (y) => y % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      const { Fn, BASE } = Pointk1;
      const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
      const p = BASE.multiply(d_);
      const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      const Fp = Fpk1;
      if (!Fp.isValidNot0(x))
        throw new Error("invalid x: Fail if x ≥ p");
      const xx = Fp.create(x * x);
      const c = Fp.create(xx * x + BigInt(7));
      let y = Fp.sqrt(c);
      if (!hasEven(y))
        y = Fp.neg(y);
      const p = Pointk1.fromAffine({ x, y });
      p.assertValidity();
      return p;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const { Fn } = Pointk1;
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const { Fn, BASE } = Pointk1;
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
          return false;
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod
        },
        lengths: {
          secretKey: size,
          publicKey: size,
          publicKeyHasPrefix: false,
          signature: size * 2,
          seed: seedLength
        }
      };
    })();
    var isoMap = (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class _Secp256k1Signature {
      constructor(r, s) {
        __publicField(this, "data");
        if (r.length > 32 || r.length === 0 || r[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s.length > 32 || s.length === 0 || s[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r,
          s
        };
      }
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data2) {
        if (data2.length !== 64) {
          throw new Error(`Got invalid data length: ${data2.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new _Secp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)));
      }
      static fromDer(data2) {
        let pos = 0;
        if (data2[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data2[pos++];
        if (data2.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data2[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data2[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data2.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data2[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data2[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data2.slice(pos, pos + sLength);
        pos += sLength;
        return new _Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data2 = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data2.length, ...data2]);
      }
    };
    exports.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature = class _ExtendedSecp256k1Signature extends Secp256k1Signature {
      constructor(r, s, recovery) {
        super(r, s);
        __publicField(this, "recovery");
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data2) {
        if (data2.length !== 65) {
          throw new Error(`Got invalid data length ${data2.length}. Expected 32 + 32 + 1`);
        }
        return new _ExtendedSecp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)), data2[64]);
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1 = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var secp256k1_1 = require_secp256k1();
    var secp256k1signature_1 = require_secp256k1signature();
    function unsignedBigIntToBytes(a) {
      (0, utils_1.assert)(a >= 0n);
      let hex = a.toString(16);
      if (hex.length % 2)
        hex = "0" + hex;
      return (0, encoding_1.fromHex)(hex);
    }
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    var Secp256k1 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(privkey)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey,
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: secp256k1_1.secp256k1.getPublicKey(privkey, false)
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const { recovery, r, s } = secp256k1_1.secp256k1.sign(messageHash, privkey, {
          lowS: true
        });
        if (typeof recovery !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(unsignedBigIntToBytes(r), unsignedBigIntToBytes(s), recovery);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const encodedSig = secp256k1_1.secp256k1.Signature.fromDER(signature.toDer());
        return secp256k1_1.secp256k1.verify(encodedSig, messageHash, pubkey, { lowS: false });
      }
      static recoverPubkey(signature, messageHash) {
        const pk = new secp256k1_1.secp256k1.Signature(bytesToUnsignedBigInt(signature.r()), bytesToUnsignedBigInt(signature.s()), signature.recovery).recoverPublicKey(messageHash);
        return pk.toBytes(false);
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(true);
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(false);
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports.Secp256k1 = Secp256k1;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/slip10.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slip10 = exports.Slip10RawIndex = exports.Slip10Curve = void 0;
    exports.slip10CurveFromString = slip10CurveFromString;
    exports.pathToString = pathToString;
    exports.stringToPath = stringToPath;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var utils_1 = require_build3();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac2();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve || (exports.Slip10Curve = Slip10Curve = {}));
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    function intTo32be(n) {
      (0, utils_1.assert)(n >= 0n);
      (0, utils_1.assert)(n < 2n ** (32n * 8n));
      const hex = n.toString(16).padStart(64, "0");
      return (0, encoding_1.fromHex)(hex);
    }
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    var Slip10RawIndex = class _Slip10RawIndex extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new _Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new _Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports.Slip10RawIndex = Slip10RawIndex;
    var Slip10 = class _Slip10 {
      static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path) {
          result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        }
        return result;
      }
      static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i);
        }
        return {
          chainCode: ir,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data2 = new Uint8Array([
              ..._Slip10.serializedPoint(curve, bytesToUnsignedBigInt(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data2).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return secp256k1_1.secp256k1.Point.BASE.multiply(p).toBytes(true);
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        const returnChainCode = ir;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n = this.n(curve);
        const returnChildKeyAsNumber = (bytesToUnsignedBigInt(il) + bytesToUnsignedBigInt(parentPrivkey)) % n;
        const returnChildKey = intTo32be(returnChildKeyAsNumber);
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = bytesToUnsignedBigInt(privkey);
        return keyAsNumber >= this.n(curve);
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.36.1/node_modules/@cosmjs/crypto/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToPath = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = exports.Slip10 = exports.pathToString = exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = exports.Secp256k1Signature = exports.ExtendedSecp256k1Signature = exports.Secp256k1 = exports.ripemd160 = exports.Ripemd160 = exports.Random = exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.isArgon2idOptions = exports.Ed25519Keypair = exports.Ed25519 = exports.Argon2id = exports.keccak256 = exports.Keccak256 = exports.Hmac = exports.EnglishMnemonic = exports.Bip39 = void 0;
    var bip39_1 = require_bip39();
    Object.defineProperty(exports, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac2();
    Object.defineProperty(exports, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium();
    Object.defineProperty(exports, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/pubkeys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyType = void 0;
    exports.isEd25519Pubkey = isEd25519Pubkey;
    exports.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports.isSinglePubkey = isSinglePubkey;
    exports.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports.pubkeyType.ed25519, exports.pubkeyType.secp256k1, exports.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    exports.encodeEd25519Pubkey = encodeEd25519Pubkey;
    exports.decodeAminoPubkey = decodeAminoPubkey;
    exports.decodeBech32Pubkey = decodeBech32Pubkey;
    exports.encodeAminoPubkey = encodeAminoPubkey;
    exports.encodeBech32Pubkey = encodeBech32Pubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data2) {
      if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSecp256k1)) {
        const rest = data2.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixEd25519)) {
        const rest = data2.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSr25519)) {
        const rest = data2.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data2);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data2.slice(0, 5)));
      }
    }
    function decodeBech32Pubkey(bechEncoded) {
      const { data: data2 } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data2);
    }
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data2) {
      const reader = Array.from(data2);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/coins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coin = coin;
    exports.coins = coins;
    exports.parseCoins = parseCoins;
    exports.addCoins = addCoins;
    var math_1 = require_build();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/:._-]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareArrays = compareArrays;
    exports.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/omitdefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitDefault = omitDefault;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
    exports.decodeSignature = decodeSignature;
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        // Note: please don't add cases here without writing additional unit tests
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/signdoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortedJsonStringify = sortedJsonStringify;
    exports.makeSignDoc = makeSignDoc;
    exports.escapeCharacters = escapeCharacters;
    exports.serializeSignDoc = serializeSignDoc;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt = /</g;
      const gt = />/g;
      return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
    }
    function serializeSignDoc(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
          await screamTest;
          return result;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class _Secp256k1HdWallet {
      constructor(mnemonic, options) {
        /** Base secret */
        __publicField(this, "secret");
        /** BIP39 seed */
        __publicField(this, "seed");
        /** Derivation instruction */
        __publicField(this, "accounts");
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      constructor(privkey, pubkey, prefix) {
        __publicField(this, "pubkey");
        __publicField(this, "privkey");
        __publicField(this, "prefix");
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/stdtx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStdTx = isStdTx;
    exports.makeStdTx = makeStdTx;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.36.1/node_modules/@cosmjs/amino/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeKdf = exports.makeStdTx = exports.isStdTx = exports.serializeSignDoc = exports.makeSignDoc = exports.encodeSecp256k1Signature = exports.decodeSignature = exports.Secp256k1Wallet = exports.Secp256k1HdWallet = exports.extractKdfConfiguration = exports.pubkeyType = exports.isSinglePubkey = exports.isSecp256k1Pubkey = exports.isMultisigThresholdPubkey = exports.isEd25519Pubkey = exports.makeCosmoshubPath = exports.omitDefault = exports.createMultisigThresholdPubkey = exports.encodeSecp256k1Pubkey = exports.encodeEd25519Pubkey = exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.parseCoins = exports.coins = exports.coin = exports.addCoins = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeAuthInfoBytes = makeAuthInfoBytes;
    exports.makeSignDoc = makeSignDoc;
    exports.makeSignBytes = makeSignBytes;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
          await screamTest;
          return result;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class _DirectSecp256k1HdWallet {
      constructor(mnemonic, options) {
        /** Base secret */
        __publicField(this, "secret");
        /** BIP39 seed */
        __publicField(this, "seed");
        /** Derivation instructions */
        __publicField(this, "accounts");
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      constructor(privkey, pubkey, prefix) {
        __publicField(this, "pubkey");
        __publicField(this, "privkey");
        __publicField(this, "prefix");
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.ed25519";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PubKey = {
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PrivKey = {
      typeUrl: "/cosmos.crypto.ed25519.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js
var require_keys2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyAminoPubKey = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.multisig";
    function createBaseLegacyAminoPubKey() {
      return {
        threshold: 0,
        publicKeys: []
      };
    }
    exports.LegacyAminoPubKey = {
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== 0) {
          writer.uint32(8).uint32(message.threshold);
        }
        for (const v of message.publicKeys) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.uint32();
              break;
            case 2:
              message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLegacyAminoPubKey();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = Number(object.threshold);
        if (Array.isArray(object == null ? void 0 : object.publicKeys))
          obj.publicKeys = object.publicKeys.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) {
          obj.publicKeys = message.publicKeys.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.publicKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseLegacyAminoPubKey();
        message.threshold = object.threshold ?? 0;
        message.publicKeys = ((_a2 = object.publicKeys) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js
var require_keys3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.secp256k1";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PubKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PrivKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePubkey = encodePubkey;
    exports.anyToSinglePubkey = anyToSinglePubkey;
    exports.decodePubkey = decodePubkey;
    exports.decodeOptionalPubkey = decodeOptionalPubkey;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams() {
      return {
        sendEnabled: [],
        defaultSendEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.bank.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled) {
          exports.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object == null ? void 0 : object.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => exports.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.defaultSendEnabled))
          obj.defaultSendEnabled = Boolean(object.defaultSendEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? exports.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseParams();
        message.sendEnabled = ((_a2 = object.sendEnabled) == null ? void 0 : _a2.map((e) => exports.SendEnabled.fromPartial(e))) || [];
        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
        return message;
      }
    };
    function createBaseSendEnabled() {
      return {
        denom: "",
        enabled: false
      };
    }
    exports.SendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSendEnabled();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.enabled))
          obj.enabled = Boolean(object.enabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSendEnabled();
        message.denom = object.denom ?? "";
        message.enabled = object.enabled ?? false;
        return message;
      }
    };
    function createBaseInput() {
      return {
        address: "",
        coins: []
      };
    }
    exports.Input = {
      typeUrl: "/cosmos.bank.v1beta1.Input",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInput();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object == null ? void 0 : object.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseInput();
        message.address = object.address ?? "";
        message.coins = ((_a2 = object.coins) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseOutput() {
      return {
        address: "",
        coins: []
      };
    }
    exports.Output = {
      typeUrl: "/cosmos.bank.v1beta1.Output",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseOutput();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object == null ? void 0 : object.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseOutput();
        message.address = object.address ?? "";
        message.coins = ((_a2 = object.coins) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return {
        total: []
      };
    }
    exports.Supply = {
      typeUrl: "/cosmos.bank.v1beta1.Supply",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.total) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSupply();
        if (Array.isArray(object == null ? void 0 : object.total))
          obj.total = object.total.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSupply();
        message.total = ((_a2 = object.total) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDenomUnit() {
      return {
        denom: "",
        exponent: 0,
        aliases: []
      };
    }
    exports.DenomUnit = {
      typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v of message.aliases) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomUnit();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.exponent))
          obj.exponent = Number(object.exponent);
        if (Array.isArray(object == null ? void 0 : object.aliases))
          obj.aliases = object.aliases.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e) => e);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDenomUnit();
        message.denom = object.denom ?? "";
        message.exponent = object.exponent ?? 0;
        message.aliases = ((_a2 = object.aliases) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMetadata() {
      return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: "",
        uri: "",
        uriHash: ""
      };
    }
    exports.Metadata = {
      typeUrl: "/cosmos.bank.v1beta1.Metadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v of message.denomUnits) {
          exports.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        if (message.uri !== "") {
          writer.uint32(58).string(message.uri);
        }
        if (message.uriHash !== "") {
          writer.uint32(66).string(message.uriHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            case 7:
              message.uri = reader.string();
              break;
            case 8:
              message.uriHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMetadata();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if (Array.isArray(object == null ? void 0 : object.denomUnits))
          obj.denomUnits = object.denomUnits.map((e) => exports.DenomUnit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.base))
          obj.base = String(object.base);
        if ((0, helpers_1.isSet)(object.display))
          obj.display = String(object.display);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.symbol))
          obj.symbol = String(object.symbol);
        if ((0, helpers_1.isSet)(object.uri))
          obj.uri = String(object.uri);
        if ((0, helpers_1.isSet)(object.uriHash))
          obj.uriHash = String(object.uriHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e) => e ? exports.DenomUnit.toJSON(e) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        message.uri !== void 0 && (obj.uri = message.uri);
        message.uriHash !== void 0 && (obj.uriHash = message.uriHash);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMetadata();
        message.description = object.description ?? "";
        message.denomUnits = ((_a2 = object.denomUnits) == null ? void 0 : _a2.map((e) => exports.DenomUnit.fromPartial(e))) || [];
        message.base = object.base ?? "";
        message.display = object.display ?? "";
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        message.uri = object.uri ?? "";
        message.uriHash = object.uriHash ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js
var require_tx2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgSetSendEnabledResponse = exports.MsgSetSendEnabled = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports.MsgSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSend();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgSend();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports.MsgSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return {
        inputs: [],
        outputs: []
      };
    }
    exports.MsgMultiSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.inputs) {
          bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
          bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMultiSend();
        if (Array.isArray(object == null ? void 0 : object.inputs))
          obj.inputs = object.inputs.map((e) => bank_1.Input.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.outputs))
          obj.outputs = object.outputs.map((e) => bank_1.Output.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgMultiSend();
        message.inputs = ((_a2 = object.inputs) == null ? void 0 : _a2.map((e) => bank_1.Input.fromPartial(e))) || [];
        message.outputs = ((_b = object.outputs) == null ? void 0 : _b.map((e) => bank_1.Output.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports.MsgMultiSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgMultiSendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: bank_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgSetSendEnabled() {
      return {
        authority: "",
        sendEnabled: [],
        useDefaultFor: []
      };
    }
    exports.MsgSetSendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v of message.sendEnabled) {
          bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.useDefaultFor) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 3:
              message.useDefaultFor.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetSendEnabled();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object == null ? void 0 : object.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.useDefaultFor))
          obj.useDefaultFor = object.useDefaultFor.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        if (message.useDefaultFor) {
          obj.useDefaultFor = message.useDefaultFor.map((e) => e);
        } else {
          obj.useDefaultFor = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSetSendEnabled();
        message.authority = object.authority ?? "";
        message.sendEnabled = ((_a2 = object.sendEnabled) == null ? void 0 : _a2.map((e) => bank_1.SendEnabled.fromPartial(e))) || [];
        message.useDefaultFor = ((_b = object.useDefaultFor) == null ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgSetSendEnabledResponse() {
      return {};
    }
    exports.MsgSetSendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabledResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetSendEnabledResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetSendEnabledResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SetSendEnabled = this.SetSendEnabled.bind(this);
      }
      Send(request) {
        const data2 = exports.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data2);
        return promise.then((data3) => exports.MsgSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      MultiSend(request) {
        const data2 = exports.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data2);
        return promise.then((data3) => exports.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SetSendEnabled(request) {
        const data2 = exports.MsgSetSendEnabled.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data2);
        return promise.then((data3) => exports.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Registry = void 0;
    exports.isTelescopeGeneratedType = isTelescopeGeneratedType;
    exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
    exports.isPbjsGeneratedType = isPbjsGeneratedType;
    exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type) {
      const casted = type;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    var Registry = class {
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overridden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        __publicField(this, "types");
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        var _a2;
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(((_a2 = txBodyFields.timeoutHeight) == null ? void 0 : _a2.toString()) ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports.Registry = Registry;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOfflineDirectSigner = isOfflineDirectSigner;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.36.1/node_modules/@cosmjs/proto-signing/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCoins = exports.coins = exports.coin = exports.executeKdf = exports.makeSignDoc = exports.makeSignBytes = exports.makeAuthInfoBytes = exports.isOfflineDirectSigner = exports.Registry = exports.isTxBodyEncodeObject = exports.isTsProtoGeneratedType = exports.isPbjsGeneratedType = exports.encodePubkey = exports.decodePubkey = exports.decodeOptionalPubkey = exports.anyToSinglePubkey = exports.makeCosmoshubPath = exports.DirectSecp256k1Wallet = exports.extractKdfConfiguration = exports.DirectSecp256k1HdWallet = exports.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.ModuleCredential = exports.ModuleAccount = exports.BaseAccount = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseBaseAccount() {
      return {
        address: "",
        pubKey: void 0,
        accountNumber: BigInt(0),
        sequence: BigInt(0)
      };
    }
    exports.BaseAccount = {
      typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseAccount();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = any_1.Any.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseAccount();
        message.address = object.address ?? "";
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = any_1.Any.fromPartial(object.pubKey);
        }
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModuleAccount() {
      return {
        baseAccount: void 0,
        name: "",
        permissions: []
      };
    }
    exports.ModuleAccount = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          exports.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v of message.permissions) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = exports.BaseAccount.fromJSON(object.baseAccount);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if (Array.isArray(object == null ? void 0 : object.permissions))
          obj.permissions = object.permissions.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseModuleAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = exports.BaseAccount.fromPartial(object.baseAccount);
        }
        message.name = object.name ?? "";
        message.permissions = ((_a2 = object.permissions) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseModuleCredential() {
      return {
        moduleName: "",
        derivationKeys: []
      };
    }
    exports.ModuleCredential = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moduleName !== "") {
          writer.uint32(10).string(message.moduleName);
        }
        for (const v of message.derivationKeys) {
          writer.uint32(18).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleCredential();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moduleName = reader.string();
              break;
            case 2:
              message.derivationKeys.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleCredential();
        if ((0, helpers_1.isSet)(object.moduleName))
          obj.moduleName = String(object.moduleName);
        if (Array.isArray(object == null ? void 0 : object.derivationKeys))
          obj.derivationKeys = object.derivationKeys.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moduleName !== void 0 && (obj.moduleName = message.moduleName);
        if (message.derivationKeys) {
          obj.derivationKeys = message.derivationKeys.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.derivationKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseModuleCredential();
        message.moduleName = object.moduleName ?? "";
        message.derivationKeys = ((_a2 = object.derivationKeys) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxMemoCharacters: BigInt(0),
        txSigLimit: BigInt(0),
        txSizeCostPerByte: BigInt(0),
        sigVerifyCostEd25519: BigInt(0),
        sigVerifyCostSecp256k1: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.auth.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxMemoCharacters !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (message.txSigLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (message.txSizeCostPerByte !== BigInt(0)) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (message.sigVerifyCostEd25519 !== BigInt(0)) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (message.sigVerifyCostSecp256k1 !== BigInt(0)) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxMemoCharacters))
          obj.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if ((0, helpers_1.isSet)(object.txSigLimit))
          obj.txSigLimit = BigInt(object.txSigLimit.toString());
        if ((0, helpers_1.isSet)(object.txSizeCostPerByte))
          obj.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostEd25519))
          obj.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostSecp256k1))
          obj.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || BigInt(0)).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || BigInt(0)).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || BigInt(0)).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || BigInt(0)).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null) {
          message.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        }
        if (object.txSigLimit !== void 0 && object.txSigLimit !== null) {
          message.txSigLimit = BigInt(object.txSigLimit.toString());
        }
        if (object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null) {
          message.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        }
        if (object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null) {
          message.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        }
        if (object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null) {
          message.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PermanentLockedAccount = exports.PeriodicVestingAccount = exports.Period = exports.DelayedVestingAccount = exports.ContinuousVestingAccount = exports.BaseVestingAccount = exports.protobufPackage = void 0;
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseBaseVestingAccount() {
      return {
        baseAccount: void 0,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: BigInt(0)
      };
    }
    exports.BaseVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.originalVesting) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.delegatedFree) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.delegatedVesting) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseVestingAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = auth_1.BaseAccount.fromJSON(object.baseAccount);
        if (Array.isArray(object == null ? void 0 : object.originalVesting))
          obj.originalVesting = object.originalVesting.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.delegatedFree))
          obj.delegatedFree = object.delegatedFree.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.delegatedVesting))
          obj.delegatedVesting = object.delegatedVesting.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseBaseVestingAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = auth_1.BaseAccount.fromPartial(object.baseAccount);
        }
        message.originalVesting = ((_a2 = object.originalVesting) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedFree = ((_b = object.delegatedFree) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedVesting = ((_c = object.delegatedVesting) == null ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        return message;
      }
    };
    function createBaseContinuousVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0)
      };
    }
    exports.ContinuousVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContinuousVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContinuousVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        return message;
      }
    };
    function createBaseDelayedVestingAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports.DelayedVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelayedVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelayedVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
    function createBasePeriod() {
      return {
        length: BigInt(0),
        amount: []
      };
    }
    exports.Period = {
      typeUrl: "/cosmos.vesting.v1beta1.Period",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.length !== BigInt(0)) {
          writer.uint32(8).int64(message.length);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriod();
        if ((0, helpers_1.isSet)(object.length))
          obj.length = BigInt(object.length.toString());
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || BigInt(0)).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBasePeriod();
        if (object.length !== void 0 && object.length !== null) {
          message.length = BigInt(object.length.toString());
        }
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePeriodicVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports.PeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          exports.Period.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object == null ? void 0 : object.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => exports.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBasePeriodicVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = ((_a2 = object.vestingPeriods) == null ? void 0 : _a2.map((e) => exports.Period.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePermanentLockedAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports.PermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePermanentLockedAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountFromAny = accountFromAny;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        // auth
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        // vesting
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a2 = vesting_1.BaseVestingAccount.decode(value)) == null ? void 0 : _a2.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) == null ? void 0 : _b.baseVestingAccount) == null ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) == null ? void 0 : _d.baseVestingAccount) == null ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) == null ? void 0 : _f.baseVestingAccount) == null ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/aminotypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AminoTypes = void 0;
    var AminoTypes = class {
      constructor(types) {
        // The map type here ensures uniqueness of the protobuf type URL in the key.
        // There is no uniqueness guarantee of the Amino type identifier in the type
        // system or constructor. Instead it's the user's responsibility to ensure
        // there is no overlap when fromAmino is called.
        __publicField(this, "register");
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports.AminoTypes = AminoTypes;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTendermintEvent = fromTendermintEvent;
    var encoding_1 = require_build2();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/fee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GasPrice = void 0;
    exports.calculateFee = calculateFee;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class _GasPrice {
      constructor(amount, denom) {
        __publicField(this, "amount");
        __publicField(this, "denom");
        if (!denom) {
          throw new Error("denom must not be empty");
        }
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.53 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/logs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAttribute = parseAttribute;
    exports.parseEvent = parseEvent;
    exports.parseLog = parseLog;
    exports.parseLogs = parseLogs;
    exports.parseRawLog = parseRawLog;
    exports.findAttribute = findAttribute;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    function findAttribute(logs, eventType, attrKey) {
      var _a2;
      const firstLogs = logs.find(() => true);
      const out = (_a2 = firstLogs == null ? void 0 : firstLogs.events.find((event) => event.type === eventType)) == null ? void 0 : _a2.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js
var require_pagination = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageResponse = exports.PageRequest = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.query.v1beta1";
    function createBasePageRequest() {
      return {
        key: new Uint8Array(),
        offset: BigInt(0),
        limit: BigInt(0),
        countTotal: false,
        reverse: false
      };
    }
    exports.PageRequest = {
      typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.offset !== BigInt(0)) {
          writer.uint32(16).uint64(message.offset);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
          writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
          writer.uint32(40).bool(message.reverse);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.offset = reader.uint64();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.countTotal = reader.bool();
              break;
            case 5:
              message.reverse = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageRequest();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.offset))
          obj.offset = BigInt(object.offset.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.countTotal))
          obj.countTotal = Boolean(object.countTotal);
        if ((0, helpers_1.isSet)(object.reverse))
          obj.reverse = Boolean(object.reverse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.offset !== void 0 && (obj.offset = (message.offset || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
        message.reverse !== void 0 && (obj.reverse = message.reverse);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array();
        if (object.offset !== void 0 && object.offset !== null) {
          message.offset = BigInt(object.offset.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
      }
    };
    function createBasePageResponse() {
      return {
        nextKey: new Uint8Array(),
        total: BigInt(0)
      };
    }
    exports.PageResponse = {
      typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextKey.length !== 0) {
          writer.uint32(10).bytes(message.nextKey);
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(16).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextKey = reader.bytes();
              break;
            case 2:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageResponse();
        if ((0, helpers_1.isSet)(object.nextKey))
          obj.nextKey = (0, helpers_1.bytesFromBase64)(object.nextKey);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextKey !== void 0 && (obj.nextKey = (0, helpers_1.base64FromBytes)(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAccountInfoResponse = exports.QueryAccountInfoRequest = exports.QueryAccountAddressByIDResponse = exports.QueryAccountAddressByIDRequest = exports.AddressStringToBytesResponse = exports.AddressStringToBytesRequest = exports.AddressBytesToStringResponse = exports.AddressBytesToStringRequest = exports.Bech32PrefixResponse = exports.Bech32PrefixRequest = exports.QueryModuleAccountByNameResponse = exports.QueryModuleAccountByNameRequest = exports.QueryModuleAccountsResponse = exports.QueryModuleAccountsRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAccountResponse = exports.QueryAccountRequest = exports.QueryAccountsResponse = exports.QueryAccountsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var auth_1 = require_auth();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseQueryAccountsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountsResponse() {
      return {
        accounts: [],
        pagination: void 0
      };
    }
    exports.QueryAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsResponse();
        if (Array.isArray(object == null ? void 0 : object.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryAccountsResponse();
        message.accounts = ((_a2 = object.accounts) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountRequest() {
      return {
        address: ""
      };
    }
    exports.QueryAccountRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountResponse() {
      return {
        account: void 0
      };
    }
    exports.QueryAccountResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: auth_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = auth_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = auth_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryModuleAccountsRequest() {
      return {};
    }
    exports.QueryModuleAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryModuleAccountsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryModuleAccountsRequest();
        return message;
      }
    };
    function createBaseQueryModuleAccountsResponse() {
      return {
        accounts: []
      };
    }
    exports.QueryModuleAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountsResponse();
        if (Array.isArray(object == null ? void 0 : object.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryModuleAccountsResponse();
        message.accounts = ((_a2 = object.accounts) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameRequest() {
      return {
        name: ""
      };
    }
    exports.QueryModuleAccountByNameRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameRequest();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameRequest();
        message.name = object.name ?? "";
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameResponse() {
      return {
        account: void 0
      };
    }
    exports.QueryModuleAccountByNameResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseBech32PrefixRequest() {
      return {};
    }
    exports.Bech32PrefixRequest = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseBech32PrefixRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseBech32PrefixRequest();
        return message;
      }
    };
    function createBaseBech32PrefixResponse() {
      return {
        bech32Prefix: ""
      };
    }
    exports.Bech32PrefixResponse = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bech32Prefix !== "") {
          writer.uint32(10).string(message.bech32Prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bech32Prefix = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBech32PrefixResponse();
        if ((0, helpers_1.isSet)(object.bech32Prefix))
          obj.bech32Prefix = String(object.bech32Prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bech32Prefix !== void 0 && (obj.bech32Prefix = message.bech32Prefix);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBech32PrefixResponse();
        message.bech32Prefix = object.bech32Prefix ?? "";
        return message;
      }
    };
    function createBaseAddressBytesToStringRequest() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports.AddressBytesToStringRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringRequest();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringRequest();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAddressBytesToStringResponse() {
      return {
        addressString: ""
      };
    }
    exports.AddressBytesToStringResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringResponse();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringResponse();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesRequest() {
      return {
        addressString: ""
      };
    }
    exports.AddressStringToBytesRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesRequest();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesRequest();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesResponse() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports.AddressStringToBytesResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesResponse();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesResponse();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDRequest() {
      return {
        id: BigInt(0),
        accountId: BigInt(0)
      };
    }
    exports.QueryAccountAddressByIDRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).int64(message.id);
        }
        if (message.accountId !== BigInt(0)) {
          writer.uint32(16).uint64(message.accountId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.int64();
              break;
            case 2:
              message.accountId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDRequest();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.accountId))
          obj.accountId = BigInt(object.accountId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.accountId !== void 0 && (obj.accountId = (message.accountId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDRequest();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        if (object.accountId !== void 0 && object.accountId !== null) {
          message.accountId = BigInt(object.accountId.toString());
        }
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDResponse() {
      return {
        accountAddress: ""
      };
    }
    exports.QueryAccountAddressByIDResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.accountAddress !== "") {
          writer.uint32(10).string(message.accountAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accountAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDResponse();
        if ((0, helpers_1.isSet)(object.accountAddress))
          obj.accountAddress = String(object.accountAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.accountAddress !== void 0 && (obj.accountAddress = message.accountAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDResponse();
        message.accountAddress = object.accountAddress ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoRequest() {
      return {
        address: ""
      };
    }
    exports.QueryAccountInfoRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoResponse() {
      return {
        info: void 0
      };
    }
    exports.QueryAccountInfoResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.info !== void 0) {
          auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoResponse();
        if ((0, helpers_1.isSet)(object.info))
          obj.info = auth_1.BaseAccount.fromJSON(object.info);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.info !== void 0 && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoResponse();
        if (object.info !== void 0 && object.info !== null) {
          message.info = auth_1.BaseAccount.fromPartial(object.info);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.AccountAddressByID = this.AccountAddressByID.bind(this);
        this.Params = this.Params.bind(this);
        this.ModuleAccounts = this.ModuleAccounts.bind(this);
        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
        this.Bech32Prefix = this.Bech32Prefix.bind(this);
        this.AddressBytesToString = this.AddressBytesToString.bind(this);
        this.AddressStringToBytes = this.AddressStringToBytes.bind(this);
        this.AccountInfo = this.AccountInfo.bind(this);
      }
      Accounts(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data2);
        return promise.then((data3) => exports.QueryAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Account(request) {
        const data2 = exports.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data2);
        return promise.then((data3) => exports.QueryAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountAddressByID(request) {
        const data2 = exports.QueryAccountAddressByIDRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data2);
        return promise.then((data3) => exports.QueryAccountAddressByIDResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccounts(request = {}) {
        const data2 = exports.QueryModuleAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data2);
        return promise.then((data3) => exports.QueryModuleAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccountByName(request) {
        const data2 = exports.QueryModuleAccountByNameRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data2);
        return promise.then((data3) => exports.QueryModuleAccountByNameResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Bech32Prefix(request = {}) {
        const data2 = exports.Bech32PrefixRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", data2);
        return promise.then((data3) => exports.Bech32PrefixResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressBytesToString(request) {
        const data2 = exports.AddressBytesToStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", data2);
        return promise.then((data3) => exports.AddressBytesToStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressStringToBytes(request) {
        const data2 = exports.AddressStringToBytesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", data2);
        return promise.then((data3) => exports.AddressStringToBytesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountInfo(request) {
        const data2 = exports.QueryAccountInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data2);
        return promise.then((data3) => exports.QueryAccountInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClient = void 0;
    var utils_1 = require_build3();
    var QueryClient = class _QueryClient {
      constructor(cometClient) {
        __publicField(this, "cometClient");
        this.cometClient = cometClient;
      }
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAccAddress = toAccAddress;
    exports.createPagination = createPagination;
    exports.createProtobufRpcClient = createProtobufRpcClient;
    exports.longify = longify;
    exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data2) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data2, void 0);
          return response.value;
        }
      };
    }
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils5();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthExtension = setupAuthExtension;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAuthzAminoConverters = createAuthzAminoConverters;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Timestamp = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports.Timestamp = {
      typeUrl: "/google.protobuf.Timestamp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimestamp();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimestamp();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GrantQueueItem = exports.GrantAuthorization = exports.Grant = exports.GenericAuthorization = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return {
        msg: ""
      };
    }
    exports.GenericAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGenericAuthorization();
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = String(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGenericAuthorization();
        message.msg = object.msg ?? "";
        return message;
      }
    };
    function createBaseGrant() {
      return {
        authorization: void 0,
        expiration: void 0
      };
    }
    exports.Grant = {
      typeUrl: "/cosmos.authz.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantAuthorization() {
      return {
        granter: "",
        grantee: "",
        authorization: void 0,
        expiration: void 0
      };
    }
    exports.GrantAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantAuthorization();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantAuthorization();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantQueueItem() {
      return {
        msgTypeUrls: []
      };
    }
    exports.GrantQueueItem = {
      typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.msgTypeUrls) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantQueueItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgTypeUrls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantQueueItem();
        if (Array.isArray(object == null ? void 0 : object.msgTypeUrls))
          obj.msgTypeUrls = object.msgTypeUrls.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.msgTypeUrls) {
          obj.msgTypeUrls = message.msgTypeUrls.map((e) => e);
        } else {
          obj.msgTypeUrls = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseGrantQueueItem();
        message.msgTypeUrls = ((_a2 = object.msgTypeUrls) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgRevokeResponse = exports.MsgRevoke = exports.MsgExecResponse = exports.MsgExec = exports.MsgGrantResponse = exports.MsgGrant = exports.protobufPackage = void 0;
    var authz_1 = require_authz();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return {
        granter: "",
        grantee: "",
        grant: authz_1.Grant.fromPartial({})
      };
    }
    exports.MsgGrant = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.grant))
          obj.grant = authz_1.Grant.fromJSON(object.grant);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.grant !== void 0 && object.grant !== null) {
          message.grant = authz_1.Grant.fromPartial(object.grant);
        }
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports.MsgGrantResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        grantee: "",
        msgs: []
      };
    }
    exports.MsgExec = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v of message.msgs) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if (Array.isArray(object == null ? void 0 : object.msgs))
          obj.msgs = object.msgs.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgExec();
        message.grantee = object.grantee ?? "";
        message.msgs = ((_a2 = object.msgs) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        results: []
      };
    }
    exports.MsgExecResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.results) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if (Array.isArray(object == null ? void 0 : object.results))
          obj.results = object.results.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgExecResponse();
        message.results = ((_a2 = object.results) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: ""
      };
    }
    exports.MsgRevoke = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevoke();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevoke();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports.MsgRevokeResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
      }
      Grant(request) {
        const data2 = exports.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data2);
        return promise.then((data3) => exports.MsgGrantResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data2);
        return promise.then((data3) => exports.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Revoke(request) {
        const data2 = exports.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data2);
        return promise.then((data3) => exports.MsgRevokeResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js
var require_query2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryGranteeGrantsResponse = exports.QueryGranteeGrantsRequest = exports.QueryGranterGrantsResponse = exports.QueryGranterGrantsRequest = exports.QueryGrantsResponse = exports.QueryGrantsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var authz_1 = require_authz();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseQueryGrantsRequest() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: "",
        pagination: void 0
      };
    }
    exports.QueryGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.Grant.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryGrantsResponse();
        message.grants = ((_a2 = object.grants) == null ? void 0 : _a2.map((e) => authz_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports.QueryGranterGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGranterGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryGranterGrantsResponse();
        message.grants = ((_a2 = object.grants) == null ? void 0 : _a2.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports.QueryGranteeGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGranteeGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryGranteeGrantsResponse();
        message.grants = ((_a2 = object.grants) == null ? void 0 : _a2.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
      }
      Grants(request) {
        const data2 = exports.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data2);
        return promise.then((data3) => exports.QueryGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranterGrants(request) {
        const data2 = exports.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data2);
        return promise.then((data3) => exports.QueryGranterGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranteeGrants(request) {
        const data2 = exports.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data2);
        return promise.then((data3) => exports.QueryGranteeGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthzExtension = setupAuthzExtension;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSend = isAminoMsgSend;
    exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
    exports.createBankAminoConverters = createBankAminoConverters;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bankTypes = void 0;
    exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
    var tx_1 = require_tx2();
    exports.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js
var require_query3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QuerySendEnabledResponse = exports.QuerySendEnabledRequest = exports.QueryDenomOwnersByQueryResponse = exports.QueryDenomOwnersByQueryRequest = exports.QueryDenomOwnersResponse = exports.DenomOwner = exports.QueryDenomOwnersRequest = exports.QueryDenomMetadataByQueryStringResponse = exports.QueryDenomMetadataByQueryStringRequest = exports.QueryDenomMetadataResponse = exports.QueryDenomMetadataRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomsMetadataRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QuerySupplyOfResponse = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyResponse = exports.QueryTotalSupplyRequest = exports.QuerySpendableBalanceByDenomResponse = exports.QuerySpendableBalanceByDenomRequest = exports.QuerySpendableBalancesResponse = exports.QuerySpendableBalancesRequest = exports.QueryAllBalancesResponse = exports.QueryAllBalancesRequest = exports.QueryBalanceResponse = exports.QueryBalanceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseQueryBalanceRequest() {
      return {
        address: "",
        denom: ""
      };
    }
    exports.QueryBalanceRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryBalanceResponse() {
      return {
        balance: void 0
      };
    }
    exports.QueryBalanceResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceResponse();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceResponse();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryAllBalancesRequest() {
      return {
        address: "",
        pagination: void 0,
        resolveDenom: false
      };
    }
    exports.QueryAllBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.resolveDenom === true) {
          writer.uint32(24).bool(message.resolveDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.resolveDenom = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.resolveDenom))
          obj.resolveDenom = Boolean(object.resolveDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.resolveDenom !== void 0 && (obj.resolveDenom = message.resolveDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.resolveDenom = object.resolveDenom ?? false;
        return message;
      }
    };
    function createBaseQueryAllBalancesResponse() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports.QueryAllBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesResponse();
        if (Array.isArray(object == null ? void 0 : object.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryAllBalancesResponse();
        message.balances = ((_a2 = object.balances) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QuerySpendableBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesResponse() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports.QuerySpendableBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesResponse();
        if (Array.isArray(object == null ? void 0 : object.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQuerySpendableBalancesResponse();
        message.balances = ((_a2 = object.balances) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomRequest() {
      return {
        address: "",
        denom: ""
      };
    }
    exports.QuerySpendableBalanceByDenomRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomResponse() {
      return {
        balance: void 0
      };
    }
    exports.QuerySpendableBalanceByDenomResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomResponse();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryTotalSupplyRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyResponse() {
      return {
        supply: [],
        pagination: void 0
      };
    }
    exports.QueryTotalSupplyResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.supply) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyResponse();
        if (Array.isArray(object == null ? void 0 : object.supply))
          obj.supply = object.supply.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.supply) {
          obj.supply = message.supply.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.supply = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryTotalSupplyResponse();
        message.supply = ((_a2 = object.supply) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySupplyOfRequest() {
      return {
        denom: ""
      };
    }
    exports.QuerySupplyOfRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySupplyOfResponse() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.QuerySupplyOfResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfResponse();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfResponse();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: bank_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryDenomsMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataResponse() {
      return {
        metadatas: [],
        pagination: void 0
      };
    }
    exports.QueryDenomsMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.metadatas) {
          bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataResponse();
        if (Array.isArray(object == null ? void 0 : object.metadatas))
          obj.metadatas = object.metadatas.map((e) => bank_1.Metadata.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.metadatas) {
          obj.metadatas = message.metadatas.map((e) => e ? bank_1.Metadata.toJSON(e) : void 0);
        } else {
          obj.metadatas = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDenomsMetadataResponse();
        message.metadatas = ((_a2 = object.metadatas) == null ? void 0 : _a2.map((e) => bank_1.Metadata.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryDenomMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataResponse() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports.QueryDenomMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataResponse();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataResponse();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryDenomMetadataByQueryStringRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringResponse() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports.QueryDenomMetadataByQueryStringResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringResponse();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersRequest() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseDenomOwner() {
      return {
        address: "",
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports.DenomOwner = {
      typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomOwner();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomOwner();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomOwner();
        message.address = object.address ?? "";
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersResponse() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners) {
          exports.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersResponse();
        if (Array.isArray(object == null ? void 0 : object.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDenomOwnersResponse();
        message.denomOwners = ((_a2 = object.denomOwners) == null ? void 0 : _a2.map((e) => exports.DenomOwner.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryRequest() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersByQueryRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersByQueryRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryResponse() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersByQueryResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners) {
          exports.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryResponse();
        if (Array.isArray(object == null ? void 0 : object.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDenomOwnersByQueryResponse();
        message.denomOwners = ((_a2 = object.denomOwners) == null ? void 0 : _a2.map((e) => exports.DenomOwner.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledRequest() {
      return {
        denoms: [],
        pagination: void 0
      };
    }
    exports.QuerySendEnabledRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denoms) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denoms.push(reader.string());
              break;
            case 99:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledRequest();
        if (Array.isArray(object == null ? void 0 : object.denoms))
          obj.denoms = object.denoms.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denoms) {
          obj.denoms = message.denoms.map((e) => e);
        } else {
          obj.denoms = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQuerySendEnabledRequest();
        message.denoms = ((_a2 = object.denoms) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledResponse() {
      return {
        sendEnabled: [],
        pagination: void 0
      };
    }
    exports.QuerySendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled) {
          bank_1.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 99:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledResponse();
        if (Array.isArray(object == null ? void 0 : object.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQuerySendEnabledResponse();
        message.sendEnabled = ((_a2 = object.sendEnabled) == null ? void 0 : _a2.map((e) => bank_1.SendEnabled.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomMetadataByQueryString = this.DenomMetadataByQueryString.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
        this.DenomOwners = this.DenomOwners.bind(this);
        this.DenomOwnersByQuery = this.DenomOwnersByQuery.bind(this);
        this.SendEnabled = this.SendEnabled.bind(this);
      }
      Balance(request) {
        const data2 = exports.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data2);
        return promise.then((data3) => exports.QueryBalanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllBalances(request) {
        const data2 = exports.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data2);
        return promise.then((data3) => exports.QueryAllBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalances(request) {
        const data2 = exports.QuerySpendableBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data2);
        return promise.then((data3) => exports.QuerySpendableBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalanceByDenom(request) {
        const data2 = exports.QuerySpendableBalanceByDenomRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", data2);
        return promise.then((data3) => exports.QuerySpendableBalanceByDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalSupply(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data2);
        return promise.then((data3) => exports.QueryTotalSupplyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SupplyOf(request) {
        const data2 = exports.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data2);
        return promise.then((data3) => exports.QuerySupplyOfResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadata(request) {
        const data2 = exports.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data2);
        return promise.then((data3) => exports.QueryDenomMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadataByQueryString(request) {
        const data2 = exports.QueryDenomMetadataByQueryStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadataByQueryString", data2);
        return promise.then((data3) => exports.QueryDenomMetadataByQueryStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomsMetadata(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data2);
        return promise.then((data3) => exports.QueryDenomsMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwners(request) {
        const data2 = exports.QueryDenomOwnersRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", data2);
        return promise.then((data3) => exports.QueryDenomOwnersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwnersByQuery(request) {
        const data2 = exports.QueryDenomOwnersByQueryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwnersByQuery", data2);
        return promise.then((data3) => exports.QueryDenomOwnersByQueryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SendEnabled(request) {
        const data2 = exports.QuerySendEnabledRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", data2);
        return promise.then((data3) => exports.QuerySendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupBankExtension = setupBankExtension;
    var utils_1 = require_build3();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    exports.createCrysisAminoConverters = createCrysisAminoConverters;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    exports.createDistributionAminoConverters = createDistributionAminoConverters;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommunityPoolSpendProposalWithDeposit = exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.CommunityPoolSpendProposal = exports.FeePool = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.Params = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseParams() {
      return {
        communityTax: "",
        baseProposerReward: "",
        bonusProposerReward: "",
        withdrawAddrEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.distribution.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.communityTax))
          obj.communityTax = String(object.communityTax);
        if ((0, helpers_1.isSet)(object.baseProposerReward))
          obj.baseProposerReward = String(object.baseProposerReward);
        if ((0, helpers_1.isSet)(object.bonusProposerReward))
          obj.bonusProposerReward = String(object.bonusProposerReward);
        if ((0, helpers_1.isSet)(object.withdrawAddrEnabled))
          obj.withdrawAddrEnabled = Boolean(object.withdrawAddrEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
      }
    };
    function createBaseValidatorHistoricalRewards() {
      return {
        cumulativeRewardRatio: [],
        referenceCount: 0
      };
    }
    exports.ValidatorHistoricalRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorHistoricalRewards();
        if (Array.isArray(object == null ? void 0 : object.cumulativeRewardRatio))
          obj.cumulativeRewardRatio = object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.referenceCount))
          obj.referenceCount = Number(object.referenceCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = ((_a2 = object.cumulativeRewardRatio) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
      }
    };
    function createBaseValidatorCurrentRewards() {
      return {
        rewards: [],
        period: BigInt(0)
      };
    }
    exports.ValidatorCurrentRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== BigInt(0)) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorCurrentRewards();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.period))
          obj.period = BigInt(object.period.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorCurrentRewards();
        message.rewards = ((_a2 = object.rewards) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        if (object.period !== void 0 && object.period !== null) {
          message.period = BigInt(object.period.toString());
        }
        return message;
      }
    };
    function createBaseValidatorAccumulatedCommission() {
      return {
        commission: []
      };
    }
    exports.ValidatorAccumulatedCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorAccumulatedCommission();
        if (Array.isArray(object == null ? void 0 : object.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = ((_a2 = object.commission) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorOutstandingRewards() {
      return {
        rewards: []
      };
    }
    exports.ValidatorOutstandingRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorOutstandingRewards();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = ((_a2 = object.rewards) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorSlashEvent() {
      return {
        validatorPeriod: BigInt(0),
        fraction: ""
      };
    }
    exports.ValidatorSlashEvent = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvent();
        if ((0, helpers_1.isSet)(object.validatorPeriod))
          obj.validatorPeriod = BigInt(object.validatorPeriod.toString());
        if ((0, helpers_1.isSet)(object.fraction))
          obj.fraction = String(object.fraction);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || BigInt(0)).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvent();
        if (object.validatorPeriod !== void 0 && object.validatorPeriod !== null) {
          message.validatorPeriod = BigInt(object.validatorPeriod.toString());
        }
        message.fraction = object.fraction ?? "";
        return message;
      }
    };
    function createBaseValidatorSlashEvents() {
      return {
        validatorSlashEvents: []
      };
    }
    exports.ValidatorSlashEvents = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validatorSlashEvents) {
          exports.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvents();
        if (Array.isArray(object == null ? void 0 : object.validatorSlashEvents))
          obj.validatorSlashEvents = object.validatorSlashEvents.map((e) => exports.ValidatorSlashEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = ((_a2 = object.validatorSlashEvents) == null ? void 0 : _a2.map((e) => exports.ValidatorSlashEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFeePool() {
      return {
        communityPool: []
      };
    }
    exports.FeePool = {
      typeUrl: "/cosmos.distribution.v1beta1.FeePool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.communityPool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFeePool();
        if (Array.isArray(object == null ? void 0 : object.communityPool))
          obj.communityPool = object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseFeePool();
        message.communityPool = ((_a2 = object.communityPool) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposal() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: []
      };
    }
    exports.CommunityPoolSpendProposal = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegatorStartingInfo() {
      return {
        previousPeriod: BigInt(0),
        stake: "",
        height: BigInt(0)
      };
    }
    exports.DelegatorStartingInfo = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.previousPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegatorStartingInfo();
        if ((0, helpers_1.isSet)(object.previousPeriod))
          obj.previousPeriod = BigInt(object.previousPeriod.toString());
        if ((0, helpers_1.isSet)(object.stake))
          obj.stake = String(object.stake);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || BigInt(0)).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        if (object.previousPeriod !== void 0 && object.previousPeriod !== null) {
          message.previousPeriod = BigInt(object.previousPeriod.toString());
        }
        message.stake = object.stake ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseDelegationDelegatorReward() {
      return {
        validatorAddress: "",
        reward: []
      };
    }
    exports.DelegationDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationDelegatorReward();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object == null ? void 0 : object.reward))
          obj.reward = object.reward.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = ((_a2 = object.reward) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposalWithDeposit() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: "",
        deposit: ""
      };
    }
    exports.CommunityPoolSpendProposalWithDeposit = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposalWithDeposit();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = String(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgDepositValidatorRewardsPoolResponse = exports.MsgDepositValidatorRewardsPool = exports.MsgCommunityPoolSpendResponse = exports.MsgCommunityPoolSpend = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var distribution_1 = require_distribution();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return {
        delegatorAddress: "",
        withdrawAddress: ""
      };
    }
    exports.MsgSetWithdrawAddress = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetWithdrawAddress();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports.MsgSetWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetWithdrawAddressResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.MsgWithdrawDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorReward();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {
        amount: []
      };
    }
    exports.MsgWithdrawDelegatorRewardResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorRewardResponse();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return {
        validatorAddress: ""
      };
    }
    exports.MsgWithdrawValidatorCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommission();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {
        amount: []
      };
    }
    exports.MsgWithdrawValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommissionResponse();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return {
        amount: [],
        depositor: ""
      };
    }
    exports.MsgFundCommunityPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgFundCommunityPool();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgFundCommunityPool();
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports.MsgFundCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgFundCommunityPoolResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpend() {
      return {
        authority: "",
        recipient: "",
        amount: []
      };
    }
    exports.MsgCommunityPoolSpend = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.recipient !== "") {
          writer.uint32(18).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.recipient = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCommunityPoolSpend();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCommunityPoolSpend();
        message.authority = object.authority ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpendResponse() {
      return {};
    }
    exports.MsgCommunityPoolSpendResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCommunityPoolSpendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCommunityPoolSpendResponse();
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPool() {
      return {
        depositor: "",
        validatorAddress: "",
        amount: []
      };
    }
    exports.MsgDepositValidatorRewardsPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") {
          writer.uint32(10).string(message.depositor);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.depositor = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDepositValidatorRewardsPool();
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgDepositValidatorRewardsPool();
        message.depositor = object.depositor ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPoolResponse() {
      return {};
    }
    exports.MsgDepositValidatorRewardsPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositValidatorRewardsPoolResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
        this.DepositValidatorRewardsPool = this.DepositValidatorRewardsPool.bind(this);
      }
      SetWithdrawAddress(request) {
        const data2 = exports.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data2);
        return promise.then((data3) => exports.MsgSetWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawDelegatorReward(request) {
        const data2 = exports.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data2);
        return promise.then((data3) => exports.MsgWithdrawDelegatorRewardResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawValidatorCommission(request) {
        const data2 = exports.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data2);
        return promise.then((data3) => exports.MsgWithdrawValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      FundCommunityPool(request) {
        const data2 = exports.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data2);
        return promise.then((data3) => exports.MsgFundCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPoolSpend(request) {
        const data2 = exports.MsgCommunityPoolSpend.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data2);
        return promise.then((data3) => exports.MsgCommunityPoolSpendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DepositValidatorRewardsPool(request) {
        const data2 = exports.MsgDepositValidatorRewardsPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "DepositValidatorRewardsPool", data2);
        return promise.then((data3) => exports.MsgDepositValidatorRewardsPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distributionTypes = void 0;
    exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
    var tx_1 = require_tx4();
    exports.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryCommunityPoolResponse = exports.QueryCommunityPoolRequest = exports.QueryDelegatorWithdrawAddressResponse = exports.QueryDelegatorWithdrawAddressRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryDelegationTotalRewardsResponse = exports.QueryDelegationTotalRewardsRequest = exports.QueryDelegationRewardsResponse = exports.QueryDelegationRewardsRequest = exports.QueryValidatorSlashesResponse = exports.QueryValidatorSlashesRequest = exports.QueryValidatorCommissionResponse = exports.QueryValidatorCommissionRequest = exports.QueryValidatorOutstandingRewardsResponse = exports.QueryValidatorOutstandingRewardsRequest = exports.QueryValidatorDistributionInfoResponse = exports.QueryValidatorDistributionInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var distribution_1 = require_distribution();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorDistributionInfoRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoResponse() {
      return {
        operatorAddress: "",
        selfBondRewards: [],
        commission: []
      };
    }
    exports.QueryValidatorDistributionInfoResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        for (const v of message.selfBondRewards) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.selfBondRewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoResponse();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if (Array.isArray(object == null ? void 0 : object.selfBondRewards))
          obj.selfBondRewards = object.selfBondRewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        if (message.selfBondRewards) {
          obj.selfBondRewards = message.selfBondRewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.selfBondRewards = [];
        }
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        message.operatorAddress = object.operatorAddress ?? "";
        message.selfBondRewards = ((_a2 = object.selfBondRewards) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.commission = ((_b = object.commission) == null ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorOutstandingRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsResponse() {
      return {
        rewards: distribution_1.ValidatorOutstandingRewards.fromPartial({})
      };
    }
    exports.QueryValidatorOutstandingRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsResponse();
        if ((0, helpers_1.isSet)(object.rewards))
          obj.rewards = distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        if (object.rewards !== void 0 && object.rewards !== null) {
          message.rewards = distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards);
        }
        return message;
      }
    };
    function createBaseQueryValidatorCommissionRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorCommissionRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorCommissionResponse() {
      return {
        commission: distribution_1.ValidatorAccumulatedCommission.fromPartial({})
      };
    }
    exports.QueryValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionResponse();
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse();
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesRequest() {
      return {
        validatorAddress: "",
        startingHeight: BigInt(0),
        endingHeight: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryValidatorSlashesRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (message.startingHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (message.endingHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.startingHeight))
          obj.startingHeight = BigInt(object.startingHeight.toString());
        if ((0, helpers_1.isSet)(object.endingHeight))
          obj.endingHeight = BigInt(object.endingHeight.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || BigInt(0)).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.startingHeight !== void 0 && object.startingHeight !== null) {
          message.startingHeight = BigInt(object.startingHeight.toString());
        }
        if (object.endingHeight !== void 0 && object.endingHeight !== null) {
          message.endingHeight = BigInt(object.endingHeight.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesResponse() {
      return {
        slashes: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorSlashesResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesResponse();
        if (Array.isArray(object == null ? void 0 : object.slashes))
          obj.slashes = object.slashes.map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = ((_a2 = object.slashes) == null ? void 0 : _a2.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRewardsRequest() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.QueryDelegationRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationRewardsResponse() {
      return {
        rewards: []
      };
    }
    exports.QueryDelegationRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsResponse();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = ((_a2 = object.rewards) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegationTotalRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsResponse() {
      return {
        rewards: [],
        total: []
      };
    }
    exports.QueryDelegationTotalRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsResponse();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.total))
          obj.total = object.total.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = ((_a2 = object.rewards) == null ? void 0 : _a2.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e))) || [];
        message.total = ((_b = object.total) == null ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: []
      };
    }
    exports.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegatorWithdrawAddressRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressResponse() {
      return {
        withdrawAddress: ""
      };
    }
    exports.QueryDelegatorWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressResponse();
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseQueryCommunityPoolRequest() {
      return {};
    }
    exports.QueryCommunityPoolRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryCommunityPoolRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
      }
    };
    function createBaseQueryCommunityPoolResponse() {
      return {
        pool: []
      };
    }
    exports.QueryCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCommunityPoolResponse();
        if (Array.isArray(object == null ? void 0 : object.pool))
          obj.pool = object.pool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = ((_a2 = object.pool) == null ? void 0 : _a2.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDistributionInfo(request) {
        const data2 = exports.QueryValidatorDistributionInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", data2);
        return promise.then((data3) => exports.QueryValidatorDistributionInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorOutstandingRewards(request) {
        const data2 = exports.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data2);
        return promise.then((data3) => exports.QueryValidatorOutstandingRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorCommission(request) {
        const data2 = exports.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data2);
        return promise.then((data3) => exports.QueryValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorSlashes(request) {
        const data2 = exports.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data2);
        return promise.then((data3) => exports.QueryValidatorSlashesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationRewards(request) {
        const data2 = exports.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data2);
        return promise.then((data3) => exports.QueryDelegationRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationTotalRewards(request) {
        const data2 = exports.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data2);
        return promise.then((data3) => exports.QueryDelegationTotalRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorWithdrawAddress(request) {
        const data2 = exports.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data2);
        return promise.then((data3) => exports.QueryDelegatorWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPool(request = {}) {
        const data2 = exports.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data2);
        return promise.then((data3) => exports.QueryCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupDistributionExtension = setupDistributionExtension;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    exports.createEvidenceAminoConverters = createEvidenceAminoConverters;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFeegrantAminoConverters = createFeegrantAminoConverters;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js
var require_tx5 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgPruneAllowancesResponse = exports.MsgPruneAllowances = exports.MsgRevokeAllowanceResponse = exports.MsgRevokeAllowance = exports.MsgGrantAllowanceResponse = exports.MsgGrantAllowance = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseMsgGrantAllowance() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports.MsgGrantAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrantAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrantAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseMsgGrantAllowanceResponse() {
      return {};
    }
    exports.MsgGrantAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantAllowanceResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgRevokeAllowance() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports.MsgRevokeAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevokeAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevokeAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeAllowanceResponse() {
      return {};
    }
    exports.MsgRevokeAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeAllowanceResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgPruneAllowances() {
      return {
        pruner: ""
      };
    }
    exports.MsgPruneAllowances = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowances",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pruner !== "") {
          writer.uint32(10).string(message.pruner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowances();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pruner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAllowances();
        if ((0, helpers_1.isSet)(object.pruner))
          obj.pruner = String(object.pruner);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pruner !== void 0 && (obj.pruner = message.pruner);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAllowances();
        message.pruner = object.pruner ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAllowancesResponse() {
      return {};
    }
    exports.MsgPruneAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowancesResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgPruneAllowancesResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgPruneAllowancesResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
        this.PruneAllowances = this.PruneAllowances.bind(this);
      }
      GrantAllowance(request) {
        const data2 = exports.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data2);
        return promise.then((data3) => exports.MsgGrantAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RevokeAllowance(request) {
        const data2 = exports.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data2);
        return promise.then((data3) => exports.MsgRevokeAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAllowances(request) {
        const data2 = exports.MsgPruneAllowances.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "PruneAllowances", data2);
        return promise.then((data3) => exports.MsgPruneAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/duration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duration = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports.Duration = {
      typeUrl: "/google.protobuf.Duration",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuration();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuration();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js
var require_feegrant = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Grant = exports.AllowedMsgAllowance = exports.PeriodicAllowance = exports.BasicAllowance = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseBasicAllowance() {
      return {
        spendLimit: [],
        expiration: void 0
      };
    }
    exports.BasicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spendLimit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBasicAllowance();
        if (Array.isArray(object == null ? void 0 : object.spendLimit))
          obj.spendLimit = object.spendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseBasicAllowance();
        message.spendLimit = ((_a2 = object.spendLimit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBasePeriodicAllowance() {
      return {
        basic: exports.BasicAllowance.fromPartial({}),
        period: duration_1.Duration.fromPartial({}),
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.PeriodicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.basic !== void 0) {
          exports.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== void 0) {
          duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.periodSpendLimit) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.periodCanSpend) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.periodReset !== void 0) {
          timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.basic = exports.BasicAllowance.decode(reader, reader.uint32());
              break;
            case 2:
              message.period = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicAllowance();
        if ((0, helpers_1.isSet)(object.basic))
          obj.basic = exports.BasicAllowance.fromJSON(object.basic);
        if ((0, helpers_1.isSet)(object.period))
          obj.period = duration_1.Duration.fromJSON(object.period);
        if (Array.isArray(object == null ? void 0 : object.periodSpendLimit))
          obj.periodSpendLimit = object.periodSpendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.periodCanSpend))
          obj.periodCanSpend = object.periodCanSpend.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.periodReset))
          obj.periodReset = (0, helpers_1.fromJsonTimestamp)(object.periodReset);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.basic !== void 0 && (obj.basic = message.basic ? exports.BasicAllowance.toJSON(message.basic) : void 0);
        message.period !== void 0 && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : void 0);
        if (message.periodSpendLimit) {
          obj.periodSpendLimit = message.periodSpendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodSpendLimit = [];
        }
        if (message.periodCanSpend) {
          obj.periodCanSpend = message.periodCanSpend.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodCanSpend = [];
        }
        message.periodReset !== void 0 && (obj.periodReset = (0, helpers_1.fromTimestamp)(message.periodReset).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePeriodicAllowance();
        if (object.basic !== void 0 && object.basic !== null) {
          message.basic = exports.BasicAllowance.fromPartial(object.basic);
        }
        if (object.period !== void 0 && object.period !== null) {
          message.period = duration_1.Duration.fromPartial(object.period);
        }
        message.periodSpendLimit = ((_a2 = object.periodSpendLimit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.periodCanSpend = ((_b = object.periodCanSpend) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.periodReset !== void 0 && object.periodReset !== null) {
          message.periodReset = timestamp_1.Timestamp.fromPartial(object.periodReset);
        }
        return message;
      }
    };
    function createBaseAllowedMsgAllowance() {
      return {
        allowance: void 0,
        allowedMessages: []
      };
    }
    exports.AllowedMsgAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.allowedMessages) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowedMessages.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAllowedMsgAllowance();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        if (Array.isArray(object == null ? void 0 : object.allowedMessages))
          obj.allowedMessages = object.allowedMessages.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        if (message.allowedMessages) {
          obj.allowedMessages = message.allowedMessages.map((e) => e);
        } else {
          obj.allowedMessages = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseAllowedMsgAllowance();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        message.allowedMessages = ((_a2 = object.allowedMessages) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseGrant() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports.Grant = {
      typeUrl: "/cosmos.feegrant.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js
var require_query5 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAllowancesByGranterResponse = exports.QueryAllowancesByGranterRequest = exports.QueryAllowancesResponse = exports.QueryAllowancesRequest = exports.QueryAllowanceResponse = exports.QueryAllowanceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var feegrant_1 = require_feegrant();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseQueryAllowanceRequest() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports.QueryAllowanceRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseQueryAllowanceResponse() {
      return {
        allowance: void 0
      };
    }
    exports.QueryAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceResponse();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = feegrant_1.Grant.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceResponse();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = feegrant_1.Grant.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports.QueryAllowancesRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports.QueryAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesResponse();
        if (Array.isArray(object == null ? void 0 : object.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryAllowancesResponse();
        message.allowances = ((_a2 = object.allowances) == null ? void 0 : _a2.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports.QueryAllowancesByGranterRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports.QueryAllowancesByGranterResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterResponse();
        if (Array.isArray(object == null ? void 0 : object.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryAllowancesByGranterResponse();
        message.allowances = ((_a2 = object.allowances) == null ? void 0 : _a2.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
      }
      Allowance(request) {
        const data2 = exports.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data2);
        return promise.then((data3) => exports.QueryAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Allowances(request) {
        const data2 = exports.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data2);
        return promise.then((data3) => exports.QueryAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllowancesByGranter(request) {
        const data2 = exports.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data2);
        return promise.then((data3) => exports.QueryAllowancesByGranterResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupFeegrantExtension = setupFeegrantExtension;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports.TextProposal = {
      typeUrl: "/cosmos.gov.v1beta1.TextProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTextProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.Deposit = {
      typeUrl: "/cosmos.gov.v1beta1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: BigInt(0),
        content: void 0,
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        depositEndTime: timestamp_1.Timestamp.fromPartial({}),
        totalDeposit: [],
        votingStartTime: timestamp_1.Timestamp.fromPartial({}),
        votingEndTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.gov.v1beta1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object == null ? void 0 : object.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = ((_a2 = object.totalDeposit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yes: "",
        abstain: "",
        no: "",
        noWithVeto: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.gov.v1beta1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yes))
          obj.yes = String(object.yes);
        if ((0, helpers_1.isSet)(object.abstain))
          obj.abstain = String(object.abstain);
        if ((0, helpers_1.isSet)(object.no))
          obj.no = String(object.no);
        if ((0, helpers_1.isSet)(object.noWithVeto))
          obj.noWithVeto = String(object.noWithVeto);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        options: []
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.gov.v1beta1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => exports.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = ((_a2 = object.options) == null ? void 0 : _a2.map((e) => exports.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.DepositParams = {
      typeUrl: "/cosmos.gov.v1beta1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a2 = object.minDeposit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.VotingParams = {
      typeUrl: "/cosmos.gov.v1beta1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports.TallyParams = {
      typeUrl: "/cosmos.gov.v1beta1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = (0, helpers_1.bytesFromBase64)(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = (0, helpers_1.bytesFromBase64)(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = (0, helpers_1.bytesFromBase64)(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = (0, helpers_1.base64FromBytes)(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = (0, helpers_1.base64FromBytes)(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = (0, helpers_1.base64FromBytes)(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? new Uint8Array();
        message.threshold = object.threshold ?? new Uint8Array();
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    exports.isAminoMsgVote = isAminoMsgVote;
    exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    exports.isAminoMsgDeposit = isAminoMsgDeposit;
    exports.createGovAminoConverters = createGovAminoConverters;
    var math_1 = require_build();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/gov.js
var require_gov2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/gov.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.Deposit = {
      typeUrl: "/cosmos.gov.v1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        messages: [],
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0,
        metadata: "",
        title: "",
        summary: "",
        proposer: "",
        expedited: false,
        failedReason: ""
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.gov.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(82).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(90).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(98).string(message.summary);
        }
        if (message.proposer !== "") {
          writer.uint32(106).string(message.proposer);
        }
        if (message.expedited === true) {
          writer.uint32(112).bool(message.expedited);
        }
        if (message.failedReason !== "") {
          writer.uint32(122).string(message.failedReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.metadata = reader.string();
              break;
            case 11:
              message.title = reader.string();
              break;
            case 12:
              message.summary = reader.string();
              break;
            case 13:
              message.proposer = reader.string();
              break;
            case 14:
              message.expedited = reader.bool();
              break;
            case 15:
              message.failedReason = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object == null ? void 0 : object.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        if ((0, helpers_1.isSet)(object.failedReason))
          obj.failedReason = String(object.failedReason);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        message.failedReason !== void 0 && (obj.failedReason = message.failedReason);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.messages = ((_a2 = object.messages) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = ((_b = object.totalDeposit) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.proposer = object.proposer ?? "";
        message.expedited = object.expedited ?? false;
        message.failedReason = object.failedReason ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.gov.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.gov.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 5:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => exports.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a2 = object.options) == null ? void 0 : _a2.map((e) => exports.WeightedVoteOption.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0
      };
    }
    exports.DepositParams = {
      typeUrl: "/cosmos.gov.v1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a2 = object.minDeposit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: void 0
      };
    }
    exports.VotingParams = {
      typeUrl: "/cosmos.gov.v1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: "",
        threshold: "",
        vetoThreshold: ""
      };
    }
    exports.TallyParams = {
      typeUrl: "/cosmos.gov.v1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum !== "") {
          writer.uint32(10).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(18).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(26).string(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.string();
              break;
            case 2:
              message.threshold = reader.string();
              break;
            case 3:
              message.vetoThreshold = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0,
        votingPeriod: void 0,
        quorum: "",
        threshold: "",
        vetoThreshold: "",
        minInitialDepositRatio: "",
        proposalCancelRatio: "",
        proposalCancelDest: "",
        expeditedVotingPeriod: void 0,
        expeditedThreshold: "",
        expeditedMinDeposit: [],
        burnVoteQuorum: false,
        burnProposalDepositPrevote: false,
        burnVoteVeto: false,
        minDepositRatio: ""
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.gov.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.quorum !== "") {
          writer.uint32(34).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(42).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(50).string(message.vetoThreshold);
        }
        if (message.minInitialDepositRatio !== "") {
          writer.uint32(58).string(message.minInitialDepositRatio);
        }
        if (message.proposalCancelRatio !== "") {
          writer.uint32(66).string(message.proposalCancelRatio);
        }
        if (message.proposalCancelDest !== "") {
          writer.uint32(74).string(message.proposalCancelDest);
        }
        if (message.expeditedVotingPeriod !== void 0) {
          duration_1.Duration.encode(message.expeditedVotingPeriod, writer.uint32(82).fork()).ldelim();
        }
        if (message.expeditedThreshold !== "") {
          writer.uint32(90).string(message.expeditedThreshold);
        }
        for (const v of message.expeditedMinDeposit) {
          coin_1.Coin.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.burnVoteQuorum === true) {
          writer.uint32(104).bool(message.burnVoteQuorum);
        }
        if (message.burnProposalDepositPrevote === true) {
          writer.uint32(112).bool(message.burnProposalDepositPrevote);
        }
        if (message.burnVoteVeto === true) {
          writer.uint32(120).bool(message.burnVoteVeto);
        }
        if (message.minDepositRatio !== "") {
          writer.uint32(130).string(message.minDepositRatio);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.quorum = reader.string();
              break;
            case 5:
              message.threshold = reader.string();
              break;
            case 6:
              message.vetoThreshold = reader.string();
              break;
            case 7:
              message.minInitialDepositRatio = reader.string();
              break;
            case 8:
              message.proposalCancelRatio = reader.string();
              break;
            case 9:
              message.proposalCancelDest = reader.string();
              break;
            case 10:
              message.expeditedVotingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 11:
              message.expeditedThreshold = reader.string();
              break;
            case 12:
              message.expeditedMinDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 13:
              message.burnVoteQuorum = reader.bool();
              break;
            case 14:
              message.burnProposalDepositPrevote = reader.bool();
              break;
            case 15:
              message.burnVoteVeto = reader.bool();
              break;
            case 16:
              message.minDepositRatio = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        if ((0, helpers_1.isSet)(object.minInitialDepositRatio))
          obj.minInitialDepositRatio = String(object.minInitialDepositRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelRatio))
          obj.proposalCancelRatio = String(object.proposalCancelRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelDest))
          obj.proposalCancelDest = String(object.proposalCancelDest);
        if ((0, helpers_1.isSet)(object.expeditedVotingPeriod))
          obj.expeditedVotingPeriod = duration_1.Duration.fromJSON(object.expeditedVotingPeriod);
        if ((0, helpers_1.isSet)(object.expeditedThreshold))
          obj.expeditedThreshold = String(object.expeditedThreshold);
        if (Array.isArray(object == null ? void 0 : object.expeditedMinDeposit))
          obj.expeditedMinDeposit = object.expeditedMinDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.burnVoteQuorum))
          obj.burnVoteQuorum = Boolean(object.burnVoteQuorum);
        if ((0, helpers_1.isSet)(object.burnProposalDepositPrevote))
          obj.burnProposalDepositPrevote = Boolean(object.burnProposalDepositPrevote);
        if ((0, helpers_1.isSet)(object.burnVoteVeto))
          obj.burnVoteVeto = Boolean(object.burnVoteVeto);
        if ((0, helpers_1.isSet)(object.minDepositRatio))
          obj.minDepositRatio = String(object.minDepositRatio);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        message.minInitialDepositRatio !== void 0 && (obj.minInitialDepositRatio = message.minInitialDepositRatio);
        message.proposalCancelRatio !== void 0 && (obj.proposalCancelRatio = message.proposalCancelRatio);
        message.proposalCancelDest !== void 0 && (obj.proposalCancelDest = message.proposalCancelDest);
        message.expeditedVotingPeriod !== void 0 && (obj.expeditedVotingPeriod = message.expeditedVotingPeriod ? duration_1.Duration.toJSON(message.expeditedVotingPeriod) : void 0);
        message.expeditedThreshold !== void 0 && (obj.expeditedThreshold = message.expeditedThreshold);
        if (message.expeditedMinDeposit) {
          obj.expeditedMinDeposit = message.expeditedMinDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.expeditedMinDeposit = [];
        }
        message.burnVoteQuorum !== void 0 && (obj.burnVoteQuorum = message.burnVoteQuorum);
        message.burnProposalDepositPrevote !== void 0 && (obj.burnProposalDepositPrevote = message.burnProposalDepositPrevote);
        message.burnVoteVeto !== void 0 && (obj.burnVoteVeto = message.burnVoteVeto);
        message.minDepositRatio !== void 0 && (obj.minDepositRatio = message.minDepositRatio);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseParams();
        message.minDeposit = ((_a2 = object.minDeposit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        message.minInitialDepositRatio = object.minInitialDepositRatio ?? "";
        message.proposalCancelRatio = object.proposalCancelRatio ?? "";
        message.proposalCancelDest = object.proposalCancelDest ?? "";
        if (object.expeditedVotingPeriod !== void 0 && object.expeditedVotingPeriod !== null) {
          message.expeditedVotingPeriod = duration_1.Duration.fromPartial(object.expeditedVotingPeriod);
        }
        message.expeditedThreshold = object.expeditedThreshold ?? "";
        message.expeditedMinDeposit = ((_b = object.expeditedMinDeposit) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.burnVoteQuorum = object.burnVoteQuorum ?? false;
        message.burnProposalDepositPrevote = object.burnProposalDepositPrevote ?? false;
        message.burnVoteVeto = object.burnVoteVeto ?? false;
        message.minDepositRatio = object.minDepositRatio ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/tx.js
var require_tx6 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgCancelProposalResponse = exports.MsgCancelProposal = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgExecLegacyContentResponse = exports.MsgExecLegacyContent = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov2();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1";
    function createBaseMsgSubmitProposal() {
      return {
        messages: [],
        initialDeposit: [],
        proposer: "",
        metadata: "",
        title: "",
        summary: "",
        expedited: false
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(42).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(50).string(message.summary);
        }
        if (message.expedited === true) {
          writer.uint32(56).bool(message.expedited);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.title = reader.string();
              break;
            case 6:
              message.summary = reader.string();
              break;
            case 7:
              message.expedited = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSubmitProposal();
        message.messages = ((_a2 = object.messages) == null ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        message.initialDeposit = ((_b = object.initialDeposit) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = object.proposer ?? "";
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.expedited = object.expedited ?? false;
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgExecLegacyContent() {
      return {
        content: void 0,
        authority: ""
      };
    }
    exports.MsgExecLegacyContent = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        if (message.authority !== "") {
          writer.uint32(18).string(message.authority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.authority = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecLegacyContent();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.authority !== void 0 && (obj.authority = message.authority);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecLegacyContent();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.authority = object.authority ?? "";
        return message;
      }
    };
    function createBaseMsgExecLegacyContentResponse() {
      return {};
    }
    exports.MsgExecLegacyContentResponse = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgExecLegacyContentResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgExecLegacyContentResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: ""
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.gov.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a2 = object.options) == null ? void 0 : _a2.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: gov_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          gov_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = gov_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = gov_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? gov_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = gov_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgCancelProposal() {
      return {
        proposalId: BigInt(0),
        proposer: ""
      };
    }
    exports.MsgCancelProposal = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.proposer !== "") {
          writer.uint32(18).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgCancelProposalResponse() {
      return {
        proposalId: BigInt(0),
        canceledTime: timestamp_1.Timestamp.fromPartial({}),
        canceledHeight: BigInt(0)
      };
    }
    exports.MsgCancelProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.canceledTime !== void 0) {
          timestamp_1.Timestamp.encode(message.canceledTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.canceledHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.canceledHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.canceledTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.canceledHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.canceledTime))
          obj.canceledTime = (0, helpers_1.fromJsonTimestamp)(object.canceledTime);
        if ((0, helpers_1.isSet)(object.canceledHeight))
          obj.canceledHeight = BigInt(object.canceledHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.canceledTime !== void 0 && (obj.canceledTime = (0, helpers_1.fromTimestamp)(message.canceledTime).toISOString());
        message.canceledHeight !== void 0 && (obj.canceledHeight = (message.canceledHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.canceledTime !== void 0 && object.canceledTime !== null) {
          message.canceledTime = timestamp_1.Timestamp.fromPartial(object.canceledTime);
        }
        if (object.canceledHeight !== void 0 && object.canceledHeight !== null) {
          message.canceledHeight = BigInt(object.canceledHeight.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.ExecLegacyContent = this.ExecLegacyContent.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CancelProposal = this.CancelProposal.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ExecLegacyContent(request) {
        const data2 = exports.MsgExecLegacyContent.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", data2);
        return promise.then((data3) => exports.MsgExecLegacyContentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Deposit", data2);
        return promise.then((data3) => exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelProposal(request) {
        const data2 = exports.MsgCancelProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "CancelProposal", data2);
        return promise.then((data3) => exports.MsgCancelProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx7 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return {
        content: void 0,
        initialDeposit: [],
        proposer: ""
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if (Array.isArray(object == null ? void 0 : object.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgSubmitProposal();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.initialDeposit = ((_a2 = object.initialDeposit) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: []
      };
    }
    exports.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a2 = object.options) == null ? void 0 : _a2.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data2);
        return promise.then((data3) => exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.govTypes = void 0;
    exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query6 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryTallyResultResponse = exports.QueryTallyResultRequest = exports.QueryDepositsResponse = exports.QueryDepositsRequest = exports.QueryDepositResponse = exports.QueryDepositRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryVotesResponse = exports.QueryVotesRequest = exports.QueryVoteResponse = exports.QueryVoteRequest = exports.QueryProposalsResponse = exports.QueryProposalsRequest = exports.QueryProposalResponse = exports.QueryProposalRequest = exports.protobufPackage = void 0;
    var gov_1 = require_gov();
    var pagination_1 = require_pagination();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseQueryProposalRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.QueryProposalRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryProposalResponse() {
      return {
        proposal: gov_1.Proposal.fromPartial({})
      };
    }
    exports.QueryProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalResponse();
        if ((0, helpers_1.isSet)(object.proposal))
          obj.proposal = gov_1.Proposal.fromJSON(object.proposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalResponse();
        if (object.proposal !== void 0 && object.proposal !== null) {
          message.proposal = gov_1.Proposal.fromPartial(object.proposal);
        }
        return message;
      }
    };
    function createBaseQueryProposalsRequest() {
      return {
        proposalStatus: 0,
        voter: "",
        depositor: "",
        pagination: void 0
      };
    }
    exports.QueryProposalsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsRequest();
        if ((0, helpers_1.isSet)(object.proposalStatus))
          obj.proposalStatus = (0, gov_1.proposalStatusFromJSON)(object.proposalStatus);
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryProposalsResponse() {
      return {
        proposals: [],
        pagination: void 0
      };
    }
    exports.QueryProposalsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proposals) {
          gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsResponse();
        if (Array.isArray(object == null ? void 0 : object.proposals))
          obj.proposals = object.proposals.map((e) => gov_1.Proposal.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryProposalsResponse();
        message.proposals = ((_a2 = object.proposals) == null ? void 0 : _a2.map((e) => gov_1.Proposal.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVoteRequest() {
      return {
        proposalId: BigInt(0),
        voter: ""
      };
    }
    exports.QueryVoteRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        return message;
      }
    };
    function createBaseQueryVoteResponse() {
      return {
        vote: gov_1.Vote.fromPartial({})
      };
    }
    exports.QueryVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteResponse();
        if ((0, helpers_1.isSet)(object.vote))
          obj.vote = gov_1.Vote.fromJSON(object.vote);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteResponse();
        if (object.vote !== void 0 && object.vote !== null) {
          message.vote = gov_1.Vote.fromPartial(object.vote);
        }
        return message;
      }
    };
    function createBaseQueryVotesRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryVotesRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVotesResponse() {
      return {
        votes: [],
        pagination: void 0
      };
    }
    exports.QueryVotesResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.votes) {
          gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesResponse();
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => gov_1.Vote.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryVotesResponse();
        message.votes = ((_a2 = object.votes) == null ? void 0 : _a2.map((e) => gov_1.Vote.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {
        paramsType: ""
      };
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsRequest();
        if ((0, helpers_1.isSet)(object.paramsType))
          obj.paramsType = String(object.paramsType);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsRequest();
        message.paramsType = object.paramsType ?? "";
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        votingParams: gov_1.VotingParams.fromPartial({}),
        depositParams: gov_1.DepositParams.fromPartial({}),
        tallyParams: gov_1.TallyParams.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.votingParams))
          obj.votingParams = gov_1.VotingParams.fromJSON(object.votingParams);
        if ((0, helpers_1.isSet)(object.depositParams))
          obj.depositParams = gov_1.DepositParams.fromJSON(object.depositParams);
        if ((0, helpers_1.isSet)(object.tallyParams))
          obj.tallyParams = gov_1.TallyParams.fromJSON(object.tallyParams);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.votingParams !== void 0 && object.votingParams !== null) {
          message.votingParams = gov_1.VotingParams.fromPartial(object.votingParams);
        }
        if (object.depositParams !== void 0 && object.depositParams !== null) {
          message.depositParams = gov_1.DepositParams.fromPartial(object.depositParams);
        }
        if (object.tallyParams !== void 0 && object.tallyParams !== null) {
          message.tallyParams = gov_1.TallyParams.fromPartial(object.tallyParams);
        }
        return message;
      }
    };
    function createBaseQueryDepositRequest() {
      return {
        proposalId: BigInt(0),
        depositor: ""
      };
    }
    exports.QueryDepositRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseQueryDepositResponse() {
      return {
        deposit: gov_1.Deposit.fromPartial({})
      };
    }
    exports.QueryDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositResponse();
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = gov_1.Deposit.fromJSON(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositResponse();
        if (object.deposit !== void 0 && object.deposit !== null) {
          message.deposit = gov_1.Deposit.fromPartial(object.deposit);
        }
        return message;
      }
    };
    function createBaseQueryDepositsRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryDepositsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDepositsResponse() {
      return {
        deposits: [],
        pagination: void 0
      };
    }
    exports.QueryDepositsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.deposits) {
          gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsResponse();
        if (Array.isArray(object == null ? void 0 : object.deposits))
          obj.deposits = object.deposits.map((e) => gov_1.Deposit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDepositsResponse();
        message.deposits = ((_a2 = object.deposits) == null ? void 0 : _a2.map((e) => gov_1.Deposit.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTallyResultRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.QueryTallyResultRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryTallyResultResponse() {
      return {
        tally: gov_1.TallyResult.fromPartial({})
      };
    }
    exports.QueryTallyResultResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultResponse();
        if ((0, helpers_1.isSet)(object.tally))
          obj.tally = gov_1.TallyResult.fromJSON(object.tally);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultResponse();
        if (object.tally !== void 0 && object.tally !== null) {
          message.tally = gov_1.TallyResult.fromPartial(object.tally);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data2 = exports.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data2);
        return promise.then((data3) => exports.QueryProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Proposals(request) {
        const data2 = exports.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data2);
        return promise.then((data3) => exports.QueryProposalsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data2);
        return promise.then((data3) => exports.QueryVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Votes(request) {
        const data2 = exports.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data2);
        return promise.then((data3) => exports.QueryVotesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data2);
        return promise.then((data3) => exports.QueryDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposits(request) {
        const data2 = exports.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data2);
        return promise.then((data3) => exports.QueryDepositsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TallyResult(request) {
        const data2 = exports.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data2);
        return promise.then((data3) => exports.QueryTallyResultResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGovExtension = setupGovExtension;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupAminoConverters = createGroupAminoConverters;
    function createGroupAminoConverters() {
      return {};
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vote = exports.TallyResult = exports.Proposal = exports.GroupPolicyInfo = exports.GroupMember = exports.GroupInfo = exports.DecisionPolicyWindows = exports.PercentageDecisionPolicy = exports.ThresholdDecisionPolicy = exports.MemberRequest = exports.Member = exports.proposalExecutorResultToJSON = exports.proposalExecutorResultFromJSON = exports.ProposalExecutorResult = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.group.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_SUBMITTED"] = 1] = "PROPOSAL_STATUS_SUBMITTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ACCEPTED"] = 2] = "PROPOSAL_STATUS_ACCEPTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 3] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ABORTED"] = 4] = "PROPOSAL_STATUS_ABORTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_WITHDRAWN"] = 5] = "PROPOSAL_STATUS_WITHDRAWN";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_SUBMITTED":
          return ProposalStatus.PROPOSAL_STATUS_SUBMITTED;
        case 2:
        case "PROPOSAL_STATUS_ACCEPTED":
          return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
        case 3:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 4:
        case "PROPOSAL_STATUS_ABORTED":
          return ProposalStatus.PROPOSAL_STATUS_ABORTED;
        case 5:
        case "PROPOSAL_STATUS_WITHDRAWN":
          return ProposalStatus.PROPOSAL_STATUS_WITHDRAWN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_SUBMITTED:
          return "PROPOSAL_STATUS_SUBMITTED";
        case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
          return "PROPOSAL_STATUS_ACCEPTED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_ABORTED:
          return "PROPOSAL_STATUS_ABORTED";
        case ProposalStatus.PROPOSAL_STATUS_WITHDRAWN:
          return "PROPOSAL_STATUS_WITHDRAWN";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    var ProposalExecutorResult;
    (function(ProposalExecutorResult2) {
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"] = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      ProposalExecutorResult2[ProposalExecutorResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalExecutorResult || (exports.ProposalExecutorResult = ProposalExecutorResult = {}));
    function proposalExecutorResultFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
        case 1:
        case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
        case 2:
        case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
        case 3:
        case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalExecutorResult.UNRECOGNIZED;
      }
    }
    exports.proposalExecutorResultFromJSON = proposalExecutorResultFromJSON;
    function proposalExecutorResultToJSON(object) {
      switch (object) {
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
          return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
          return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
          return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE:
          return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
        case ProposalExecutorResult.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalExecutorResultToJSON = proposalExecutorResultToJSON;
    function createBaseMember() {
      return {
        address: "",
        weight: "",
        metadata: "",
        addedAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Member = {
      typeUrl: "/cosmos.group.v1.Member",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.addedAt !== void 0) {
          timestamp_1.Timestamp.encode(message.addedAt, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.addedAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMember();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.addedAt))
          obj.addedAt = (0, helpers_1.fromJsonTimestamp)(object.addedAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.addedAt !== void 0 && (obj.addedAt = (0, helpers_1.fromTimestamp)(message.addedAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMember();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        if (object.addedAt !== void 0 && object.addedAt !== null) {
          message.addedAt = timestamp_1.Timestamp.fromPartial(object.addedAt);
        }
        return message;
      }
    };
    function createBaseMemberRequest() {
      return {
        address: "",
        weight: "",
        metadata: ""
      };
    }
    exports.MemberRequest = {
      typeUrl: "/cosmos.group.v1.MemberRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMemberRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMemberRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMemberRequest();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseThresholdDecisionPolicy() {
      return {
        threshold: "",
        windows: void 0
      };
    }
    exports.ThresholdDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== "") {
          writer.uint32(10).string(message.threshold);
        }
        if (message.windows !== void 0) {
          exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseThresholdDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.string();
              break;
            case 2:
              message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseThresholdDecisionPolicy();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.windows !== void 0 && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseThresholdDecisionPolicy();
        message.threshold = object.threshold ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBasePercentageDecisionPolicy() {
      return {
        percentage: "",
        windows: void 0
      };
    }
    exports.PercentageDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.percentage !== "") {
          writer.uint32(10).string(message.percentage);
        }
        if (message.windows !== void 0) {
          exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePercentageDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.percentage = reader.string();
              break;
            case 2:
              message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePercentageDecisionPolicy();
        if ((0, helpers_1.isSet)(object.percentage))
          obj.percentage = String(object.percentage);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.percentage !== void 0 && (obj.percentage = message.percentage);
        message.windows !== void 0 && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePercentageDecisionPolicy();
        message.percentage = object.percentage ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBaseDecisionPolicyWindows() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({}),
        minExecutionPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.DecisionPolicyWindows = {
      typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        if (message.minExecutionPeriod !== void 0) {
          duration_1.Duration.encode(message.minExecutionPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecisionPolicyWindows();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.minExecutionPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecisionPolicyWindows();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.minExecutionPeriod))
          obj.minExecutionPeriod = duration_1.Duration.fromJSON(object.minExecutionPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.minExecutionPeriod !== void 0 && (obj.minExecutionPeriod = message.minExecutionPeriod ? duration_1.Duration.toJSON(message.minExecutionPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecisionPolicyWindows();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        if (object.minExecutionPeriod !== void 0 && object.minExecutionPeriod !== null) {
          message.minExecutionPeriod = duration_1.Duration.fromPartial(object.minExecutionPeriod);
        }
        return message;
      }
    };
    function createBaseGroupInfo() {
      return {
        id: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        totalWeight: "",
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.GroupInfo = {
      typeUrl: "/cosmos.group.v1.GroupInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(32).uint64(message.version);
        }
        if (message.totalWeight !== "") {
          writer.uint32(42).string(message.totalWeight);
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.version = reader.uint64();
              break;
            case 5:
              message.totalWeight = reader.string();
              break;
            case 6:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupInfo();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.totalWeight))
          obj.totalWeight = String(object.totalWeight);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.totalWeight !== void 0 && (obj.totalWeight = message.totalWeight);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupInfo();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        message.totalWeight = object.totalWeight ?? "";
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseGroupMember() {
      return {
        groupId: BigInt(0),
        member: void 0
      };
    }
    exports.GroupMember = {
      typeUrl: "/cosmos.group.v1.GroupMember",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.member !== void 0) {
          exports.Member.encode(message.member, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.member = exports.Member.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupMember();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.member))
          obj.member = exports.Member.fromJSON(object.member);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.member !== void 0 && (obj.member = message.member ? exports.Member.toJSON(message.member) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupMember();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        if (object.member !== void 0 && object.member !== null) {
          message.member = exports.Member.fromPartial(object.member);
        }
        return message;
      }
    };
    function createBaseGroupPolicyInfo() {
      return {
        address: "",
        groupId: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        decisionPolicy: void 0,
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.GroupPolicyInfo = {
      typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(40).uint64(message.version);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupPolicyInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.version = reader.uint64();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupPolicyInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupPolicyInfo();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        groupPolicyAddress: "",
        metadata: "",
        proposers: [],
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        groupVersion: BigInt(0),
        groupPolicyVersion: BigInt(0),
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        votingPeriodEnd: timestamp_1.Timestamp.fromPartial({}),
        executorResult: 0,
        messages: [],
        title: "",
        summary: ""
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.group.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.proposers) {
          writer.uint32(34).string(v);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.groupVersion !== BigInt(0)) {
          writer.uint32(48).uint64(message.groupVersion);
        }
        if (message.groupPolicyVersion !== BigInt(0)) {
          writer.uint32(56).uint64(message.groupPolicyVersion);
        }
        if (message.status !== 0) {
          writer.uint32(64).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(74).fork()).ldelim();
        }
        if (message.votingPeriodEnd !== void 0) {
          timestamp_1.Timestamp.encode(message.votingPeriodEnd, writer.uint32(82).fork()).ldelim();
        }
        if (message.executorResult !== 0) {
          writer.uint32(88).int32(message.executorResult);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== "") {
          writer.uint32(106).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(114).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.proposers.push(reader.string());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.groupVersion = reader.uint64();
              break;
            case 7:
              message.groupPolicyVersion = reader.uint64();
              break;
            case 8:
              message.status = reader.int32();
              break;
            case 9:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 10:
              message.votingPeriodEnd = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.executorResult = reader.int32();
              break;
            case 12:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 13:
              message.title = reader.string();
              break;
            case 14:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object == null ? void 0 : object.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.groupVersion))
          obj.groupVersion = BigInt(object.groupVersion.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyVersion))
          obj.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.votingPeriodEnd))
          obj.votingPeriodEnd = (0, helpers_1.fromJsonTimestamp)(object.votingPeriodEnd);
        if ((0, helpers_1.isSet)(object.executorResult))
          obj.executorResult = proposalExecutorResultFromJSON(object.executorResult);
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.groupVersion !== void 0 && (obj.groupVersion = (message.groupVersion || BigInt(0)).toString());
        message.groupPolicyVersion !== void 0 && (obj.groupPolicyVersion = (message.groupPolicyVersion || BigInt(0)).toString());
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.votingPeriodEnd !== void 0 && (obj.votingPeriodEnd = (0, helpers_1.fromTimestamp)(message.votingPeriodEnd).toISOString());
        message.executorResult !== void 0 && (obj.executorResult = proposalExecutorResultToJSON(message.executorResult));
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        message.proposers = ((_a2 = object.proposers) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.groupVersion !== void 0 && object.groupVersion !== null) {
          message.groupVersion = BigInt(object.groupVersion.toString());
        }
        if (object.groupPolicyVersion !== void 0 && object.groupPolicyVersion !== null) {
          message.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.votingPeriodEnd !== void 0 && object.votingPeriodEnd !== null) {
          message.votingPeriodEnd = timestamp_1.Timestamp.fromPartial(object.votingPeriodEnd);
        }
        message.executorResult = object.executorResult ?? 0;
        message.messages = ((_b = object.messages) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.group.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        submitTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.group.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/tx.js
var require_tx8 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgLeaveGroupResponse = exports.MsgLeaveGroup = exports.MsgExecResponse = exports.MsgExec = exports.MsgVoteResponse = exports.MsgVote = exports.MsgWithdrawProposalResponse = exports.MsgWithdrawProposal = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.MsgUpdateGroupPolicyMetadataResponse = exports.MsgUpdateGroupPolicyMetadata = exports.MsgUpdateGroupPolicyDecisionPolicyResponse = exports.MsgUpdateGroupPolicyDecisionPolicy = exports.MsgCreateGroupWithPolicyResponse = exports.MsgCreateGroupWithPolicy = exports.MsgUpdateGroupPolicyAdminResponse = exports.MsgUpdateGroupPolicyAdmin = exports.MsgCreateGroupPolicyResponse = exports.MsgCreateGroupPolicy = exports.MsgUpdateGroupMetadataResponse = exports.MsgUpdateGroupMetadata = exports.MsgUpdateGroupAdminResponse = exports.MsgUpdateGroupAdmin = exports.MsgUpdateGroupMembersResponse = exports.MsgUpdateGroupMembers = exports.MsgCreateGroupResponse = exports.MsgCreateGroup = exports.execToJSON = exports.execFromJSON = exports.Exec = exports.protobufPackage = void 0;
    var types_1 = require_types();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.group.v1";
    var Exec;
    (function(Exec2) {
      Exec2[Exec2["EXEC_UNSPECIFIED"] = 0] = "EXEC_UNSPECIFIED";
      Exec2[Exec2["EXEC_TRY"] = 1] = "EXEC_TRY";
      Exec2[Exec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Exec || (exports.Exec = Exec = {}));
    function execFromJSON(object) {
      switch (object) {
        case 0:
        case "EXEC_UNSPECIFIED":
          return Exec.EXEC_UNSPECIFIED;
        case 1:
        case "EXEC_TRY":
          return Exec.EXEC_TRY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Exec.UNRECOGNIZED;
      }
    }
    exports.execFromJSON = execFromJSON;
    function execToJSON(object) {
      switch (object) {
        case Exec.EXEC_UNSPECIFIED:
          return "EXEC_UNSPECIFIED";
        case Exec.EXEC_TRY:
          return "EXEC_TRY";
        case Exec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.execToJSON = execToJSON;
    function createBaseMsgCreateGroup() {
      return {
        admin: "",
        members: [],
        metadata: ""
      };
    }
    exports.MsgCreateGroup = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroup();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object == null ? void 0 : object.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCreateGroup();
        message.admin = object.admin ?? "";
        message.members = ((_a2 = object.members) == null ? void 0 : _a2.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgCreateGroupResponse() {
      return {
        groupId: BigInt(0)
      };
    }
    exports.MsgCreateGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembers() {
      return {
        admin: "",
        groupId: BigInt(0),
        memberUpdates: []
      };
    }
    exports.MsgUpdateGroupMembers = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        for (const v of message.memberUpdates) {
          types_1.MemberRequest.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembers();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.memberUpdates.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMembers();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if (Array.isArray(object == null ? void 0 : object.memberUpdates))
          obj.memberUpdates = object.memberUpdates.map((e) => types_1.MemberRequest.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        if (message.memberUpdates) {
          obj.memberUpdates = message.memberUpdates.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.memberUpdates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgUpdateGroupMembers();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.memberUpdates = ((_a2 = object.memberUpdates) == null ? void 0 : _a2.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembersResponse() {
      return {};
    }
    exports.MsgUpdateGroupMembersResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembersResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMembersResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMembersResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdmin() {
      return {
        admin: "",
        groupId: BigInt(0),
        newAdmin: ""
      };
    }
    exports.MsgUpdateGroupAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupAdmin();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdminResponse() {
      return {};
    }
    exports.MsgUpdateGroupAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupAdminResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupAdminResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadata() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: ""
      };
    }
    exports.MsgUpdateGroupMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMetadata();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadataResponse() {
      return {};
    }
    exports.MsgUpdateGroupMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMetadataResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMetadataResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicy() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: "",
        decisionPolicy: void 0
      };
    }
    exports.MsgCreateGroupPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicy();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicyResponse() {
      return {
        address: ""
      };
    }
    exports.MsgCreateGroupPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicyResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicyResponse();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdmin() {
      return {
        admin: "",
        groupPolicyAddress: "",
        newAdmin: ""
      };
    }
    exports.MsgUpdateGroupPolicyAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdminResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyAdminResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicy() {
      return {
        admin: "",
        members: [],
        groupMetadata: "",
        groupPolicyMetadata: "",
        groupPolicyAsAdmin: false,
        decisionPolicy: void 0
      };
    }
    exports.MsgCreateGroupWithPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMetadata !== "") {
          writer.uint32(26).string(message.groupMetadata);
        }
        if (message.groupPolicyMetadata !== "") {
          writer.uint32(34).string(message.groupPolicyMetadata);
        }
        if (message.groupPolicyAsAdmin === true) {
          writer.uint32(40).bool(message.groupPolicyAsAdmin);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.groupMetadata = reader.string();
              break;
            case 4:
              message.groupPolicyMetadata = reader.string();
              break;
            case 5:
              message.groupPolicyAsAdmin = reader.bool();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object == null ? void 0 : object.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.groupMetadata))
          obj.groupMetadata = String(object.groupMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyMetadata))
          obj.groupPolicyMetadata = String(object.groupPolicyMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyAsAdmin))
          obj.groupPolicyAsAdmin = Boolean(object.groupPolicyAsAdmin);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.groupMetadata !== void 0 && (obj.groupMetadata = message.groupMetadata);
        message.groupPolicyMetadata !== void 0 && (obj.groupPolicyMetadata = message.groupPolicyMetadata);
        message.groupPolicyAsAdmin !== void 0 && (obj.groupPolicyAsAdmin = message.groupPolicyAsAdmin);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCreateGroupWithPolicy();
        message.admin = object.admin ?? "";
        message.members = ((_a2 = object.members) == null ? void 0 : _a2.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        message.groupMetadata = object.groupMetadata ?? "";
        message.groupPolicyMetadata = object.groupPolicyMetadata ?? "";
        message.groupPolicyAsAdmin = object.groupPolicyAsAdmin ?? false;
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicyResponse() {
      return {
        groupId: BigInt(0),
        groupPolicyAddress: ""
      };
    }
    exports.MsgCreateGroupWithPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicyResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicy() {
      return {
        admin: "",
        groupPolicyAddress: "",
        decisionPolicy: void 0
      };
    }
    exports.MsgUpdateGroupPolicyDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicyResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyDecisionPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadata() {
      return {
        admin: "",
        groupPolicyAddress: "",
        metadata: ""
      };
    }
    exports.MsgUpdateGroupPolicyMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadataResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return message;
      }
    };
    function createBaseMsgSubmitProposal() {
      return {
        groupPolicyAddress: "",
        proposers: [],
        metadata: "",
        messages: [],
        exec: 0,
        title: "",
        summary: ""
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupPolicyAddress !== "") {
          writer.uint32(10).string(message.groupPolicyAddress);
        }
        for (const v of message.proposers) {
          writer.uint32(18).string(v);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        if (message.title !== "") {
          writer.uint32(50).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(58).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupPolicyAddress = reader.string();
              break;
            case 2:
              message.proposers.push(reader.string());
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 5:
              message.exec = reader.int32();
              break;
            case 6:
              message.title = reader.string();
              break;
            case 7:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if (Array.isArray(object == null ? void 0 : object.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSubmitProposal();
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.proposers = ((_a2 = object.proposers) == null ? void 0 : _a2.map((e) => e)) || [];
        message.metadata = object.metadata ?? "";
        message.messages = ((_b = object.messages) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.exec = object.exec ?? 0;
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgWithdrawProposal() {
      return {
        proposalId: BigInt(0),
        address: ""
      };
    }
    exports.MsgWithdrawProposal = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawProposalResponse() {
      return {};
    }
    exports.MsgWithdrawProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgWithdrawProposalResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawProposalResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        exec: 0
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.group.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.exec = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, types_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, types_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        message.exec = object.exec ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.group.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        proposalId: BigInt(0),
        executor: ""
      };
    }
    exports.MsgExec = {
      typeUrl: "/cosmos.group.v1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.executor !== "") {
          writer.uint32(18).string(message.executor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.executor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.executor))
          obj.executor = String(object.executor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.executor !== void 0 && (obj.executor = message.executor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.executor = object.executor ?? "";
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        result: 0
      };
    }
    exports.MsgExecResponse = {
      typeUrl: "/cosmos.group.v1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(16).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, types_1.proposalExecutorResultFromJSON)(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = (0, types_1.proposalExecutorResultToJSON)(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgLeaveGroup() {
      return {
        address: "",
        groupId: BigInt(0)
      };
    }
    exports.MsgLeaveGroup = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgLeaveGroup();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLeaveGroup();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgLeaveGroupResponse() {
      return {};
    }
    exports.MsgLeaveGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgLeaveGroupResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgLeaveGroupResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateGroup = this.CreateGroup.bind(this);
        this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this);
        this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this);
        this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this);
        this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this);
        this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this);
        this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this);
        this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this);
        this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this);
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.WithdrawProposal = this.WithdrawProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Exec = this.Exec.bind(this);
        this.LeaveGroup = this.LeaveGroup.bind(this);
      }
      CreateGroup(request) {
        const data2 = exports.MsgCreateGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", data2);
        return promise.then((data3) => exports.MsgCreateGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMembers(request) {
        const data2 = exports.MsgUpdateGroupMembers.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", data2);
        return promise.then((data3) => exports.MsgUpdateGroupMembersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupAdmin(request) {
        const data2 = exports.MsgUpdateGroupAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", data2);
        return promise.then((data3) => exports.MsgUpdateGroupAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMetadata(request) {
        const data2 = exports.MsgUpdateGroupMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", data2);
        return promise.then((data3) => exports.MsgUpdateGroupMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupPolicy(request) {
        const data2 = exports.MsgCreateGroupPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", data2);
        return promise.then((data3) => exports.MsgCreateGroupPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupWithPolicy(request) {
        const data2 = exports.MsgCreateGroupWithPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", data2);
        return promise.then((data3) => exports.MsgCreateGroupWithPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyAdmin(request) {
        const data2 = exports.MsgUpdateGroupPolicyAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyDecisionPolicy(request) {
        const data2 = exports.MsgUpdateGroupPolicyDecisionPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyMetadata(request) {
        const data2 = exports.MsgUpdateGroupPolicyMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawProposal(request) {
        const data2 = exports.MsgWithdrawProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", data2);
        return promise.then((data3) => exports.MsgWithdrawProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Exec", data2);
        return promise.then((data3) => exports.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      LeaveGroup(request) {
        const data2 = exports.MsgLeaveGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", data2);
        return promise.then((data3) => exports.MsgLeaveGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleVersion = exports.CancelSoftwareUpgradeProposal = exports.SoftwareUpgradeProposal = exports.Plan = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return {
        name: "",
        time: timestamp_1.Timestamp.fromPartial({}),
        height: BigInt(0),
        info: "",
        upgradedClientState: void 0
      };
    }
    exports.Plan = {
      typeUrl: "/cosmos.upgrade.v1beta1.Plan",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePlan();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePlan();
        message.name = object.name ?? "";
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.info = object.info ?? "";
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: exports.Plan.fromPartial({})
      };
    }
    exports.SoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = exports.Plan.fromJSON(object.plan);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = exports.Plan.fromPartial(object.plan);
        }
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports.CancelSoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCancelSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return {
        name: "",
        version: BigInt(0)
      };
    }
    exports.ModuleVersion = {
      typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleVersion();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleVersion();
        message.name = object.name ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpgradeProposal = exports.ClientUpdateProposal = exports.Params = exports.Height = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return {
        clientId: "",
        clientState: void 0
      };
    }
    exports.IdentifiedClientState = {
      typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedClientState();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedClientState();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return {
        height: exports.Height.fromPartial({}),
        consensusState: void 0
      };
    }
    exports.ConsensusStateWithHeight = {
      typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusStateWithHeight();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = exports.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        if (object.height !== void 0 && object.height !== null) {
          message.height = exports.Height.fromPartial(object.height);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return {
        clientId: "",
        consensusStates: []
      };
    }
    exports.ClientConsensusStates = {
      typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientConsensusStates();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => exports.ConsensusStateWithHeight.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseClientConsensusStates();
        message.clientId = object.clientId ?? "";
        message.consensusStates = ((_a2 = object.consensusStates) == null ? void 0 : _a2.map((e) => exports.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseHeight() {
      return {
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.Height = {
      typeUrl: "/ibc.core.client.v1.Height",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeight();
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeight();
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        allowedClients: []
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.client.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object == null ? void 0 : object.allowedClients))
          obj.allowedClients = object.allowedClients.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseParams();
        message.allowedClients = ((_a2 = object.allowedClients) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports.ClientUpdateProposal = {
      typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientUpdateProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientUpdateProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0
      };
    }
    exports.UpgradeProposal = {
      typeUrl: "/ibc.core.client.v1.UpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx9 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: coin_1.Coin.fromPartial({}),
        sender: "",
        receiver: "",
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0),
        memo: ""
      };
    }
    exports.MsgTransfer = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransfer();
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.token))
          obj.token = coin_1.Coin.fromJSON(object.token);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.receiver))
          obj.receiver = String(object.receiver);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransfer();
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        if (object.token !== void 0 && object.token !== null) {
          message.token = coin_1.Coin.fromPartial(object.token);
        }
        message.sender = object.sender ?? "";
        message.receiver = object.receiver ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        message.memo = object.memo ?? "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {
        sequence: BigInt(0)
      };
    }
    exports.MsgTransferResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransferResponse();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransferResponse();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      Transfer(request) {
        const data2 = exports.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data2);
        return promise.then((data3) => exports.MsgTransferResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgTransfer = isAminoMsgTransfer;
    exports.createIbcAminoConverters = createIbcAminoConverters;
    var amino_1 = require_build5();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => {
            var _a2, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a2 = (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)) == null ? void 0 : _a2.toString(),
                revision_number: (_b = (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)) == null ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = (0, amino_1.omitDefault)(timeoutTimestamp)) == null ? void 0 : _c.toString(),
              memo: (0, amino_1.omitDefault)(memo)
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Timeout = exports.Acknowledgement = exports.PacketId = exports.PacketState = exports.Packet = exports.Counterparty = exports.IdentifiedChannel = exports.Channel = exports.orderToJSON = exports.orderFromJSON = exports.Order = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["STATE_FLUSHING"] = 5] = "STATE_FLUSHING";
      State2[State2["STATE_FLUSHCOMPLETE"] = 6] = "STATE_FLUSHCOMPLETE";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case 5:
        case "STATE_FLUSHING":
          return State.STATE_FLUSHING;
        case 6:
        case "STATE_FLUSHCOMPLETE":
          return State.STATE_FLUSHCOMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        case State.STATE_FLUSHING:
          return "STATE_FLUSHING";
        case State.STATE_FLUSHCOMPLETE:
          return "STATE_FLUSHCOMPLETE";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order || (exports.Order = Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports.Channel = {
      typeUrl: "/ibc.core.channel.v1.Channel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object == null ? void 0 : object.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = ((_a2 = object.connectionHops) == null ? void 0 : _a2.map((e) => e)) || [];
        message.version = object.version ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        portId: "",
        channelId: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports.IdentifiedChannel = {
      typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(64).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            case 8:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object == null ? void 0 : object.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseIdentifiedChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = ((_a2 = object.connectionHops) == null ? void 0 : _a2.map((e) => e)) || [];
        message.version = object.version ?? "";
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.Counterparty = {
      typeUrl: "/ibc.core.channel.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: BigInt(0),
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0)
      };
    }
    exports.Packet = {
      typeUrl: "/ibc.core.channel.v1.Packet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacket();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.destinationPort))
          obj.destinationPort = String(object.destinationPort);
        if ((0, helpers_1.isSet)(object.destinationChannel))
          obj.destinationChannel = String(object.destinationChannel);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacket();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        message.destinationPort = object.destinationPort ?? "";
        message.destinationChannel = object.destinationChannel ?? "";
        message.data = object.data ?? new Uint8Array();
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        return message;
      }
    };
    function createBasePacketState() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0),
        data: new Uint8Array()
      };
    }
    exports.PacketState = {
      typeUrl: "/ibc.core.channel.v1.PacketState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketState();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketState();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBasePacketId() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.PacketId = {
      typeUrl: "/ibc.core.channel.v1.PacketId",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketId();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketId();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return {
        result: void 0,
        error: void 0
      };
    }
    exports.Acknowledgement = {
      typeUrl: "/ibc.core.channel.v1.Acknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAcknowledgement();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, helpers_1.bytesFromBase64)(object.result);
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? (0, helpers_1.base64FromBytes)(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAcknowledgement();
        message.result = object.result ?? void 0;
        message.error = object.error ?? void 0;
        return message;
      }
    };
    function createBaseTimeout() {
      return {
        height: client_1.Height.fromPartial({}),
        timestamp: BigInt(0)
      };
    }
    exports.Timeout = {
      typeUrl: "/ibc.core.channel.v1.Timeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== BigInt(0)) {
          writer.uint32(16).uint64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.timestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimeout();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = BigInt(object.timestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimeout();
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = BigInt(object.timestamp.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        upgradeTimeout: exports.Timeout.fromPartial({})
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.channel.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradeTimeout !== void 0) {
          exports.Timeout.encode(message.upgradeTimeout, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradeTimeout = exports.Timeout.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.upgradeTimeout))
          obj.upgradeTimeout = exports.Timeout.fromJSON(object.upgradeTimeout);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradeTimeout !== void 0 && (obj.upgradeTimeout = message.upgradeTimeout ? exports.Timeout.toJSON(message.upgradeTimeout) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.upgradeTimeout !== void 0 && object.upgradeTimeout !== null) {
          message.upgradeTimeout = exports.Timeout.fromPartial(object.upgradeTimeout);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js
var require_upgrade2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorReceipt = exports.UpgradeFields = exports.Upgrade = exports.protobufPackage = void 0;
    var channel_1 = require_channel();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    function createBaseUpgrade() {
      return {
        fields: exports.UpgradeFields.fromPartial({}),
        timeout: channel_1.Timeout.fromPartial({}),
        nextSequenceSend: BigInt(0)
      };
    }
    exports.Upgrade = {
      typeUrl: "/ibc.core.channel.v1.Upgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fields !== void 0) {
          exports.UpgradeFields.encode(message.fields, writer.uint32(10).fork()).ldelim();
        }
        if (message.timeout !== void 0) {
          channel_1.Timeout.encode(message.timeout, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(24).uint64(message.nextSequenceSend);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fields = exports.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 2:
              message.timeout = channel_1.Timeout.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextSequenceSend = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgrade();
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = exports.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.timeout))
          obj.timeout = channel_1.Timeout.fromJSON(object.timeout);
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fields !== void 0 && (obj.fields = message.fields ? exports.UpgradeFields.toJSON(message.fields) : void 0);
        message.timeout !== void 0 && (obj.timeout = message.timeout ? channel_1.Timeout.toJSON(message.timeout) : void 0);
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgrade();
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = exports.UpgradeFields.fromPartial(object.fields);
        }
        if (object.timeout !== void 0 && object.timeout !== null) {
          message.timeout = channel_1.Timeout.fromPartial(object.timeout);
        }
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        return message;
      }
    };
    function createBaseUpgradeFields() {
      return {
        ordering: 0,
        connectionHops: [],
        version: ""
      };
    }
    exports.UpgradeFields = {
      typeUrl: "/ibc.core.channel.v1.UpgradeFields",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ordering !== 0) {
          writer.uint32(8).int32(message.ordering);
        }
        for (const v of message.connectionHops) {
          writer.uint32(18).string(v);
        }
        if (message.version !== "") {
          writer.uint32(26).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeFields();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ordering = reader.int32();
              break;
            case 2:
              message.connectionHops.push(reader.string());
              break;
            case 3:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeFields();
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = (0, channel_1.orderFromJSON)(object.ordering);
        if (Array.isArray(object == null ? void 0 : object.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ordering !== void 0 && (obj.ordering = (0, channel_1.orderToJSON)(message.ordering));
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseUpgradeFields();
        message.ordering = object.ordering ?? 0;
        message.connectionHops = ((_a2 = object.connectionHops) == null ? void 0 : _a2.map((e) => e)) || [];
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseErrorReceipt() {
      return {
        sequence: BigInt(0),
        message: ""
      };
    }
    exports.ErrorReceipt = {
      typeUrl: "/ibc.core.channel.v1.ErrorReceipt",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.message !== "") {
          writer.uint32(18).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseErrorReceipt();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseErrorReceipt();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseErrorReceipt();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.message = object.message ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx10 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgPruneAcknowledgementsResponse = exports.MsgPruneAcknowledgements = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgChannelUpgradeCancelResponse = exports.MsgChannelUpgradeCancel = exports.MsgChannelUpgradeTimeoutResponse = exports.MsgChannelUpgradeTimeout = exports.MsgChannelUpgradeOpenResponse = exports.MsgChannelUpgradeOpen = exports.MsgChannelUpgradeConfirmResponse = exports.MsgChannelUpgradeConfirm = exports.MsgChannelUpgradeAckResponse = exports.MsgChannelUpgradeAck = exports.MsgChannelUpgradeTryResponse = exports.MsgChannelUpgradeTry = exports.MsgChannelUpgradeInitResponse = exports.MsgChannelUpgradeInit = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;
    var channel_1 = require_channel();
    var client_1 = require_client();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    var ResponseResultType;
    (function(ResponseResultType2) {
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_FAILURE"] = 3] = "RESPONSE_RESULT_TYPE_FAILURE";
      ResponseResultType2[ResponseResultType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseResultType || (exports.ResponseResultType = ResponseResultType = {}));
    function responseResultTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
          return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
          return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
          return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case 3:
        case "RESPONSE_RESULT_TYPE_FAILURE":
          return ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseResultType.UNRECOGNIZED;
      }
    }
    exports.responseResultTypeFromJSON = responseResultTypeFromJSON;
    function responseResultTypeToJSON(object) {
      switch (object) {
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
          return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
          return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
          return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE:
          return "RESPONSE_RESULT_TYPE_FAILURE";
        case ResponseResultType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseResultTypeToJSON = responseResultTypeToJSON;
    function createBaseMsgChannelOpenInit() {
      return {
        portId: "",
        channel: channel_1.Channel.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInit();
        message.portId = object.portId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenInitResponse() {
      return {
        channelId: "",
        version: ""
      };
    }
    exports.MsgChannelOpenInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channelId !== "") {
          writer.uint32(10).string(message.channelId);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channelId = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInitResponse();
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = object.channelId ?? "";
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTry() {
      return {
        portId: "",
        previousChannelId: "",
        channel: channel_1.Channel.fromPartial({}),
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.previousChannelId))
          obj.previousChannelId = String(object.previousChannelId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTry();
        message.portId = object.portId ?? "";
        message.previousChannelId = object.previousChannelId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTryResponse() {
      return {
        version: "",
        channelId: ""
      };
    }
    exports.MsgChannelOpenTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTryResponse();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = object.version ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelId))
          obj.counterpartyChannelId = String(object.counterpartyChannelId);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelId = object.counterpartyChannelId ?? "";
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofTry = object.proofTry ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAckResponse() {
      return {};
    }
    exports.MsgChannelOpenAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirm() {
      return {
        portId: "",
        channelId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirmResponse() {
      return {};
    }
    exports.MsgChannelOpenConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseInit() {
      return {
        portId: "",
        channelId: "",
        signer: ""
      };
    }
    exports.MsgChannelCloseInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelCloseInitResponse() {
      return {};
    }
    exports.MsgChannelCloseInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirm() {
      return {
        portId: "",
        channelId: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports.MsgChannelCloseConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            case 6:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirmResponse() {
      return {};
    }
    exports.MsgChannelCloseConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
      }
    };
    function createBaseMsgRecvPacket() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofCommitment: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgRecvPacket = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacket();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofCommitment))
          obj.proofCommitment = (0, helpers_1.bytesFromBase64)(object.proofCommitment);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = (0, helpers_1.base64FromBytes)(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacket();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofCommitment = object.proofCommitment ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecvPacketResponse() {
      return {
        result: 0
      };
    }
    exports.MsgRecvPacketResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacketResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacketResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeout() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
      };
    }
    exports.MsgTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeout();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeout();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgTimeoutResponse() {
      return {
        result: 0
      };
    }
    exports.MsgTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeoutOnClose() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports.MsgTimeoutOnClose = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(56).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            case 7:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnClose();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofClose))
          obj.proofClose = (0, helpers_1.bytesFromBase64)(object.proofClose);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = (0, helpers_1.base64FromBytes)(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnClose();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        message.proofClose = object.proofClose ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgTimeoutOnCloseResponse() {
      return {
        result: 0
      };
    }
    exports.MsgTimeoutOnCloseResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnCloseResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgAcknowledgement() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgAcknowledgement = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgement();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proofAcked))
          obj.proofAcked = (0, helpers_1.bytesFromBase64)(object.proofAcked);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = (0, helpers_1.base64FromBytes)(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgement();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proofAcked = object.proofAcked ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgAcknowledgementResponse() {
      return {
        result: 0
      };
    }
    exports.MsgAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgementResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInit() {
      return {
        portId: "",
        channelId: "",
        fields: upgrade_1.UpgradeFields.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.fields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.fields, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.fields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = upgrade_1.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.fields !== void 0 && (obj.fields = message.fields ? upgrade_1.UpgradeFields.toJSON(message.fields) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = upgrade_1.UpgradeFields.fromPartial(object.fields);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInitResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0)
      };
    }
    exports.MsgChannelUpgradeInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInitResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInitResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTry() {
      return {
        portId: "",
        channelId: "",
        proposedUpgradeConnectionHops: [],
        counterpartyUpgradeFields: upgrade_1.UpgradeFields.fromPartial({}),
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        for (const v of message.proposedUpgradeConnectionHops) {
          writer.uint32(26).string(v);
        }
        if (message.counterpartyUpgradeFields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.counterpartyUpgradeFields, writer.uint32(34).fork()).ldelim();
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(50).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(58).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(66).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(74).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proposedUpgradeConnectionHops.push(reader.string());
              break;
            case 4:
              message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 5:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 6:
              message.proofChannel = reader.bytes();
              break;
            case 7:
              message.proofUpgrade = reader.bytes();
              break;
            case 8:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 9:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object == null ? void 0 : object.proposedUpgradeConnectionHops))
          obj.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeFields))
          obj.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromJSON(object.counterpartyUpgradeFields);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.proposedUpgradeConnectionHops) {
          obj.proposedUpgradeConnectionHops = message.proposedUpgradeConnectionHops.map((e) => e);
        } else {
          obj.proposedUpgradeConnectionHops = [];
        }
        message.counterpartyUpgradeFields !== void 0 && (obj.counterpartyUpgradeFields = message.counterpartyUpgradeFields ? upgrade_1.UpgradeFields.toJSON(message.counterpartyUpgradeFields) : void 0);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgChannelUpgradeTry();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proposedUpgradeConnectionHops = ((_a2 = object.proposedUpgradeConnectionHops) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.counterpartyUpgradeFields !== void 0 && object.counterpartyUpgradeFields !== null) {
          message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromPartial(object.counterpartyUpgradeFields);
        }
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTryResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0),
        result: 0
      };
    }
    exports.MsgChannelUpgradeTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        if (message.result !== 0) {
          writer.uint32(24).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            case 3:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTryResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTryResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofUpgrade = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAckResponse() {
      return {
        result: 0
      };
    }
    exports.MsgChannelUpgradeAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAckResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAckResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAckResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirm() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(50).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(66).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofUpgrade = reader.bytes();
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirmResponse() {
      return {
        result: 0
      };
    }
    exports.MsgChannelUpgradeConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirmResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirmResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpen() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeOpen = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpen",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpen();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeOpen();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeOpen();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpenResponse() {
      return {};
    }
    exports.MsgChannelUpgradeOpenResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpenResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpenResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeOpenResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeOpenResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeout() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannel: channel_1.Channel.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannel !== void 0) {
          channel_1.Channel.encode(message.counterpartyChannel, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTimeout();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannel))
          obj.counterpartyChannel = channel_1.Channel.fromJSON(object.counterpartyChannel);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannel !== void 0 && (obj.counterpartyChannel = message.counterpartyChannel ? channel_1.Channel.toJSON(message.counterpartyChannel) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTimeout();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyChannel !== void 0 && object.counterpartyChannel !== null) {
          message.counterpartyChannel = channel_1.Channel.fromPartial(object.counterpartyChannel);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeoutResponse() {
      return {};
    }
    exports.MsgChannelUpgradeTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeoutResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeTimeoutResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancel() {
      return {
        portId: "",
        channelId: "",
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proofErrorReceipt: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeCancel = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofErrorReceipt.length !== 0) {
          writer.uint32(34).bytes(message.proofErrorReceipt);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofErrorReceipt = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeCancel();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proofErrorReceipt))
          obj.proofErrorReceipt = (0, helpers_1.bytesFromBase64)(object.proofErrorReceipt);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proofErrorReceipt !== void 0 && (obj.proofErrorReceipt = (0, helpers_1.base64FromBytes)(message.proofErrorReceipt !== void 0 ? message.proofErrorReceipt : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeCancel();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proofErrorReceipt = object.proofErrorReceipt ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancelResponse() {
      return {};
    }
    exports.MsgChannelUpgradeCancelResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancelResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeCancelResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeCancelResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgements() {
      return {
        portId: "",
        channelId: "",
        limit: BigInt(0),
        signer: ""
      };
    }
    exports.MsgPruneAcknowledgements = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgements",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgements();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgements();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgements();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgementsResponse() {
      return {
        totalPrunedSequences: BigInt(0),
        totalRemainingSequences: BigInt(0)
      };
    }
    exports.MsgPruneAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalPrunedSequences !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalPrunedSequences);
        }
        if (message.totalRemainingSequences !== BigInt(0)) {
          writer.uint32(16).uint64(message.totalRemainingSequences);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalPrunedSequences = reader.uint64();
              break;
            case 2:
              message.totalRemainingSequences = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgementsResponse();
        if ((0, helpers_1.isSet)(object.totalPrunedSequences))
          obj.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        if ((0, helpers_1.isSet)(object.totalRemainingSequences))
          obj.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalPrunedSequences !== void 0 && (obj.totalPrunedSequences = (message.totalPrunedSequences || BigInt(0)).toString());
        message.totalRemainingSequences !== void 0 && (obj.totalRemainingSequences = (message.totalRemainingSequences || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgementsResponse();
        if (object.totalPrunedSequences !== void 0 && object.totalPrunedSequences !== null) {
          message.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        }
        if (object.totalRemainingSequences !== void 0 && object.totalRemainingSequences !== null) {
          message.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
        this.ChannelUpgradeInit = this.ChannelUpgradeInit.bind(this);
        this.ChannelUpgradeTry = this.ChannelUpgradeTry.bind(this);
        this.ChannelUpgradeAck = this.ChannelUpgradeAck.bind(this);
        this.ChannelUpgradeConfirm = this.ChannelUpgradeConfirm.bind(this);
        this.ChannelUpgradeOpen = this.ChannelUpgradeOpen.bind(this);
        this.ChannelUpgradeTimeout = this.ChannelUpgradeTimeout.bind(this);
        this.ChannelUpgradeCancel = this.ChannelUpgradeCancel.bind(this);
        this.UpdateChannelParams = this.UpdateChannelParams.bind(this);
        this.PruneAcknowledgements = this.PruneAcknowledgements.bind(this);
      }
      ChannelOpenInit(request) {
        const data2 = exports.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data2);
        return promise.then((data3) => exports.MsgChannelOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenTry(request) {
        const data2 = exports.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data2);
        return promise.then((data3) => exports.MsgChannelOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenAck(request) {
        const data2 = exports.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data2);
        return promise.then((data3) => exports.MsgChannelOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenConfirm(request) {
        const data2 = exports.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data2);
        return promise.then((data3) => exports.MsgChannelOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseInit(request) {
        const data2 = exports.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data2);
        return promise.then((data3) => exports.MsgChannelCloseInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseConfirm(request) {
        const data2 = exports.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data2);
        return promise.then((data3) => exports.MsgChannelCloseConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecvPacket(request) {
        const data2 = exports.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data2);
        return promise.then((data3) => exports.MsgRecvPacketResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Timeout(request) {
        const data2 = exports.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data2);
        return promise.then((data3) => exports.MsgTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TimeoutOnClose(request) {
        const data2 = exports.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data2);
        return promise.then((data3) => exports.MsgTimeoutOnCloseResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Acknowledgement(request) {
        const data2 = exports.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data2);
        return promise.then((data3) => exports.MsgAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeInit(request) {
        const data2 = exports.MsgChannelUpgradeInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeInit", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTry(request) {
        const data2 = exports.MsgChannelUpgradeTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTry", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeAck(request) {
        const data2 = exports.MsgChannelUpgradeAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeAck", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeConfirm(request) {
        const data2 = exports.MsgChannelUpgradeConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeConfirm", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeOpen(request) {
        const data2 = exports.MsgChannelUpgradeOpen.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeOpen", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeOpenResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTimeout(request) {
        const data2 = exports.MsgChannelUpgradeTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTimeout", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeCancel(request) {
        const data2 = exports.MsgChannelUpgradeCancel.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeCancel", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeCancelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateChannelParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "UpdateChannelParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAcknowledgements(request) {
        const data2 = exports.MsgPruneAcknowledgements.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "PruneAcknowledgements", data2);
        return promise.then((data3) => exports.MsgPruneAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx11 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgIBCSoftwareUpgradeResponse = exports.MsgIBCSoftwareUpgrade = exports.MsgRecoverClientResponse = exports.MsgRecoverClient = exports.MsgSubmitMisbehaviourResponse = exports.MsgSubmitMisbehaviour = exports.MsgUpgradeClientResponse = exports.MsgUpgradeClient = exports.MsgUpdateClientResponse = exports.MsgUpdateClient = exports.MsgCreateClientResponse = exports.MsgCreateClient = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseMsgCreateClient() {
      return {
        clientState: void 0,
        consensusState: void 0,
        signer: ""
      };
    }
    exports.MsgCreateClient = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateClient();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateClient();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgCreateClientResponse() {
      return {};
    }
    exports.MsgCreateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpdateClient() {
      return {
        clientId: "",
        clientMessage: void 0,
        signer: ""
      };
    }
    exports.MsgUpdateClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientMessage !== void 0) {
          any_1.Any.encode(message.clientMessage, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientMessage = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientMessage))
          obj.clientMessage = any_1.Any.fromJSON(object.clientMessage);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientMessage !== void 0 && (obj.clientMessage = message.clientMessage ? any_1.Any.toJSON(message.clientMessage) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateClient();
        message.clientId = object.clientId ?? "";
        if (object.clientMessage !== void 0 && object.clientMessage !== null) {
          message.clientMessage = any_1.Any.fromPartial(object.clientMessage);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateClientResponse() {
      return {};
    }
    exports.MsgUpdateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpgradeClient() {
      return {
        clientId: "",
        clientState: void 0,
        consensusState: void 0,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
      };
    }
    exports.MsgUpgradeClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpgradeClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proofUpgradeClient))
          obj.proofUpgradeClient = (0, helpers_1.bytesFromBase64)(object.proofUpgradeClient);
        if ((0, helpers_1.isSet)(object.proofUpgradeConsensusState))
          obj.proofUpgradeConsensusState = (0, helpers_1.bytesFromBase64)(object.proofUpgradeConsensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = (0, helpers_1.base64FromBytes)(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = (0, helpers_1.base64FromBytes)(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpgradeClient();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proofUpgradeClient = object.proofUpgradeClient ?? new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState ?? new Uint8Array();
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpgradeClientResponse() {
      return {};
    }
    exports.MsgUpgradeClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpgradeClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviour() {
      return {
        clientId: "",
        misbehaviour: void 0,
        signer: ""
      };
    }
    exports.MsgSubmitMisbehaviour = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.misbehaviour))
          obj.misbehaviour = any_1.Any.fromJSON(object.misbehaviour);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.misbehaviour !== void 0 && object.misbehaviour !== null) {
          message.misbehaviour = any_1.Any.fromPartial(object.misbehaviour);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviourResponse() {
      return {};
    }
    exports.MsgSubmitMisbehaviourResponse = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSubmitMisbehaviourResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
      }
    };
    function createBaseMsgRecoverClient() {
      return {
        subjectClientId: "",
        substituteClientId: "",
        signer: ""
      };
    }
    exports.MsgRecoverClient = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.subjectClientId !== "") {
          writer.uint32(10).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(18).string(message.substituteClientId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subjectClientId = reader.string();
              break;
            case 2:
              message.substituteClientId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecoverClient();
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecoverClient();
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecoverClientResponse() {
      return {};
    }
    exports.MsgRecoverClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRecoverClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRecoverClientResponse();
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgrade() {
      return {
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0,
        signer: ""
      };
    }
    exports.MsgIBCSoftwareUpgrade = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgIBCSoftwareUpgrade();
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgIBCSoftwareUpgrade();
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgradeResponse() {
      return {};
    }
    exports.MsgIBCSoftwareUpgradeResponse = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgradeResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgIBCSoftwareUpgradeResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
        this.RecoverClient = this.RecoverClient.bind(this);
        this.IBCSoftwareUpgrade = this.IBCSoftwareUpgrade.bind(this);
        this.UpdateClientParams = this.UpdateClientParams.bind(this);
      }
      CreateClient(request) {
        const data2 = exports.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data2);
        return promise.then((data3) => exports.MsgCreateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClient(request) {
        const data2 = exports.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data2);
        return promise.then((data3) => exports.MsgUpdateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeClient(request) {
        const data2 = exports.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data2);
        return promise.then((data3) => exports.MsgUpgradeClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitMisbehaviour(request) {
        const data2 = exports.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data2);
        return promise.then((data3) => exports.MsgSubmitMisbehaviourResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecoverClient(request) {
        const data2 = exports.MsgRecoverClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "RecoverClient", data2);
        return promise.then((data3) => exports.MsgRecoverClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      IBCSoftwareUpgrade(request) {
        const data2 = exports.MsgIBCSoftwareUpgrade.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "IBCSoftwareUpgrade", data2);
        return promise.then((data3) => exports.MsgIBCSoftwareUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClientParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClientParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js
var require_proofs = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.ics23.v1";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["SHA512_256"] = 6] = "SHA512_256";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp || (exports.HashOp = HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case 6:
        case "SHA512_256":
          return HashOp.SHA512_256;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        case HashOp.SHA512_256:
          return "SHA512_256";
        case HashOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp || (exports.LengthOp = LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.lengthOpToJSON = lengthOpToJSON;
    function createBaseExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports.ExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.ExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.path) {
          exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object == null ? void 0 : object.path))
          obj.path = object.path.map((e) => exports.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports.LeafOp.fromPartial(object.leaf);
        }
        message.path = ((_a2 = object.path) == null ? void 0 : _a2.map((e) => exports.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports.NonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports.ExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports.ExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports.ExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports.ExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
    function createBaseCommitmentProof() {
      return {
        exist: void 0,
        nonexist: void 0,
        batch: void 0,
        compressed: void 0
      };
    }
    exports.CommitmentProof = {
      typeUrl: "/cosmos.ics23.v1.CommitmentProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitmentProof();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        if ((0, helpers_1.isSet)(object.batch))
          obj.batch = exports.BatchProof.fromJSON(object.batch);
        if ((0, helpers_1.isSet)(object.compressed))
          obj.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitmentProof();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        }
        if (object.batch !== void 0 && object.batch !== null) {
          message.batch = exports.BatchProof.fromPartial(object.batch);
        }
        if (object.compressed !== void 0 && object.compressed !== null) {
          message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);
        }
        return message;
      }
    };
    function createBaseLeafOp() {
      return {
        hash: 0,
        prehashKey: 0,
        prehashValue: 0,
        length: 0,
        prefix: new Uint8Array()
      };
    }
    exports.LeafOp = {
      typeUrl: "/cosmos.ics23.v1.LeafOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLeafOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prehashKey))
          obj.prehashKey = hashOpFromJSON(object.prehashKey);
        if ((0, helpers_1.isSet)(object.prehashValue))
          obj.prehashValue = hashOpFromJSON(object.prehashValue);
        if ((0, helpers_1.isSet)(object.length))
          obj.length = lengthOpFromJSON(object.length);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLeafOp();
        message.hash = object.hash ?? 0;
        message.prehashKey = object.prehashKey ?? 0;
        message.prehashValue = object.prehashValue ?? 0;
        message.length = object.length ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseInnerOp() {
      return {
        hash: 0,
        prefix: new Uint8Array(),
        suffix: new Uint8Array()
      };
    }
    exports.InnerOp = {
      typeUrl: "/cosmos.ics23.v1.InnerOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        if ((0, helpers_1.isSet)(object.suffix))
          obj.suffix = (0, helpers_1.bytesFromBase64)(object.suffix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = (0, helpers_1.base64FromBytes)(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerOp();
        message.hash = object.hash ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        message.suffix = object.suffix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofSpec() {
      return {
        leafSpec: void 0,
        innerSpec: void 0,
        maxDepth: 0,
        minDepth: 0
      };
    }
    exports.ProofSpec = {
      typeUrl: "/cosmos.ics23.v1.ProofSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.leafSpec !== void 0) {
          exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofSpec();
        if ((0, helpers_1.isSet)(object.leafSpec))
          obj.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);
        if ((0, helpers_1.isSet)(object.innerSpec))
          obj.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);
        if ((0, helpers_1.isSet)(object.maxDepth))
          obj.maxDepth = Number(object.maxDepth);
        if ((0, helpers_1.isSet)(object.minDepth))
          obj.minDepth = Number(object.minDepth);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== void 0 && (obj.minDepth = Math.round(message.minDepth));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofSpec();
        if (object.leafSpec !== void 0 && object.leafSpec !== null) {
          message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);
        }
        if (object.innerSpec !== void 0 && object.innerSpec !== null) {
          message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);
        }
        message.maxDepth = object.maxDepth ?? 0;
        message.minDepth = object.minDepth ?? 0;
        return message;
      }
    };
    function createBaseInnerSpec() {
      return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
      };
    }
    exports.InnerSpec = {
      typeUrl: "/cosmos.ics23.v1.InnerSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerSpec();
        if (Array.isArray(object == null ? void 0 : object.childOrder))
          obj.childOrder = object.childOrder.map((e) => Number(e));
        if ((0, helpers_1.isSet)(object.childSize))
          obj.childSize = Number(object.childSize);
        if ((0, helpers_1.isSet)(object.minPrefixLength))
          obj.minPrefixLength = Number(object.minPrefixLength);
        if ((0, helpers_1.isSet)(object.maxPrefixLength))
          obj.maxPrefixLength = Number(object.maxPrefixLength);
        if ((0, helpers_1.isSet)(object.emptyChild))
          obj.emptyChild = (0, helpers_1.bytesFromBase64)(object.emptyChild);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => Math.round(e));
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== void 0 && (obj.emptyChild = (0, helpers_1.base64FromBytes)(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseInnerSpec();
        message.childOrder = ((_a2 = object.childOrder) == null ? void 0 : _a2.map((e) => e)) || [];
        message.childSize = object.childSize ?? 0;
        message.minPrefixLength = object.minPrefixLength ?? 0;
        message.maxPrefixLength = object.maxPrefixLength ?? 0;
        message.emptyChild = object.emptyChild ?? new Uint8Array();
        message.hash = object.hash ?? 0;
        return message;
      }
    };
    function createBaseBatchProof() {
      return {
        entries: []
      };
    }
    exports.BatchProof = {
      typeUrl: "/cosmos.ics23.v1.BatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchProof();
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports.BatchEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseBatchProof();
        message.entries = ((_a2 = object.entries) == null ? void 0 : _a2.map((e) => exports.BatchEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports.BatchEntry = {
      typeUrl: "/cosmos.ics23.v1.BatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedBatchProof() {
      return {
        entries: [],
        lookupInners: []
      };
    }
    exports.CompressedBatchProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.lookupInners) {
          exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchProof();
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports.CompressedBatchEntry.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.lookupInners))
          obj.lookupInners = object.lookupInners.map((e) => exports.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCompressedBatchProof();
        message.entries = ((_a2 = object.entries) == null ? void 0 : _a2.map((e) => exports.CompressedBatchEntry.fromPartial(e))) || [];
        message.lookupInners = ((_b = object.lookupInners) == null ? void 0 : _b.map((e) => exports.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCompressedBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports.CompressedBatchEntry = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.CompressedExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports.CompressedExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.path) {
          writer.int32(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object == null ? void 0 : object.path))
          obj.path = object.path.map((e) => Number(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => Math.round(e));
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseCompressedExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports.LeafOp.fromPartial(object.leaf);
        }
        message.path = ((_a2 = object.path) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompressedNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports.CompressedNonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports.CompressedExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports.CompressedExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports.CompressedExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports.CompressedExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleProof = exports.MerklePath = exports.MerklePrefix = exports.MerkleRoot = exports.protobufPackage = void 0;
    var proofs_1 = require_proofs();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.commitment.v1";
    function createBaseMerkleRoot() {
      return {
        hash: new Uint8Array()
      };
    }
    exports.MerkleRoot = {
      typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleRoot();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleRoot();
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePrefix() {
      return {
        keyPrefix: new Uint8Array()
      };
    }
    exports.MerklePrefix = {
      typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePrefix();
        if ((0, helpers_1.isSet)(object.keyPrefix))
          obj.keyPrefix = (0, helpers_1.bytesFromBase64)(object.keyPrefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = (0, helpers_1.base64FromBytes)(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePrefix();
        message.keyPrefix = object.keyPrefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePath() {
      return {
        keyPath: []
      };
    }
    exports.MerklePath = {
      typeUrl: "/ibc.core.commitment.v1.MerklePath",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.keyPath) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePath();
        if (Array.isArray(object == null ? void 0 : object.keyPath))
          obj.keyPath = object.keyPath.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMerklePath();
        message.keyPath = ((_a2 = object.keyPath) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMerkleProof() {
      return {
        proofs: []
      };
    }
    exports.MerkleProof = {
      typeUrl: "/ibc.core.commitment.v1.MerkleProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proofs) {
          proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleProof();
        if (Array.isArray(object == null ? void 0 : object.proofs))
          obj.proofs = object.proofs.map((e) => proofs_1.CommitmentProof.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMerkleProof();
        message.proofs = ((_a2 = object.proofs) == null ? void 0 : _a2.map((e) => proofs_1.CommitmentProof.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var commitment_1 = require_commitment();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.stateToJSON = stateToJSON;
    function createBaseConnectionEnd() {
      return {
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports.ConnectionEnd = {
      typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.versions) {
          exports.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionEnd();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.versions))
          obj.versions = object.versions.map((e) => exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseConnectionEnd();
        message.clientId = object.clientId ?? "";
        message.versions = ((_a2 = object.versions) == null ? void 0 : _a2.map((e) => exports.Version.fromPartial(e))) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedConnection() {
      return {
        id: "",
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports.IdentifiedConnection = {
      typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v of message.versions) {
          exports.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedConnection();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = String(object.id);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.versions))
          obj.versions = object.versions.map((e) => exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseIdentifiedConnection();
        message.id = object.id ?? "";
        message.clientId = object.clientId ?? "";
        message.versions = ((_a2 = object.versions) == null ? void 0 : _a2.map((e) => exports.Version.fromPartial(e))) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        clientId: "",
        connectionId: "",
        prefix: commitment_1.MerklePrefix.fromPartial({})
      };
    }
    exports.Counterparty = {
      typeUrl: "/ibc.core.connection.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.clientId = object.clientId ?? "";
        message.connectionId = object.connectionId ?? "";
        if (object.prefix !== void 0 && object.prefix !== null) {
          message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);
        }
        return message;
      }
    };
    function createBaseClientPaths() {
      return {
        paths: []
      };
    }
    exports.ClientPaths = {
      typeUrl: "/ibc.core.connection.v1.ClientPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.paths) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientPaths();
        if (Array.isArray(object == null ? void 0 : object.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseClientPaths();
        message.paths = ((_a2 = object.paths) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseConnectionPaths() {
      return {
        clientId: "",
        paths: []
      };
    }
    exports.ConnectionPaths = {
      typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.paths) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionPaths();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseConnectionPaths();
        message.clientId = object.clientId ?? "";
        message.paths = ((_a2 = object.paths) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersion() {
      return {
        identifier: "",
        features: []
      };
    }
    exports.Version = {
      typeUrl: "/ibc.core.connection.v1.Version",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersion();
        if ((0, helpers_1.isSet)(object.identifier))
          obj.identifier = String(object.identifier);
        if (Array.isArray(object == null ? void 0 : object.features))
          obj.features = object.features.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseVersion();
        message.identifier = object.identifier ?? "";
        message.features = ((_a2 = object.features) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxExpectedTimePerBlock: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.connection.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxExpectedTimePerBlock !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxExpectedTimePerBlock = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxExpectedTimePerBlock))
          obj.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== void 0 && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxExpectedTimePerBlock !== void 0 && object.maxExpectedTimePerBlock !== null) {
          message.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx12 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;
    var connection_1 = require_connection();
    var any_1 = require_any();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    function createBaseMsgConnectionOpenInit() {
      return {
        clientId: "",
        counterparty: connection_1.Counterparty.fromPartial({}),
        version: void 0,
        delayPeriod: BigInt(0),
        signer: ""
      };
    }
    exports.MsgConnectionOpenInit = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenInit();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = object.clientId ?? "";
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenInitResponse() {
      return {};
    }
    exports.MsgConnectionOpenInitResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTry() {
      return {
        clientId: "",
        previousConnectionId: "",
        clientState: void 0,
        counterparty: connection_1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0),
        counterpartyVersions: [],
        proofHeight: client_1.Height.fromPartial({}),
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports.MsgConnectionOpenTry = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v of message.counterpartyVersions) {
          connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(106).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            case 13:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenTry();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.previousConnectionId))
          obj.previousConnectionId = String(object.previousConnectionId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if (Array.isArray(object == null ? void 0 : object.counterpartyVersions))
          obj.counterpartyVersions = object.counterpartyVersions.map((e) => connection_1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = object.clientId ?? "";
        message.previousConnectionId = object.previousConnectionId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.counterpartyVersions = ((_a2 = object.counterpartyVersions) == null ? void 0 : _a2.map((e) => connection_1.Version.fromPartial(e))) || [];
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofInit = object.proofInit ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTryResponse() {
      return {};
    }
    exports.MsgConnectionOpenTryResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenTryResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAck() {
      return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: void 0,
        clientState: void 0,
        proofHeight: client_1.Height.fromPartial({}),
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports.MsgConnectionOpenAck = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(90).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            case 11:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenAck();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.counterpartyConnectionId))
          obj.counterpartyConnectionId = String(object.counterpartyConnectionId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = object.connectionId ?? "";
        message.counterpartyConnectionId = object.counterpartyConnectionId ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofTry = object.proofTry ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAckResponse() {
      return {};
    }
    exports.MsgConnectionOpenAckResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirm() {
      return {
        connectionId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgConnectionOpenConfirm = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenConfirm();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = object.connectionId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirmResponse() {
      return {};
    }
    exports.MsgConnectionOpenConfirmResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
        this.UpdateConnectionParams = this.UpdateConnectionParams.bind(this);
      }
      ConnectionOpenInit(request) {
        const data2 = exports.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data2);
        return promise.then((data3) => exports.MsgConnectionOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenTry(request) {
        const data2 = exports.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data2);
        return promise.then((data3) => exports.MsgConnectionOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenAck(request) {
        const data2 = exports.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data2);
        return promise.then((data3) => exports.MsgConnectionOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenConfirm(request) {
        const data2 = exports.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data2);
        return promise.then((data3) => exports.MsgConnectionOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateConnectionParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "UpdateConnectionParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ibcTypes = void 0;
    exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.DenomTrace = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseDenomTrace() {
      return {
        path: "",
        baseDenom: ""
      };
    }
    exports.DenomTrace = {
      typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomTrace();
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.baseDenom))
          obj.baseDenom = String(object.baseDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomTrace();
        message.path = object.path ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        sendEnabled: false,
        receiveEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/ibc.applications.transfer.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.sendEnabled))
          obj.sendEnabled = Boolean(object.sendEnabled);
        if ((0, helpers_1.isSet)(object.receiveEnabled))
          obj.receiveEnabled = Boolean(object.receiveEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled ?? false;
        message.receiveEnabled = object.receiveEnabled ?? false;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query7 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryTotalEscrowForDenomResponse = exports.QueryTotalEscrowForDenomRequest = exports.QueryEscrowAddressResponse = exports.QueryEscrowAddressRequest = exports.QueryDenomHashResponse = exports.QueryDenomHashRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryDenomTracesResponse = exports.QueryDenomTracesRequest = exports.QueryDenomTraceResponse = exports.QueryDenomTraceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var transfer_1 = require_transfer();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseQueryDenomTraceRequest() {
      return {
        hash: ""
      };
    }
    exports.QueryDenomTraceRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryDenomTraceResponse() {
      return {
        denomTrace: void 0
      };
    }
    exports.QueryDenomTraceResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceResponse();
        if ((0, helpers_1.isSet)(object.denomTrace))
          obj.denomTrace = transfer_1.DenomTrace.fromJSON(object.denomTrace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceResponse();
        if (object.denomTrace !== void 0 && object.denomTrace !== null) {
          message.denomTrace = transfer_1.DenomTrace.fromPartial(object.denomTrace);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryDenomTracesRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesResponse() {
      return {
        denomTraces: [],
        pagination: void 0
      };
    }
    exports.QueryDenomTracesResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomTraces) {
          transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesResponse();
        if (Array.isArray(object == null ? void 0 : object.denomTraces))
          obj.denomTraces = object.denomTraces.map((e) => transfer_1.DenomTrace.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = ((_a2 = object.denomTraces) == null ? void 0 : _a2.map((e) => transfer_1.DenomTrace.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = transfer_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = transfer_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomHashRequest() {
      return {
        trace: ""
      };
    }
    exports.QueryDenomHashRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.trace !== "") {
          writer.uint32(10).string(message.trace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.trace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashRequest();
        if ((0, helpers_1.isSet)(object.trace))
          obj.trace = String(object.trace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.trace !== void 0 && (obj.trace = message.trace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashRequest();
        message.trace = object.trace ?? "";
        return message;
      }
    };
    function createBaseQueryDenomHashResponse() {
      return {
        hash: ""
      };
    }
    exports.QueryDenomHashResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashResponse();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashResponse();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryEscrowAddressRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressResponse() {
      return {
        escrowAddress: ""
      };
    }
    exports.QueryEscrowAddressResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.escrowAddress !== "") {
          writer.uint32(10).string(message.escrowAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.escrowAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressResponse();
        if ((0, helpers_1.isSet)(object.escrowAddress))
          obj.escrowAddress = String(object.escrowAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.escrowAddress !== void 0 && (obj.escrowAddress = message.escrowAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressResponse();
        message.escrowAddress = object.escrowAddress ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryTotalEscrowForDenomRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomResponse() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.QueryTotalEscrowForDenomResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomResponse();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomResponse();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTraces = this.DenomTraces.bind(this);
        this.DenomTrace = this.DenomTrace.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
        this.EscrowAddress = this.EscrowAddress.bind(this);
        this.TotalEscrowForDenom = this.TotalEscrowForDenom.bind(this);
      }
      DenomTraces(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data2);
        return promise.then((data3) => exports.QueryDenomTracesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomTrace(request) {
        const data2 = exports.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data2);
        return promise.then((data3) => exports.QueryDenomTraceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomHash(request) {
        const data2 = exports.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data2);
        return promise.then((data3) => exports.QueryDenomHashResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EscrowAddress(request) {
        const data2 = exports.QueryEscrowAddressRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", data2);
        return promise.then((data3) => exports.QueryEscrowAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalEscrowForDenom(request) {
        const data2 = exports.QueryTotalEscrowForDenomRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "TotalEscrowForDenom", data2);
        return promise.then((data3) => exports.QueryTotalEscrowForDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query8 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryChannelParamsResponse = exports.QueryChannelParamsRequest = exports.QueryUpgradeResponse = exports.QueryUpgradeRequest = exports.QueryUpgradeErrorResponse = exports.QueryUpgradeErrorRequest = exports.QueryNextSequenceSendResponse = exports.QueryNextSequenceSendRequest = exports.QueryNextSequenceReceiveResponse = exports.QueryNextSequenceReceiveRequest = exports.QueryUnreceivedAcksResponse = exports.QueryUnreceivedAcksRequest = exports.QueryUnreceivedPacketsResponse = exports.QueryUnreceivedPacketsRequest = exports.QueryPacketAcknowledgementsResponse = exports.QueryPacketAcknowledgementsRequest = exports.QueryPacketAcknowledgementResponse = exports.QueryPacketAcknowledgementRequest = exports.QueryPacketReceiptResponse = exports.QueryPacketReceiptRequest = exports.QueryPacketCommitmentsResponse = exports.QueryPacketCommitmentsRequest = exports.QueryPacketCommitmentResponse = exports.QueryPacketCommitmentRequest = exports.QueryChannelConsensusStateResponse = exports.QueryChannelConsensusStateRequest = exports.QueryChannelClientStateResponse = exports.QueryChannelClientStateRequest = exports.QueryConnectionChannelsResponse = exports.QueryConnectionChannelsRequest = exports.QueryChannelsResponse = exports.QueryChannelsRequest = exports.QueryChannelResponse = exports.QueryChannelRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var channel_1 = require_channel();
    var client_1 = require_client();
    var any_1 = require_any();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    function createBaseQueryChannelRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryChannelRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelResponse() {
      return {
        channel: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelResponse();
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelResponse();
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsResponse();
        if (Array.isArray(object == null ? void 0 : object.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryChannelsResponse();
        message.channels = ((_a2 = object.channels) == null ? void 0 : _a2.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsRequest() {
      return {
        connection: "",
        pagination: void 0
      };
    }
    exports.QueryConnectionChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsRequest();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = String(object.connection);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = object.connection ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsResponse();
        if (Array.isArray(object == null ? void 0 : object.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = ((_a2 = object.channels) == null ? void 0 : _a2.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryChannelClientStateRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryChannelClientStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelClientStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateRequest() {
      return {
        portId: "",
        channelId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.QueryChannelConsensusStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelConsensusStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketCommitmentRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentResponse() {
      return {
        commitment: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketCommitmentResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentResponse();
        if ((0, helpers_1.isSet)(object.commitment))
          obj.commitment = (0, helpers_1.bytesFromBase64)(object.commitment);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = (0, helpers_1.base64FromBytes)(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = object.commitment ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0
      };
    }
    exports.QueryPacketCommitmentsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsResponse() {
      return {
        commitments: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketCommitmentsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commitments) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsResponse();
        if (Array.isArray(object == null ? void 0 : object.commitments))
          obj.commitments = object.commitments.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = ((_a2 = object.commitments) == null ? void 0 : _a2.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketReceiptRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptResponse() {
      return {
        received: false,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketReceiptResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptResponse();
        if ((0, helpers_1.isSet)(object.received))
          obj.received = Boolean(object.received);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptResponse();
        message.received = object.received ?? false;
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketAcknowledgementRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementResponse() {
      return {
        acknowledgement: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0,
        packetCommitmentSequences: []
      };
    }
    exports.QueryPacketAcknowledgementsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if (Array.isArray(object == null ? void 0 : object.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.packetCommitmentSequences = ((_a2 = object.packetCommitmentSequences) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsResponse() {
      return {
        acknowledgements: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.acknowledgements) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsResponse();
        if (Array.isArray(object == null ? void 0 : object.acknowledgements))
          obj.acknowledgements = object.acknowledgements.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = ((_a2 = object.acknowledgements) == null ? void 0 : _a2.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsRequest() {
      return {
        portId: "",
        channelId: "",
        packetCommitmentSequences: []
      };
    }
    exports.QueryUnreceivedPacketsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object == null ? void 0 : object.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetCommitmentSequences = ((_a2 = object.packetCommitmentSequences) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUnreceivedPacketsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsResponse();
        if (Array.isArray(object == null ? void 0 : object.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = ((_a2 = object.sequences) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksRequest() {
      return {
        portId: "",
        channelId: "",
        packetAckSequences: []
      };
    }
    exports.QueryUnreceivedAcksRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object == null ? void 0 : object.packetAckSequences))
          obj.packetAckSequences = object.packetAckSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetAckSequences = ((_a2 = object.packetAckSequences) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUnreceivedAcksResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksResponse();
        if (Array.isArray(object == null ? void 0 : object.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = ((_a2 = object.sequences) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryNextSequenceReceiveRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveResponse() {
      return {
        nextSequenceReceive: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryNextSequenceReceiveResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceReceive !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceReceive))
          obj.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveResponse();
        if (object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null) {
          message.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceSendRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryNextSequenceSendRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceSendResponse() {
      return {
        nextSequenceSend: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryNextSequenceSendResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceSend);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceSend = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendResponse();
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeErrorRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryUpgradeErrorRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeErrorResponse() {
      return {
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUpgradeErrorResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorResponse();
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorResponse();
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryUpgradeRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUpgradeResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelParamsRequest() {
      return {};
    }
    exports.QueryChannelParamsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryChannelParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryChannelParamsRequest();
        return message;
      }
    };
    function createBaseQueryChannelParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryChannelParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
        this.NextSequenceSend = this.NextSequenceSend.bind(this);
        this.UpgradeError = this.UpgradeError.bind(this);
        this.Upgrade = this.Upgrade.bind(this);
        this.ChannelParams = this.ChannelParams.bind(this);
      }
      Channel(request) {
        const data2 = exports.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data2);
        return promise.then((data3) => exports.QueryChannelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Channels(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data2);
        return promise.then((data3) => exports.QueryChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionChannels(request) {
        const data2 = exports.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data2);
        return promise.then((data3) => exports.QueryConnectionChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelClientState(request) {
        const data2 = exports.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data2);
        return promise.then((data3) => exports.QueryChannelClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelConsensusState(request) {
        const data2 = exports.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data2);
        return promise.then((data3) => exports.QueryChannelConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitment(request) {
        const data2 = exports.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data2);
        return promise.then((data3) => exports.QueryPacketCommitmentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitments(request) {
        const data2 = exports.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data2);
        return promise.then((data3) => exports.QueryPacketCommitmentsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketReceipt(request) {
        const data2 = exports.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data2);
        return promise.then((data3) => exports.QueryPacketReceiptResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgement(request) {
        const data2 = exports.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data2);
        return promise.then((data3) => exports.QueryPacketAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgements(request) {
        const data2 = exports.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data2);
        return promise.then((data3) => exports.QueryPacketAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedPackets(request) {
        const data2 = exports.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data2);
        return promise.then((data3) => exports.QueryUnreceivedPacketsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedAcks(request) {
        const data2 = exports.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data2);
        return promise.then((data3) => exports.QueryUnreceivedAcksResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceReceive(request) {
        const data2 = exports.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data2);
        return promise.then((data3) => exports.QueryNextSequenceReceiveResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceSend(request) {
        const data2 = exports.QueryNextSequenceSendRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceSend", data2);
        return promise.then((data3) => exports.QueryNextSequenceSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeError(request) {
        const data2 = exports.QueryUpgradeErrorRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UpgradeError", data2);
        return promise.then((data3) => exports.QueryUpgradeErrorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Upgrade(request) {
        const data2 = exports.QueryUpgradeRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Upgrade", data2);
        return promise.then((data3) => exports.QueryUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelParams(request = {}) {
        const data2 = exports.QueryChannelParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelParams", data2);
        return promise.then((data3) => exports.QueryChannelParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query9 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryVerifyMembershipResponse = exports.QueryVerifyMembershipRequest = exports.QueryUpgradedConsensusStateResponse = exports.QueryUpgradedConsensusStateRequest = exports.QueryUpgradedClientStateResponse = exports.QueryUpgradedClientStateRequest = exports.QueryClientParamsResponse = exports.QueryClientParamsRequest = exports.QueryClientStatusResponse = exports.QueryClientStatusRequest = exports.QueryConsensusStateHeightsResponse = exports.QueryConsensusStateHeightsRequest = exports.QueryConsensusStatesResponse = exports.QueryConsensusStatesRequest = exports.QueryConsensusStateResponse = exports.QueryConsensusStateRequest = exports.QueryClientStatesResponse = exports.QueryClientStatesRequest = exports.QueryClientStateResponse = exports.QueryClientStateRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var client_1 = require_client();
    var commitment_1 = require_commitment();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseQueryClientStateRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStateResponse() {
      return {
        clientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateResponse();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateResponse();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryClientStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesResponse() {
      return {
        clientStates: [],
        pagination: void 0
      };
    }
    exports.QueryClientStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.clientStates) {
          client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesResponse();
        if (Array.isArray(object == null ? void 0 : object.clientStates))
          obj.clientStates = object.clientStates.map((e) => client_1.IdentifiedClientState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = ((_a2 = object.clientStates) == null ? void 0 : _a2.map((e) => client_1.IdentifiedClientState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateRequest() {
      return {
        clientId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0),
        latestHeight: false
      };
    }
    exports.QueryConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = Boolean(object.latestHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = object.clientId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        message.latestHeight = object.latestHeight ?? false;
        return message;
      }
    };
    function createBaseQueryConsensusStateResponse() {
      return {
        consensusState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports.QueryConsensusStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesResponse() {
      return {
        consensusStates: [],
        pagination: void 0
      };
    }
    exports.QueryConsensusStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesResponse();
        if (Array.isArray(object == null ? void 0 : object.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => client_1.ConsensusStateWithHeight.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = ((_a2 = object.consensusStates) == null ? void 0 : _a2.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports.QueryConsensusStateHeightsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsResponse() {
      return {
        consensusStateHeights: [],
        pagination: void 0
      };
    }
    exports.QueryConsensusStateHeightsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStateHeights) {
          client_1.Height.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStateHeights.push(client_1.Height.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsResponse();
        if (Array.isArray(object == null ? void 0 : object.consensusStateHeights))
          obj.consensusStateHeights = object.consensusStateHeights.map((e) => client_1.Height.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStateHeights) {
          obj.consensusStateHeights = message.consensusStateHeights.map((e) => e ? client_1.Height.toJSON(e) : void 0);
        } else {
          obj.consensusStateHeights = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryConsensusStateHeightsResponse();
        message.consensusStateHeights = ((_a2 = object.consensusStateHeights) == null ? void 0 : _a2.map((e) => client_1.Height.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatusRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientStatusRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStatusResponse() {
      return {
        status: ""
      };
    }
    exports.QueryClientStatusResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusResponse();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusResponse();
        message.status = object.status ?? "";
        return message;
      }
    };
    function createBaseQueryClientParamsRequest() {
      return {};
    }
    exports.QueryClientParamsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryClientParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryClientParamsRequest();
        return message;
      }
    };
    function createBaseQueryClientParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryClientParamsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateRequest() {
      return {};
    }
    exports.QueryUpgradedClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedClientStateRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateResponse() {
      return {
        upgradedClientState: void 0
      };
    }
    exports.QueryUpgradedClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedClientStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateRequest() {
      return {};
    }
    exports.QueryUpgradedConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedConsensusStateRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedConsensusStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateResponse() {
      return {
        upgradedConsensusState: void 0
      };
    }
    exports.QueryUpgradedConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedConsensusState !== void 0) {
          any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedConsensusState))
          obj.upgradedConsensusState = any_1.Any.fromJSON(object.upgradedConsensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedConsensusState !== void 0 && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedConsensusStateResponse();
        if (object.upgradedConsensusState !== void 0 && object.upgradedConsensusState !== null) {
          message.upgradedConsensusState = any_1.Any.fromPartial(object.upgradedConsensusState);
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipRequest() {
      return {
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        merklePath: commitment_1.MerklePath.fromPartial({}),
        value: new Uint8Array(),
        timeDelay: BigInt(0),
        blockDelay: BigInt(0)
      };
    }
    exports.QueryVerifyMembershipRequest = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.merklePath !== void 0) {
          commitment_1.MerklePath.encode(message.merklePath, writer.uint32(34).fork()).ldelim();
        }
        if (message.value.length !== 0) {
          writer.uint32(42).bytes(message.value);
        }
        if (message.timeDelay !== BigInt(0)) {
          writer.uint32(48).uint64(message.timeDelay);
        }
        if (message.blockDelay !== BigInt(0)) {
          writer.uint32(56).uint64(message.blockDelay);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.merklePath = commitment_1.MerklePath.decode(reader, reader.uint32());
              break;
            case 5:
              message.value = reader.bytes();
              break;
            case 6:
              message.timeDelay = reader.uint64();
              break;
            case 7:
              message.blockDelay = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.merklePath))
          obj.merklePath = commitment_1.MerklePath.fromJSON(object.merklePath);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.timeDelay))
          obj.timeDelay = BigInt(object.timeDelay.toString());
        if ((0, helpers_1.isSet)(object.blockDelay))
          obj.blockDelay = BigInt(object.blockDelay.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.merklePath !== void 0 && (obj.merklePath = message.merklePath ? commitment_1.MerklePath.toJSON(message.merklePath) : void 0);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.timeDelay !== void 0 && (obj.timeDelay = (message.timeDelay || BigInt(0)).toString());
        message.blockDelay !== void 0 && (obj.blockDelay = (message.blockDelay || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipRequest();
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.merklePath !== void 0 && object.merklePath !== null) {
          message.merklePath = commitment_1.MerklePath.fromPartial(object.merklePath);
        }
        message.value = object.value ?? new Uint8Array();
        if (object.timeDelay !== void 0 && object.timeDelay !== null) {
          message.timeDelay = BigInt(object.timeDelay.toString());
        }
        if (object.blockDelay !== void 0 && object.blockDelay !== null) {
          message.blockDelay = BigInt(object.blockDelay.toString());
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipResponse() {
      return {
        success: false
      };
    }
    exports.QueryVerifyMembershipResponse = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.success === true) {
          writer.uint32(8).bool(message.success);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.success = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipResponse();
        if ((0, helpers_1.isSet)(object.success))
          obj.success = Boolean(object.success);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.success !== void 0 && (obj.success = message.success);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipResponse();
        message.success = object.success ?? false;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
        this.VerifyMembership = this.VerifyMembership.bind(this);
      }
      ClientState(request) {
        const data2 = exports.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data2);
        return promise.then((data3) => exports.QueryClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStates(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data2);
        return promise.then((data3) => exports.QueryClientStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusState(request) {
        const data2 = exports.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data2);
        return promise.then((data3) => exports.QueryConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStates(request) {
        const data2 = exports.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data2);
        return promise.then((data3) => exports.QueryConsensusStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStateHeights(request) {
        const data2 = exports.QueryConsensusStateHeightsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", data2);
        return promise.then((data3) => exports.QueryConsensusStateHeightsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStatus(request) {
        const data2 = exports.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data2);
        return promise.then((data3) => exports.QueryClientStatusResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientParams(request = {}) {
        const data2 = exports.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data2);
        return promise.then((data3) => exports.QueryClientParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedClientState(request = {}) {
        const data2 = exports.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data2);
        return promise.then((data3) => exports.QueryUpgradedClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedConsensusState(request = {}) {
        const data2 = exports.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data2);
        return promise.then((data3) => exports.QueryUpgradedConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VerifyMembership(request) {
        const data2 = exports.QueryVerifyMembershipRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "VerifyMembership", data2);
        return promise.then((data3) => exports.QueryVerifyMembershipResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query10 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryConnectionParamsResponse = exports.QueryConnectionParamsRequest = exports.QueryConnectionConsensusStateResponse = exports.QueryConnectionConsensusStateRequest = exports.QueryConnectionClientStateResponse = exports.QueryConnectionClientStateRequest = exports.QueryClientConnectionsResponse = exports.QueryClientConnectionsRequest = exports.QueryConnectionsResponse = exports.QueryConnectionsRequest = exports.QueryConnectionResponse = exports.QueryConnectionRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var connection_1 = require_connection();
    var client_1 = require_client();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    function createBaseQueryConnectionRequest() {
      return {
        connectionId: ""
      };
    }
    exports.QueryConnectionRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionResponse() {
      return {
        connection: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionResponse();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = connection_1.ConnectionEnd.fromJSON(object.connection);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionResponse();
        if (object.connection !== void 0 && object.connection !== null) {
          message.connection = connection_1.ConnectionEnd.fromPartial(object.connection);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsResponse() {
      return {
        connections: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connections) {
          connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsResponse();
        if (Array.isArray(object == null ? void 0 : object.connections))
          obj.connections = object.connections.map((e) => connection_1.IdentifiedConnection.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryConnectionsResponse();
        message.connections = ((_a2 = object.connections) == null ? void 0 : _a2.map((e) => connection_1.IdentifiedConnection.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryClientConnectionsRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientConnectionsResponse() {
      return {
        connectionPaths: [],
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryClientConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connectionPaths) {
          writer.uint32(10).string(v);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsResponse();
        if (Array.isArray(object == null ? void 0 : object.connectionPaths))
          obj.connectionPaths = object.connectionPaths.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = ((_a2 = object.connectionPaths) == null ? void 0 : _a2.map((e) => e)) || [];
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionClientStateRequest() {
      return {
        connectionId: ""
      };
    }
    exports.QueryConnectionClientStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionClientStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateRequest() {
      return {
        connectionId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.QueryConnectionConsensusStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = object.connectionId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionConsensusStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionParamsRequest() {
      return {};
    }
    exports.QueryConnectionParamsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryConnectionParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryConnectionParamsRequest();
        return message;
      }
    };
    function createBaseQueryConnectionParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryConnectionParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
        this.ConnectionParams = this.ConnectionParams.bind(this);
      }
      Connection(request) {
        const data2 = exports.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data2);
        return promise.then((data3) => exports.QueryConnectionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Connections(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data2);
        return promise.then((data3) => exports.QueryConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientConnections(request) {
        const data2 = exports.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data2);
        return promise.then((data3) => exports.QueryClientConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionClientState(request) {
        const data2 = exports.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data2);
        return promise.then((data3) => exports.QueryConnectionClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionConsensusState(request) {
        const data2 = exports.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data2);
        return promise.then((data3) => exports.QueryConnectionConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionParams(request = {}) {
        const data2 = exports.QueryConnectionParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", data2);
        return promise.then((data3) => exports.QueryConnectionParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return {
        total: BigInt(0),
        index: BigInt(0),
        leafHash: new Uint8Array(),
        aunts: []
      };
    }
    exports.Proof = {
      typeUrl: "/tendermint.crypto.Proof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== BigInt(0)) {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProof();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.leafHash))
          obj.leafHash = (0, helpers_1.bytesFromBase64)(object.leafHash);
        if (Array.isArray(object == null ? void 0 : object.aunts))
          obj.aunts = object.aunts.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.leafHash !== void 0 && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseProof();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.leafHash = object.leafHash ?? new Uint8Array();
        message.aunts = ((_a2 = object.aunts) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return {
        key: new Uint8Array(),
        proof: void 0
      };
    }
    exports.ValueOp = {
      typeUrl: "/tendermint.crypto.ValueOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValueOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = exports.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = exports.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseDominoOp() {
      return {
        key: "",
        input: "",
        output: ""
      };
    }
    exports.DominoOp = {
      typeUrl: "/tendermint.crypto.DominoOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDominoOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.input))
          obj.input = String(object.input);
        if ((0, helpers_1.isSet)(object.output))
          obj.output = String(object.output);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
      }
    };
    function createBaseProofOp() {
      return {
        type: "",
        key: new Uint8Array(),
        data: new Uint8Array()
      };
    }
    exports.ProofOp = {
      typeUrl: "/tendermint.crypto.ProofOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOp();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOp();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return {
        ops: []
      };
    }
    exports.ProofOps = {
      typeUrl: "/tendermint.crypto.ProofOps",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.ops) {
          exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOps();
        if (Array.isArray(object == null ? void 0 : object.ops))
          obj.ops = object.ops.map((e) => exports.ProofOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseProofOps();
        message.ops = ((_a2 = object.ops) == null ? void 0 : _a2.map((e) => exports.ProofOp.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/version/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/version/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Consensus = exports.App = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return {
        protocol: BigInt(0),
        software: ""
      };
    }
    exports.App = {
      typeUrl: "/tendermint.version.App",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.protocol !== BigInt(0)) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseApp();
        if ((0, helpers_1.isSet)(object.protocol))
          obj.protocol = BigInt(object.protocol.toString());
        if ((0, helpers_1.isSet)(object.software))
          obj.software = String(object.software);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || BigInt(0)).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseApp();
        if (object.protocol !== void 0 && object.protocol !== null) {
          message.protocol = BigInt(object.protocol.toString());
        }
        message.software = object.software ?? "";
        return message;
      }
    };
    function createBaseConsensus() {
      return {
        block: BigInt(0),
        app: BigInt(0)
      };
    }
    exports.Consensus = {
      typeUrl: "/tendermint.version.Consensus",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== BigInt(0)) {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== BigInt(0)) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensus();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = BigInt(object.block.toString());
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || BigInt(0)).toString());
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensus();
        if (object.block !== void 0 && object.block !== null) {
          message.block = BigInt(object.block.toString());
        }
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return {
        ed25519: void 0,
        secp256k1: void 0
      };
    }
    exports.PublicKey = {
      typeUrl: "/tendermint.crypto.PublicKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePublicKey();
        if ((0, helpers_1.isSet)(object.ed25519))
          obj.ed25519 = (0, helpers_1.bytesFromBase64)(object.ed25519);
        if ((0, helpers_1.isSet)(object.secp256k1))
          obj.secp256k1 = (0, helpers_1.bytesFromBase64)(object.secp256k1);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? (0, helpers_1.base64FromBytes)(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? (0, helpers_1.base64FromBytes)(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? void 0;
        message.secp256k1 = object.secp256k1 ?? void 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;
    var keys_1 = require_keys4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag || (exports.BlockIDFlag = BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.blockIDFlagToJSON = blockIDFlagToJSON;
    function createBaseValidatorSet() {
      return {
        validators: [],
        proposer: void 0,
        totalVotingPower: BigInt(0)
      };
    }
    exports.ValidatorSet = {
      typeUrl: "/tendermint.types.ValidatorSet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          exports.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSet();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = exports.Validator.fromJSON(object.proposer);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorSet();
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => exports.Validator.fromPartial(e))) || [];
        if (object.proposer !== void 0 && object.proposer !== null) {
          message.proposer = exports.Validator.fromPartial(object.proposer);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: keys_1.PublicKey.fromPartial({}),
        votingPower: BigInt(0),
        proposerPriority: BigInt(0)
      };
    }
    exports.Validator = {
      typeUrl: "/tendermint.types.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== BigInt(0)) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        if ((0, helpers_1.isSet)(object.proposerPriority))
          obj.proposerPriority = BigInt(object.proposerPriority.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        if (object.proposerPriority !== void 0 && object.proposerPriority !== null) {
          message.proposerPriority = BigInt(object.proposerPriority.toString());
        }
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return {
        pubKey: void 0,
        votingPower: BigInt(0)
      };
    }
    exports.SimpleValidator = {
      typeUrl: "/tendermint.types.SimpleValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimpleValidator();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimpleValidator();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.ExtendedCommitSig = exports.ExtendedCommit = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.protobufPackage = void 0;
    var proof_1 = require_proof();
    var types_1 = require_types2();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType || (exports.SignedMsgType = SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return {
        total: 0,
        hash: new Uint8Array()
      };
    }
    exports.PartSetHeader = {
      typeUrl: "/tendermint.types.PartSetHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePartSetHeader();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = Number(object.total);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePartSetHeader();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return {
        index: 0,
        bytes: new Uint8Array(),
        proof: proof_1.Proof.fromPartial({})
      };
    }
    exports.Part = {
      typeUrl: "/tendermint.types.Part",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePart();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.bytes))
          obj.bytes = (0, helpers_1.bytesFromBase64)(object.bytes);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseBlockID() {
      return {
        hash: new Uint8Array(),
        partSetHeader: exports.PartSetHeader.fromPartial({})
      };
    }
    exports.BlockID = {
      typeUrl: "/tendermint.types.BlockID",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockID();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.partSetHeader))
          obj.partSetHeader = exports.PartSetHeader.fromJSON(object.partSetHeader);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockID();
        message.hash = object.hash ?? new Uint8Array();
        if (object.partSetHeader !== void 0 && object.partSetHeader !== null) {
          message.partSetHeader = exports.PartSetHeader.fromPartial(object.partSetHeader);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: types_1.Consensus.fromPartial({}),
        chainId: "",
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        lastBlockId: exports.BlockID.fromPartial({}),
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.Header = {
      typeUrl: "/tendermint.types.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = types_1.Consensus.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.lastBlockId))
          obj.lastBlockId = exports.BlockID.fromJSON(object.lastBlockId);
        if ((0, helpers_1.isSet)(object.lastCommitHash))
          obj.lastCommitHash = (0, helpers_1.bytesFromBase64)(object.lastCommitHash);
        if ((0, helpers_1.isSet)(object.dataHash))
          obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.validatorsHash))
          obj.validatorsHash = (0, helpers_1.bytesFromBase64)(object.validatorsHash);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.consensusHash))
          obj.consensusHash = (0, helpers_1.bytesFromBase64)(object.consensusHash);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        if ((0, helpers_1.isSet)(object.lastResultsHash))
          obj.lastResultsHash = (0, helpers_1.bytesFromBase64)(object.lastResultsHash);
        if ((0, helpers_1.isSet)(object.evidenceHash))
          obj.evidenceHash = (0, helpers_1.bytesFromBase64)(object.evidenceHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.version !== void 0 && object.version !== null) {
          message.version = types_1.Consensus.fromPartial(object.version);
        }
        message.chainId = object.chainId ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.lastBlockId !== void 0 && object.lastBlockId !== null) {
          message.lastBlockId = exports.BlockID.fromPartial(object.lastBlockId);
        }
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.consensusHash = object.consensusHash ?? new Uint8Array();
        message.appHash = object.appHash ?? new Uint8Array();
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return {
        txs: []
      };
    }
    exports.Data = {
      typeUrl: "/tendermint.types.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseData();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseData();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports.Vote = {
      typeUrl: "/tendermint.types.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(74).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(82).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            case 9:
              message.extension = reader.bytes();
              break;
            case 10:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.validatorIndex))
          obj.validatorIndex = Number(object.validatorIndex);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        signatures: []
      };
    }
    exports.Commit = {
      typeUrl: "/tendermint.types.Commit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports.CommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        message.signatures = ((_a2 = object.signatures) == null ? void 0 : _a2.map((e) => exports.CommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports.CommitSig = {
      typeUrl: "/tendermint.types.CommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseExtendedCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        extendedSignatures: []
      };
    }
    exports.ExtendedCommit = {
      typeUrl: "/tendermint.types.ExtendedCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.extendedSignatures) {
          exports.ExtendedCommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.extendedSignatures.push(exports.ExtendedCommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object == null ? void 0 : object.extendedSignatures))
          obj.extendedSignatures = object.extendedSignatures.map((e) => exports.ExtendedCommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.extendedSignatures) {
          obj.extendedSignatures = message.extendedSignatures.map((e) => e ? exports.ExtendedCommitSig.toJSON(e) : void 0);
        } else {
          obj.extendedSignatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseExtendedCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        message.extendedSignatures = ((_a2 = object.extendedSignatures) == null ? void 0 : _a2.map((e) => exports.ExtendedCommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseExtendedCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports.ExtendedCommitSig = {
      typeUrl: "/tendermint.types.ExtendedCommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(42).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(50).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            case 5:
              message.extension = reader.bytes();
              break;
            case 6:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        polRound: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports.Proposal = {
      typeUrl: "/tendermint.types.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.polRound))
          obj.polRound = Number(object.polRound);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return {
        header: void 0,
        commit: void 0
      };
    }
    exports.SignedHeader = {
      typeUrl: "/tendermint.types.SignedHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignedHeader();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.Commit.fromJSON(object.commit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader();
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports.Header.fromPartial(object.header);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.Commit.fromPartial(object.commit);
        }
        return message;
      }
    };
    function createBaseLightBlock() {
      return {
        signedHeader: void 0,
        validatorSet: void 0
      };
    }
    exports.LightBlock = {
      typeUrl: "/tendermint.types.LightBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightBlock();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = exports.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = exports.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        return message;
      }
    };
    function createBaseBlockMeta() {
      return {
        blockId: exports.BlockID.fromPartial({}),
        blockSize: BigInt(0),
        header: exports.Header.fromPartial({}),
        numTxs: BigInt(0)
      };
    }
    exports.BlockMeta = {
      typeUrl: "/tendermint.types.BlockMeta",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== BigInt(0)) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== BigInt(0)) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockMeta();
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.blockSize))
          obj.blockSize = BigInt(object.blockSize.toString());
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.numTxs))
          obj.numTxs = BigInt(object.numTxs.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || BigInt(0)).toString());
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockMeta();
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.blockSize !== void 0 && object.blockSize !== null) {
          message.blockSize = BigInt(object.blockSize.toString());
        }
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports.Header.fromPartial(object.header);
        }
        if (object.numTxs !== void 0 && object.numTxs !== null) {
          message.numTxs = BigInt(object.numTxs.toString());
        }
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports.TxProof = {
      typeUrl: "/tendermint.types.TxProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxProof();
        if ((0, helpers_1.isSet)(object.rootHash))
          obj.rootHash = (0, helpers_1.bytesFromBase64)(object.rootHash);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fraction = exports.Header = exports.Misbehaviour = exports.ConsensusState = exports.ClientState = exports.protobufPackage = void 0;
    var duration_1 = require_duration();
    var client_1 = require_client();
    var proofs_1 = require_proofs();
    var timestamp_1 = require_timestamp();
    var commitment_1 = require_commitment();
    var types_1 = require_types3();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.lightclients.tendermint.v1";
    function createBaseClientState() {
      return {
        chainId: "",
        trustLevel: exports.Fraction.fromPartial({}),
        trustingPeriod: duration_1.Duration.fromPartial({}),
        unbondingPeriod: duration_1.Duration.fromPartial({}),
        maxClockDrift: duration_1.Duration.fromPartial({}),
        frozenHeight: client_1.Height.fromPartial({}),
        latestHeight: client_1.Height.fromPartial({}),
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
      };
    }
    exports.ClientState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.upgradePath) {
          writer.uint32(74).string(v);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.trustLevel))
          obj.trustLevel = exports.Fraction.fromJSON(object.trustLevel);
        if ((0, helpers_1.isSet)(object.trustingPeriod))
          obj.trustingPeriod = duration_1.Duration.fromJSON(object.trustingPeriod);
        if ((0, helpers_1.isSet)(object.unbondingPeriod))
          obj.unbondingPeriod = duration_1.Duration.fromJSON(object.unbondingPeriod);
        if ((0, helpers_1.isSet)(object.maxClockDrift))
          obj.maxClockDrift = duration_1.Duration.fromJSON(object.maxClockDrift);
        if ((0, helpers_1.isSet)(object.frozenHeight))
          obj.frozenHeight = client_1.Height.fromJSON(object.frozenHeight);
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        if (Array.isArray(object == null ? void 0 : object.proofSpecs))
          obj.proofSpecs = object.proofSpecs.map((e) => proofs_1.ProofSpec.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.upgradePath))
          obj.upgradePath = object.upgradePath.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.allowUpdateAfterExpiry))
          obj.allowUpdateAfterExpiry = Boolean(object.allowUpdateAfterExpiry);
        if ((0, helpers_1.isSet)(object.allowUpdateAfterMisbehaviour))
          obj.allowUpdateAfterMisbehaviour = Boolean(object.allowUpdateAfterMisbehaviour);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseClientState();
        message.chainId = object.chainId ?? "";
        if (object.trustLevel !== void 0 && object.trustLevel !== null) {
          message.trustLevel = exports.Fraction.fromPartial(object.trustLevel);
        }
        if (object.trustingPeriod !== void 0 && object.trustingPeriod !== null) {
          message.trustingPeriod = duration_1.Duration.fromPartial(object.trustingPeriod);
        }
        if (object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null) {
          message.unbondingPeriod = duration_1.Duration.fromPartial(object.unbondingPeriod);
        }
        if (object.maxClockDrift !== void 0 && object.maxClockDrift !== null) {
          message.maxClockDrift = duration_1.Duration.fromPartial(object.maxClockDrift);
        }
        if (object.frozenHeight !== void 0 && object.frozenHeight !== null) {
          message.frozenHeight = client_1.Height.fromPartial(object.frozenHeight);
        }
        if (object.latestHeight !== void 0 && object.latestHeight !== null) {
          message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        }
        message.proofSpecs = ((_a2 = object.proofSpecs) == null ? void 0 : _a2.map((e) => proofs_1.ProofSpec.fromPartial(e))) || [];
        message.upgradePath = ((_b = object.upgradePath) == null ? void 0 : _b.map((e) => e)) || [];
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
        return message;
      }
    };
    function createBaseConsensusState() {
      return {
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        root: commitment_1.MerkleRoot.fromPartial({}),
        nextValidatorsHash: new Uint8Array()
      };
    }
    exports.ConsensusState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.root))
          obj.root = commitment_1.MerkleRoot.fromJSON(object.root);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusState();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        if (object.root !== void 0 && object.root !== null) {
          message.root = commitment_1.MerkleRoot.fromPartial(object.root);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehaviour() {
      return {
        clientId: "",
        header1: void 0,
        header2: void 0
      };
    }
    exports.Misbehaviour = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.header1))
          obj.header1 = exports.Header.fromJSON(object.header1);
        if ((0, helpers_1.isSet)(object.header2))
          obj.header2 = exports.Header.fromJSON(object.header2);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.header1 !== void 0 && object.header1 !== null) {
          message.header1 = exports.Header.fromPartial(object.header1);
        }
        if (object.header2 !== void 0 && object.header2 !== null) {
          message.header2 = exports.Header.fromPartial(object.header2);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        signedHeader: void 0,
        validatorSet: void 0,
        trustedHeight: client_1.Height.fromPartial({}),
        trustedValidators: void 0
      };
    }
    exports.Header = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = types_1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        if ((0, helpers_1.isSet)(object.trustedHeight))
          obj.trustedHeight = client_1.Height.fromJSON(object.trustedHeight);
        if ((0, helpers_1.isSet)(object.trustedValidators))
          obj.trustedValidators = validator_1.ValidatorSet.fromJSON(object.trustedValidators);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = types_1.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        if (object.trustedHeight !== void 0 && object.trustedHeight !== null) {
          message.trustedHeight = client_1.Height.fromPartial(object.trustedHeight);
        }
        if (object.trustedValidators !== void 0 && object.trustedValidators !== null) {
          message.trustedValidators = validator_1.ValidatorSet.fromPartial(object.trustedValidators);
        }
        return message;
      }
    };
    function createBaseFraction() {
      return {
        numerator: BigInt(0),
        denominator: BigInt(0)
      };
    }
    exports.Fraction = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.numerator !== BigInt(0)) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (message.denominator !== BigInt(0)) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFraction();
        if ((0, helpers_1.isSet)(object.numerator))
          obj.numerator = BigInt(object.numerator.toString());
        if ((0, helpers_1.isSet)(object.denominator))
          obj.denominator = BigInt(object.denominator.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || BigInt(0)).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFraction();
        if (object.numerator !== void 0 && object.numerator !== null) {
          message.numerator = BigInt(object.numerator.toString());
        }
        if (object.denominator !== void 0 && object.denominator !== null) {
          message.denominator = BigInt(object.denominator.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupIbcExtension = setupIbcExtension;
    var query_1 = require_query7();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a2;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a2;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a2;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a2;
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => BigInt(s))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => BigInt(s))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a2;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a2;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a2;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight == null ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight == null ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a2;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash2) => transferQueryService.DenomTrace({ hash: hash2 }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a2;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a2 = response.pagination) == null ? void 0 : _a2.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Minter = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseMinter() {
      return {
        inflation: "",
        annualProvisions: ""
      };
    }
    exports.Minter = {
      typeUrl: "/cosmos.mint.v1beta1.Minter",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMinter();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMinter();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = String(object.inflation);
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = String(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMinter();
        message.inflation = object.inflation ?? "";
        message.annualProvisions = object.annualProvisions ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.mint.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (message.blocksPerYear !== BigInt(0)) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.mintDenom))
          obj.mintDenom = String(object.mintDenom);
        if ((0, helpers_1.isSet)(object.inflationRateChange))
          obj.inflationRateChange = String(object.inflationRateChange);
        if ((0, helpers_1.isSet)(object.inflationMax))
          obj.inflationMax = String(object.inflationMax);
        if ((0, helpers_1.isSet)(object.inflationMin))
          obj.inflationMin = String(object.inflationMin);
        if ((0, helpers_1.isSet)(object.goalBonded))
          obj.goalBonded = String(object.goalBonded);
        if ((0, helpers_1.isSet)(object.blocksPerYear))
          obj.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.mintDenom = object.mintDenom ?? "";
        message.inflationRateChange = object.inflationRateChange ?? "";
        message.inflationMax = object.inflationMax ?? "";
        message.inflationMin = object.inflationMin ?? "";
        message.goalBonded = object.goalBonded ?? "";
        if (object.blocksPerYear !== void 0 && object.blocksPerYear !== null) {
          message.blocksPerYear = BigInt(object.blocksPerYear.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query11 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAnnualProvisionsResponse = exports.QueryAnnualProvisionsRequest = exports.QueryInflationResponse = exports.QueryInflationRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var mint_1 = require_mint();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: mint_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = mint_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = mint_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryInflationRequest() {
      return {};
    }
    exports.QueryInflationRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryInflationRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryInflationRequest();
        return message;
      }
    };
    function createBaseQueryInflationResponse() {
      return {
        inflation: new Uint8Array()
      };
    }
    exports.QueryInflationResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryInflationResponse();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = (0, helpers_1.bytesFromBase64)(object.inflation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = (0, helpers_1.base64FromBytes)(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryInflationResponse();
        message.inflation = object.inflation ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsRequest() {
      return {};
    }
    exports.QueryAnnualProvisionsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryAnnualProvisionsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryAnnualProvisionsRequest();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsResponse() {
      return {
        annualProvisions: new Uint8Array()
      };
    }
    exports.QueryAnnualProvisionsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAnnualProvisionsResponse();
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = (0, helpers_1.bytesFromBase64)(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = (0, helpers_1.base64FromBytes)(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAnnualProvisionsResponse();
        message.annualProvisions = object.annualProvisions ?? new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Inflation(request = {}) {
        const data2 = exports.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data2);
        return promise.then((data3) => exports.QueryInflationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AnnualProvisions(request = {}) {
        const data2 = exports.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data2);
        return promise.then((data3) => exports.QueryAnnualProvisionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupMintExtension = setupMintExtension;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgUnjail = isAminoMsgUnjail;
    exports.createSlashingAminoConverters = createSlashingAminoConverters;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js
var require_slashing = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.ValidatorSigningInfo = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseValidatorSigningInfo() {
      return {
        address: "",
        startHeight: BigInt(0),
        indexOffset: BigInt(0),
        jailedUntil: timestamp_1.Timestamp.fromPartial({}),
        tombstoned: false,
        missedBlocksCounter: BigInt(0)
      };
    }
    exports.ValidatorSigningInfo = {
      typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.startHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.startHeight);
        }
        if (message.indexOffset !== BigInt(0)) {
          writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== void 0) {
          timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
          writer.uint32(40).bool(message.tombstoned);
        }
        if (message.missedBlocksCounter !== BigInt(0)) {
          writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.startHeight = reader.int64();
              break;
            case 3:
              message.indexOffset = reader.int64();
              break;
            case 4:
              message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.tombstoned = reader.bool();
              break;
            case 6:
              message.missedBlocksCounter = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSigningInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.startHeight))
          obj.startHeight = BigInt(object.startHeight.toString());
        if ((0, helpers_1.isSet)(object.indexOffset))
          obj.indexOffset = BigInt(object.indexOffset.toString());
        if ((0, helpers_1.isSet)(object.jailedUntil))
          obj.jailedUntil = (0, helpers_1.fromJsonTimestamp)(object.jailedUntil);
        if ((0, helpers_1.isSet)(object.tombstoned))
          obj.tombstoned = Boolean(object.tombstoned);
        if ((0, helpers_1.isSet)(object.missedBlocksCounter))
          obj.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.startHeight !== void 0 && (obj.startHeight = (message.startHeight || BigInt(0)).toString());
        message.indexOffset !== void 0 && (obj.indexOffset = (message.indexOffset || BigInt(0)).toString());
        message.jailedUntil !== void 0 && (obj.jailedUntil = (0, helpers_1.fromTimestamp)(message.jailedUntil).toISOString());
        message.tombstoned !== void 0 && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== void 0 && (obj.missedBlocksCounter = (message.missedBlocksCounter || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSigningInfo();
        message.address = object.address ?? "";
        if (object.startHeight !== void 0 && object.startHeight !== null) {
          message.startHeight = BigInt(object.startHeight.toString());
        }
        if (object.indexOffset !== void 0 && object.indexOffset !== null) {
          message.indexOffset = BigInt(object.indexOffset.toString());
        }
        if (object.jailedUntil !== void 0 && object.jailedUntil !== null) {
          message.jailedUntil = timestamp_1.Timestamp.fromPartial(object.jailedUntil);
        }
        message.tombstoned = object.tombstoned ?? false;
        if (object.missedBlocksCounter !== void 0 && object.missedBlocksCounter !== null) {
          message.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        signedBlocksWindow: BigInt(0),
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: duration_1.Duration.fromPartial({}),
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.slashing.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedBlocksWindow !== BigInt(0)) {
          writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
          writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== void 0) {
          duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
          writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
          writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedBlocksWindow = reader.int64();
              break;
            case 2:
              message.minSignedPerWindow = reader.bytes();
              break;
            case 3:
              message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.slashFractionDoubleSign = reader.bytes();
              break;
            case 5:
              message.slashFractionDowntime = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.signedBlocksWindow))
          obj.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        if ((0, helpers_1.isSet)(object.minSignedPerWindow))
          obj.minSignedPerWindow = (0, helpers_1.bytesFromBase64)(object.minSignedPerWindow);
        if ((0, helpers_1.isSet)(object.downtimeJailDuration))
          obj.downtimeJailDuration = duration_1.Duration.fromJSON(object.downtimeJailDuration);
        if ((0, helpers_1.isSet)(object.slashFractionDoubleSign))
          obj.slashFractionDoubleSign = (0, helpers_1.bytesFromBase64)(object.slashFractionDoubleSign);
        if ((0, helpers_1.isSet)(object.slashFractionDowntime))
          obj.slashFractionDowntime = (0, helpers_1.bytesFromBase64)(object.slashFractionDowntime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedBlocksWindow !== void 0 && (obj.signedBlocksWindow = (message.signedBlocksWindow || BigInt(0)).toString());
        message.minSignedPerWindow !== void 0 && (obj.minSignedPerWindow = (0, helpers_1.base64FromBytes)(message.minSignedPerWindow !== void 0 ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== void 0 && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : void 0);
        message.slashFractionDoubleSign !== void 0 && (obj.slashFractionDoubleSign = (0, helpers_1.base64FromBytes)(message.slashFractionDoubleSign !== void 0 ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== void 0 && (obj.slashFractionDowntime = (0, helpers_1.base64FromBytes)(message.slashFractionDowntime !== void 0 ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.signedBlocksWindow !== void 0 && object.signedBlocksWindow !== null) {
          message.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        }
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array();
        if (object.downtimeJailDuration !== void 0 && object.downtimeJailDuration !== null) {
          message.downtimeJailDuration = duration_1.Duration.fromPartial(object.downtimeJailDuration);
        }
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array();
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js
var require_query12 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QuerySigningInfosResponse = exports.QuerySigningInfosRequest = exports.QuerySigningInfoResponse = exports.QuerySigningInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var slashing_1 = require_slashing();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: slashing_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = slashing_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = slashing_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = slashing_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfoRequest() {
      return {
        consAddress: ""
      };
    }
    exports.QuerySigningInfoRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consAddress !== "") {
          writer.uint32(10).string(message.consAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoRequest();
        if ((0, helpers_1.isSet)(object.consAddress))
          obj.consAddress = String(object.consAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consAddress !== void 0 && (obj.consAddress = message.consAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = object.consAddress ?? "";
        return message;
      }
    };
    function createBaseQuerySigningInfoResponse() {
      return {
        valSigningInfo: slashing_1.ValidatorSigningInfo.fromPartial({})
      };
    }
    exports.QuerySigningInfoResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.valSigningInfo !== void 0) {
          slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoResponse();
        if ((0, helpers_1.isSet)(object.valSigningInfo))
          obj.valSigningInfo = slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.valSigningInfo !== void 0 && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse();
        if (object.valSigningInfo !== void 0 && object.valSigningInfo !== null) {
          message.valSigningInfo = slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QuerySigningInfosRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosResponse() {
      return {
        info: [],
        pagination: void 0
      };
    }
    exports.QuerySigningInfosResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.info) {
          slashing_1.ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosResponse();
        if (Array.isArray(object == null ? void 0 : object.info))
          obj.info = object.info.map((e) => slashing_1.ValidatorSigningInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? slashing_1.ValidatorSigningInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQuerySigningInfosResponse();
        message.info = ((_a2 = object.info) == null ? void 0 : _a2.map((e) => slashing_1.ValidatorSigningInfo.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfo(request) {
        const data2 = exports.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data2);
        return promise.then((data3) => exports.QuerySigningInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfos(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data2);
        return promise.then((data3) => exports.QuerySigningInfosResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupSlashingExtension = setupSlashingExtension;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protoDecimalToJson = protoDecimalToJson;
    exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
    exports.isAminoMsgDelegate = isAminoMsgDelegate;
    exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
    exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    exports.createStakingAminoConverters = createStakingAminoConverters;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ABCIParams = exports.HashedParams = exports.VersionParams = exports.ValidatorParams = exports.EvidenceParams = exports.BlockParams = exports.ConsensusParams = exports.protobufPackage = void 0;
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseConsensusParams() {
      return {
        block: void 0,
        evidence: void 0,
        validator: void 0,
        version: void 0,
        abci: void 0
      };
    }
    exports.ConsensusParams = {
      typeUrl: "/tendermint.types.ConsensusParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== void 0) {
          exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        if (message.abci !== void 0) {
          exports.ABCIParams.encode(message.abci, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports.VersionParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.abci = exports.ABCIParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusParams();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = exports.BlockParams.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = exports.EvidenceParams.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.ValidatorParams.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = exports.VersionParams.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.abci))
          obj.abci = exports.ABCIParams.fromJSON(object.abci);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports.VersionParams.toJSON(message.version) : void 0);
        message.abci !== void 0 && (obj.abci = message.abci ? exports.ABCIParams.toJSON(message.abci) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams();
        if (object.block !== void 0 && object.block !== null) {
          message.block = exports.BlockParams.fromPartial(object.block);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = exports.EvidenceParams.fromPartial(object.evidence);
        }
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.ValidatorParams.fromPartial(object.validator);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = exports.VersionParams.fromPartial(object.version);
        }
        if (object.abci !== void 0 && object.abci !== null) {
          message.abci = exports.ABCIParams.fromPartial(object.abci);
        }
        return message;
      }
    };
    function createBaseBlockParams() {
      return {
        maxBytes: BigInt(0),
        maxGas: BigInt(0)
      };
    }
    exports.BlockParams = {
      typeUrl: "/tendermint.types.BlockParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockParams();
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        if ((0, helpers_1.isSet)(object.maxGas))
          obj.maxGas = BigInt(object.maxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams();
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        if (object.maxGas !== void 0 && object.maxGas !== null) {
          message.maxGas = BigInt(object.maxGas.toString());
        }
        return message;
      }
    };
    function createBaseEvidenceParams() {
      return {
        maxAgeNumBlocks: BigInt(0),
        maxAgeDuration: duration_1.Duration.fromPartial({}),
        maxBytes: BigInt(0)
      };
    }
    exports.EvidenceParams = {
      typeUrl: "/tendermint.types.EvidenceParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxAgeNumBlocks !== BigInt(0)) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceParams();
        if ((0, helpers_1.isSet)(object.maxAgeNumBlocks))
          obj.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if ((0, helpers_1.isSet)(object.maxAgeDuration))
          obj.maxAgeDuration = duration_1.Duration.fromJSON(object.maxAgeDuration);
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || BigInt(0)).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceParams();
        if (object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null) {
          message.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        }
        if (object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null) {
          message.maxAgeDuration = duration_1.Duration.fromPartial(object.maxAgeDuration);
        }
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        return message;
      }
    };
    function createBaseValidatorParams() {
      return {
        pubKeyTypes: []
      };
    }
    exports.ValidatorParams = {
      typeUrl: "/tendermint.types.ValidatorParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pubKeyTypes) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorParams();
        if (Array.isArray(object == null ? void 0 : object.pubKeyTypes))
          obj.pubKeyTypes = object.pubKeyTypes.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorParams();
        message.pubKeyTypes = ((_a2 = object.pubKeyTypes) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersionParams() {
      return {
        app: BigInt(0)
      };
    }
    exports.VersionParams = {
      typeUrl: "/tendermint.types.VersionParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.app !== BigInt(0)) {
          writer.uint32(8).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersionParams();
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersionParams();
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
    function createBaseHashedParams() {
      return {
        blockMaxBytes: BigInt(0),
        blockMaxGas: BigInt(0)
      };
    }
    exports.HashedParams = {
      typeUrl: "/tendermint.types.HashedParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockMaxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHashedParams();
        if ((0, helpers_1.isSet)(object.blockMaxBytes))
          obj.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if ((0, helpers_1.isSet)(object.blockMaxGas))
          obj.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || BigInt(0)).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHashedParams();
        if (object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null) {
          message.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        }
        if (object.blockMaxGas !== void 0 && object.blockMaxGas !== null) {
          message.blockMaxGas = BigInt(object.blockMaxGas.toString());
        }
        return message;
      }
    };
    function createBaseABCIParams() {
      return {
        voteExtensionsEnableHeight: BigInt(0)
      };
    }
    exports.ABCIParams = {
      typeUrl: "/tendermint.types.ABCIParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtensionsEnableHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.voteExtensionsEnableHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtensionsEnableHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIParams();
        if ((0, helpers_1.isSet)(object.voteExtensionsEnableHeight))
          obj.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtensionsEnableHeight !== void 0 && (obj.voteExtensionsEnableHeight = (message.voteExtensionsEnableHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseABCIParams();
        if (object.voteExtensionsEnableHeight !== void 0 && object.voteExtensionsEnableHeight !== null) {
          message.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/abci/types.js
var require_types4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/abci/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponsePrepareProposal = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = exports.ResponseCheckTx = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestFinalizeBlock = exports.RequestVerifyVoteExtension = exports.RequestExtendVote = exports.RequestProcessProposal = exports.RequestPrepareProposal = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestCheckTx = exports.RequestQuery = exports.RequestInitChain = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.misbehaviorTypeToJSON = exports.misbehaviorTypeFromJSON = exports.MisbehaviorType = exports.responseVerifyVoteExtension_VerifyStatusToJSON = exports.responseVerifyVoteExtension_VerifyStatusFromJSON = exports.ResponseVerifyVoteExtension_VerifyStatus = exports.responseProcessProposal_ProposalStatusToJSON = exports.responseProcessProposal_ProposalStatusFromJSON = exports.ResponseProcessProposal_ProposalStatus = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_Result = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxType = exports.protobufPackage = void 0;
    exports.Snapshot = exports.Misbehavior = exports.ExtendedVoteInfo = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.ExecTxResult = exports.EventAttribute = exports.Event = exports.ExtendedCommitInfo = exports.CommitInfo = exports.ResponseFinalizeBlock = exports.ResponseVerifyVoteExtension = exports.ResponseExtendVote = exports.ResponseProcessProposal = void 0;
    var timestamp_1 = require_timestamp();
    var params_1 = require_params();
    var proof_1 = require_proof();
    var keys_1 = require_keys4();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType || (exports.CheckTxType = CheckTxType = {}));
    function checkTxTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports.checkTxTypeFromJSON = checkTxTypeFromJSON;
    function checkTxTypeToJSON(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.checkTxTypeToJSON = checkTxTypeToJSON;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
    function responseOfferSnapshot_ResultToJSON(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
    function responseApplySnapshotChunk_ResultToJSON(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
    var ResponseProcessProposal_ProposalStatus;
    (function(ResponseProcessProposal_ProposalStatus2) {
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["REJECT"] = 2] = "REJECT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseProcessProposal_ProposalStatus || (exports.ResponseProcessProposal_ProposalStatus = ResponseProcessProposal_ProposalStatus = {}));
    function responseProcessProposal_ProposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseProcessProposal_ProposalStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseProcessProposal_ProposalStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseProcessProposal_ProposalStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON;
    function responseProcessProposal_ProposalStatusToJSON(object) {
      switch (object) {
        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseProcessProposal_ProposalStatus.ACCEPT:
          return "ACCEPT";
        case ResponseProcessProposal_ProposalStatus.REJECT:
          return "REJECT";
        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON;
    var ResponseVerifyVoteExtension_VerifyStatus;
    (function(ResponseVerifyVoteExtension_VerifyStatus2) {
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["REJECT"] = 2] = "REJECT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseVerifyVoteExtension_VerifyStatus || (exports.ResponseVerifyVoteExtension_VerifyStatus = ResponseVerifyVoteExtension_VerifyStatus = {}));
    function responseVerifyVoteExtension_VerifyStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseVerifyVoteExtension_VerifyStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseVerifyVoteExtension_VerifyStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED;
      }
    }
    exports.responseVerifyVoteExtension_VerifyStatusFromJSON = responseVerifyVoteExtension_VerifyStatusFromJSON;
    function responseVerifyVoteExtension_VerifyStatusToJSON(object) {
      switch (object) {
        case ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseVerifyVoteExtension_VerifyStatus.ACCEPT:
          return "ACCEPT";
        case ResponseVerifyVoteExtension_VerifyStatus.REJECT:
          return "REJECT";
        case ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseVerifyVoteExtension_VerifyStatusToJSON = responseVerifyVoteExtension_VerifyStatusToJSON;
    var MisbehaviorType;
    (function(MisbehaviorType2) {
      MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
      MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      MisbehaviorType2[MisbehaviorType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MisbehaviorType || (exports.MisbehaviorType = MisbehaviorType = {}));
    function misbehaviorTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return MisbehaviorType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return MisbehaviorType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return MisbehaviorType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return MisbehaviorType.UNRECOGNIZED;
      }
    }
    exports.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON;
    function misbehaviorTypeToJSON(object) {
      switch (object) {
        case MisbehaviorType.UNKNOWN:
          return "UNKNOWN";
        case MisbehaviorType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        case MisbehaviorType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.misbehaviorTypeToJSON = misbehaviorTypeToJSON;
    function createBaseRequest() {
      return {
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports.Request = {
      typeUrl: "/tendermint.abci.Request",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.echo !== void 0) {
          exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports.RequestExtendVote.encode(message.extendVote, writer.uint32(146).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports.RequestVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(154).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports.RequestFinalizeBlock.encode(message.finalizeBlock, writer.uint32(162).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports.RequestInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports.RequestQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.prepareProposal = exports.RequestPrepareProposal.decode(reader, reader.uint32());
              break;
            case 17:
              message.processProposal = exports.RequestProcessProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.extendVote = exports.RequestExtendVote.decode(reader, reader.uint32());
              break;
            case 19:
              message.verifyVoteExtension = exports.RequestVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 20:
              message.finalizeBlock = exports.RequestFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequest();
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports.RequestEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports.RequestFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports.RequestInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports.RequestInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports.RequestQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports.RequestCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.RequestCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports.RequestListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports.RequestPrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports.RequestProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports.RequestExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports.RequestFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports.RequestPrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports.RequestProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports.RequestExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.RequestVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports.RequestFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequest();
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports.RequestEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports.RequestFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports.RequestInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports.RequestInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports.RequestQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports.RequestCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.RequestCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports.RequestListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports.RequestPrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports.RequestProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports.RequestExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports.RequestFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseRequestEcho() {
      return {
        message: ""
      };
    }
    exports.RequestEcho = {
      typeUrl: "/tendermint.abci.RequestEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseRequestFlush() {
      return {};
    }
    exports.RequestFlush = {
      typeUrl: "/tendermint.abci.RequestFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestFlush();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestFlush();
        return message;
      }
    };
    function createBaseRequestInfo() {
      return {
        version: "",
        blockVersion: BigInt(0),
        p2pVersion: BigInt(0),
        abciVersion: ""
      };
    }
    exports.RequestInfo = {
      typeUrl: "/tendermint.abci.RequestInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.blockVersion !== BigInt(0)) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (message.p2pVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        if (message.abciVersion !== "") {
          writer.uint32(34).string(message.abciVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            case 4:
              message.abciVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInfo();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.blockVersion))
          obj.blockVersion = BigInt(object.blockVersion.toString());
        if ((0, helpers_1.isSet)(object.p2pVersion))
          obj.p2pVersion = BigInt(object.p2pVersion.toString());
        if ((0, helpers_1.isSet)(object.abciVersion))
          obj.abciVersion = String(object.abciVersion);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || BigInt(0)).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || BigInt(0)).toString());
        message.abciVersion !== void 0 && (obj.abciVersion = message.abciVersion);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInfo();
        message.version = object.version ?? "";
        if (object.blockVersion !== void 0 && object.blockVersion !== null) {
          message.blockVersion = BigInt(object.blockVersion.toString());
        }
        if (object.p2pVersion !== void 0 && object.p2pVersion !== null) {
          message.p2pVersion = BigInt(object.p2pVersion.toString());
        }
        message.abciVersion = object.abciVersion ?? "";
        return message;
      }
    };
    function createBaseRequestInitChain() {
      return {
        time: timestamp_1.Timestamp.fromPartial({}),
        chainId: "",
        consensusParams: void 0,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: BigInt(0)
      };
    }
    exports.RequestInitChain = {
      typeUrl: "/tendermint.abci.RequestInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (message.initialHeight !== BigInt(0)) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInitChain();
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appStateBytes))
          obj.appStateBytes = (0, helpers_1.bytesFromBase64)(object.appStateBytes);
        if ((0, helpers_1.isSet)(object.initialHeight))
          obj.initialHeight = BigInt(object.initialHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseRequestInitChain();
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.chainId = object.chainId ?? "";
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
        if (object.initialHeight !== void 0 && object.initialHeight !== null) {
          message.initialHeight = BigInt(object.initialHeight.toString());
        }
        return message;
      }
    };
    function createBaseRequestQuery() {
      return {
        data: new Uint8Array(),
        path: "",
        height: BigInt(0),
        prove: false
      };
    }
    exports.RequestQuery = {
      typeUrl: "/tendermint.abci.RequestQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestQuery();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.prove))
          obj.prove = Boolean(object.prove);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestQuery();
        message.data = object.data ?? new Uint8Array();
        message.path = object.path ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.prove = object.prove ?? false;
        return message;
      }
    };
    function createBaseRequestCheckTx() {
      return {
        tx: new Uint8Array(),
        type: 0
      };
    }
    exports.RequestCheckTx = {
      typeUrl: "/tendermint.abci.RequestCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestCheckTx();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.type))
          obj.type = checkTxTypeFromJSON(object.type);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestCheckTx();
        message.tx = object.tx ?? new Uint8Array();
        message.type = object.type ?? 0;
        return message;
      }
    };
    function createBaseRequestCommit() {
      return {};
    }
    exports.RequestCommit = {
      typeUrl: "/tendermint.abci.RequestCommit",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestCommit();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestCommit();
        return message;
      }
    };
    function createBaseRequestListSnapshots() {
      return {};
    }
    exports.RequestListSnapshots = {
      typeUrl: "/tendermint.abci.RequestListSnapshots",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestListSnapshots();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestListSnapshots();
        return message;
      }
    };
    function createBaseRequestOfferSnapshot() {
      return {
        snapshot: void 0,
        appHash: new Uint8Array()
      };
    }
    exports.RequestOfferSnapshot = {
      typeUrl: "/tendermint.abci.RequestOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.snapshot !== void 0) {
          exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestOfferSnapshot();
        if ((0, helpers_1.isSet)(object.snapshot))
          obj.snapshot = exports.Snapshot.fromJSON(object.snapshot);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestOfferSnapshot();
        if (object.snapshot !== void 0 && object.snapshot !== null) {
          message.snapshot = exports.Snapshot.fromPartial(object.snapshot);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestLoadSnapshotChunk() {
      return {
        height: BigInt(0),
        format: 0,
        chunk: 0
      };
    }
    exports.RequestLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = Number(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunk !== void 0 && (obj.chunk = Math.round(message.chunk));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestLoadSnapshotChunk();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
      }
    };
    function createBaseRequestApplySnapshotChunk() {
      return {
        index: 0,
        chunk: new Uint8Array(),
        sender: ""
      };
    }
    exports.RequestApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestApplySnapshotChunk();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array();
        message.sender = object.sender ?? "";
        return message;
      }
    };
    function createBaseRequestPrepareProposal() {
      return {
        maxTxBytes: BigInt(0),
        txs: [],
        localLastCommit: exports.ExtendedCommitInfo.fromPartial({}),
        misbehavior: [],
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestPrepareProposal = {
      typeUrl: "/tendermint.abci.RequestPrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxTxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxTxBytes);
        }
        for (const v of message.txs) {
          writer.uint32(18).bytes(v);
        }
        if (message.localLastCommit !== void 0) {
          exports.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestPrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTxBytes = reader.int64();
              break;
            case 2:
              message.txs.push(reader.bytes());
              break;
            case 3:
              message.localLastCommit = exports.ExtendedCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestPrepareProposal();
        if ((0, helpers_1.isSet)(object.maxTxBytes))
          obj.maxTxBytes = BigInt(object.maxTxBytes.toString());
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.localLastCommit))
          obj.localLastCommit = exports.ExtendedCommitInfo.fromJSON(object.localLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxTxBytes !== void 0 && (obj.maxTxBytes = (message.maxTxBytes || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.localLastCommit !== void 0 && (obj.localLastCommit = message.localLastCommit ? exports.ExtendedCommitInfo.toJSON(message.localLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseRequestPrepareProposal();
        if (object.maxTxBytes !== void 0 && object.maxTxBytes !== null) {
          message.maxTxBytes = BigInt(object.maxTxBytes.toString());
        }
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.localLastCommit !== void 0 && object.localLastCommit !== null) {
          message.localLastCommit = exports.ExtendedCommitInfo.fromPartial(object.localLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports.Misbehavior.fromPartial(e))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestProcessProposal() {
      return {
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestProcessProposal = {
      typeUrl: "/tendermint.abci.RequestProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        if (message.proposedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestProcessProposal();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseRequestProcessProposal();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports.Misbehavior.fromPartial(e))) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestExtendVote() {
      return {
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestExtendVote = {
      typeUrl: "/tendermint.abci.RequestExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.txs) {
          writer.uint32(34).bytes(v);
        }
        if (message.proposedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports.Misbehavior.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestExtendVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.txs.push(reader.bytes());
              break;
            case 5:
              message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestExtendVote();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseRequestExtendVote();
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports.Misbehavior.fromPartial(e))) || [];
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestVerifyVoteExtension() {
      return {
        hash: new Uint8Array(),
        validatorAddress: new Uint8Array(),
        height: BigInt(0),
        voteExtension: new Uint8Array()
      };
    }
    exports.RequestVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.RequestVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(34).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestVerifyVoteExtension();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestVerifyVoteExtension();
        message.hash = object.hash ?? new Uint8Array();
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestFinalizeBlock() {
      return {
        txs: [],
        decidedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestFinalizeBlock = {
      typeUrl: "/tendermint.abci.RequestFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        if (message.decidedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.decidedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFinalizeBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.decidedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestFinalizeBlock();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.decidedLastCommit))
          obj.decidedLastCommit = exports.CommitInfo.fromJSON(object.decidedLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.decidedLastCommit !== void 0 && (obj.decidedLastCommit = message.decidedLastCommit ? exports.CommitInfo.toJSON(message.decidedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseRequestFinalizeBlock();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.decidedLastCommit !== void 0 && object.decidedLastCommit !== null) {
          message.decidedLastCommit = exports.CommitInfo.fromPartial(object.decidedLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports.Misbehavior.fromPartial(e))) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponse() {
      return {
        exception: void 0,
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports.Response = {
      typeUrl: "/tendermint.abci.Response",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exception !== void 0) {
          exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports.ResponseExtendVote.encode(message.extendVote, writer.uint32(154).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports.ResponseVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(162).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports.ResponseFinalizeBlock.encode(message.finalizeBlock, writer.uint32(170).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 17:
              message.prepareProposal = exports.ResponsePrepareProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.processProposal = exports.ResponseProcessProposal.decode(reader, reader.uint32());
              break;
            case 19:
              message.extendVote = exports.ResponseExtendVote.decode(reader, reader.uint32());
              break;
            case 20:
              message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 21:
              message.finalizeBlock = exports.ResponseFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponse();
        if ((0, helpers_1.isSet)(object.exception))
          obj.exception = exports.ResponseException.fromJSON(object.exception);
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports.ResponseEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports.ResponseFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports.ResponseInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports.ResponseInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports.ResponseQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports.ResponseCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.ResponseCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports.ResponseListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports.ResponsePrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports.ResponseProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports.ResponseExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports.ResponseFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports.ResponsePrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports.ResponseProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports.ResponseExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.ResponseVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports.ResponseFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponse();
        if (object.exception !== void 0 && object.exception !== null) {
          message.exception = exports.ResponseException.fromPartial(object.exception);
        }
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports.ResponseEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports.ResponseFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports.ResponseInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports.ResponseInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports.ResponseQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports.ResponseCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.ResponseCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports.ResponseListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports.ResponsePrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports.ResponseProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports.ResponseExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports.ResponseFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseResponseException() {
      return {
        error: ""
      };
    }
    exports.ResponseException = {
      typeUrl: "/tendermint.abci.ResponseException",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseException();
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
      }
    };
    function createBaseResponseEcho() {
      return {
        message: ""
      };
    }
    exports.ResponseEcho = {
      typeUrl: "/tendermint.abci.ResponseEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseResponseFlush() {
      return {};
    }
    exports.ResponseFlush = {
      typeUrl: "/tendermint.abci.ResponseFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseResponseFlush();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseResponseFlush();
        return message;
      }
    };
    function createBaseResponseInfo() {
      return {
        data: "",
        version: "",
        appVersion: BigInt(0),
        lastBlockHeight: BigInt(0),
        lastBlockAppHash: new Uint8Array()
      };
    }
    exports.ResponseInfo = {
      typeUrl: "/tendermint.abci.ResponseInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.appVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (message.lastBlockHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInfo();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.appVersion))
          obj.appVersion = BigInt(object.appVersion.toString());
        if ((0, helpers_1.isSet)(object.lastBlockHeight))
          obj.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        if ((0, helpers_1.isSet)(object.lastBlockAppHash))
          obj.lastBlockAppHash = (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || BigInt(0)).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || BigInt(0)).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInfo();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        if (object.appVersion !== void 0 && object.appVersion !== null) {
          message.appVersion = BigInt(object.appVersion.toString());
        }
        if (object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null) {
          message.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        }
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseInitChain() {
      return {
        consensusParams: void 0,
        validators: [],
        appHash: new Uint8Array()
      };
    }
    exports.ResponseInitChain = {
      typeUrl: "/tendermint.abci.ResponseInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInitChain();
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseResponseInitChain();
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseQuery() {
      return {
        code: 0,
        log: "",
        info: "",
        index: BigInt(0),
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: void 0,
        height: BigInt(0),
        codespace: ""
      };
    }
    exports.ResponseQuery = {
      typeUrl: "/tendermint.abci.ResponseQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseQuery();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.proofOps))
          obj.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseQuery();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.proofOps !== void 0 && object.proofOps !== null) {
          message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCheckTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports.ResponseCheckTx = {
      typeUrl: "/tendermint.abci.ResponseCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCheckTx();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseResponseCheckTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => exports.Event.fromPartial(e))) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCommit() {
      return {
        retainHeight: BigInt(0)
      };
    }
    exports.ResponseCommit = {
      typeUrl: "/tendermint.abci.ResponseCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.retainHeight !== BigInt(0)) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCommit();
        if ((0, helpers_1.isSet)(object.retainHeight))
          obj.retainHeight = BigInt(object.retainHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCommit();
        if (object.retainHeight !== void 0 && object.retainHeight !== null) {
          message.retainHeight = BigInt(object.retainHeight.toString());
        }
        return message;
      }
    };
    function createBaseResponseListSnapshots() {
      return {
        snapshots: []
      };
    }
    exports.ResponseListSnapshots = {
      typeUrl: "/tendermint.abci.ResponseListSnapshots",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.snapshots) {
          exports.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseListSnapshots();
        if (Array.isArray(object == null ? void 0 : object.snapshots))
          obj.snapshots = object.snapshots.map((e) => exports.Snapshot.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseResponseListSnapshots();
        message.snapshots = ((_a2 = object.snapshots) == null ? void 0 : _a2.map((e) => exports.Snapshot.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseOfferSnapshot() {
      return {
        result: 0
      };
    }
    exports.ResponseOfferSnapshot = {
      typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseOfferSnapshot();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseOfferSnapshot_ResultFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseOfferSnapshot();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseResponseLoadSnapshotChunk() {
      return {
        chunk: new Uint8Array()
      };
    }
    exports.ResponseLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = object.chunk ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseApplySnapshotChunk() {
      return {
        result: 0,
        refetchChunks: [],
        rejectSenders: []
      };
    }
    exports.ResponseApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
          writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseApplySnapshotChunk_ResultFromJSON(object.result);
        if (Array.isArray(object == null ? void 0 : object.refetchChunks))
          obj.refetchChunks = object.refetchChunks.map((e) => Number(e));
        if (Array.isArray(object == null ? void 0 : object.rejectSenders))
          obj.rejectSenders = object.rejectSenders.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseResponseApplySnapshotChunk();
        message.result = object.result ?? 0;
        message.refetchChunks = ((_a2 = object.refetchChunks) == null ? void 0 : _a2.map((e) => e)) || [];
        message.rejectSenders = ((_b = object.rejectSenders) == null ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseResponsePrepareProposal() {
      return {
        txs: []
      };
    }
    exports.ResponsePrepareProposal = {
      typeUrl: "/tendermint.abci.ResponsePrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponsePrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponsePrepareProposal();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseResponsePrepareProposal();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseResponseProcessProposal() {
      return {
        status: 0
      };
    }
    exports.ResponseProcessProposal = {
      typeUrl: "/tendermint.abci.ResponseProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseProcessProposal();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseProcessProposal_ProposalStatusFromJSON(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseProcessProposal();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseExtendVote() {
      return {
        voteExtension: new Uint8Array()
      };
    }
    exports.ResponseExtendVote = {
      typeUrl: "/tendermint.abci.ResponseExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtension.length !== 0) {
          writer.uint32(10).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseExtendVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseExtendVote();
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseExtendVote();
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseVerifyVoteExtension() {
      return {
        status: 0
      };
    }
    exports.ResponseVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.ResponseVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseVerifyVoteExtension();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseVerifyVoteExtension_VerifyStatusFromJSON(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseVerifyVoteExtension_VerifyStatusToJSON(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseVerifyVoteExtension();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseFinalizeBlock() {
      return {
        events: [],
        txResults: [],
        validatorUpdates: [],
        consensusParamUpdates: void 0,
        appHash: new Uint8Array()
      };
    }
    exports.ResponseFinalizeBlock = {
      typeUrl: "/tendermint.abci.ResponseFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResults) {
          exports.ExecTxResult.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.validatorUpdates) {
          exports.ValidatorUpdate.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(34).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(42).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFinalizeBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResults.push(exports.ExecTxResult.decode(reader, reader.uint32()));
              break;
            case 3:
              message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 4:
              message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseFinalizeBlock();
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.txResults))
          obj.txResults = object.txResults.map((e) => exports.ExecTxResult.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.validatorUpdates))
          obj.validatorUpdates = object.validatorUpdates.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.consensusParamUpdates))
          obj.consensusParamUpdates = params_1.ConsensusParams.fromJSON(object.consensusParamUpdates);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.txResults) {
          obj.txResults = message.txResults.map((e) => e ? exports.ExecTxResult.toJSON(e) : void 0);
        } else {
          obj.txResults = [];
        }
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseResponseFinalizeBlock();
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => exports.Event.fromPartial(e))) || [];
        message.txResults = ((_b = object.txResults) == null ? void 0 : _b.map((e) => exports.ExecTxResult.fromPartial(e))) || [];
        message.validatorUpdates = ((_c = object.validatorUpdates) == null ? void 0 : _c.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        if (object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null) {
          message.consensusParamUpdates = params_1.ConsensusParams.fromPartial(object.consensusParamUpdates);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports.CommitInfo = {
      typeUrl: "/tendermint.abci.CommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => exports.VoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseCommitInfo();
        message.round = object.round ?? 0;
        message.votes = ((_a2 = object.votes) == null ? void 0 : _a2.map((e) => exports.VoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseExtendedCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports.ExtendedCommitInfo = {
      typeUrl: "/tendermint.abci.ExtendedCommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports.ExtendedVoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports.ExtendedVoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => exports.ExtendedVoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports.ExtendedVoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseExtendedCommitInfo();
        message.round = object.round ?? 0;
        message.votes = ((_a2 = object.votes) == null ? void 0 : _a2.map((e) => exports.ExtendedVoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports.Event = {
      typeUrl: "/tendermint.abci.Event",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object == null ? void 0 : object.attributes))
          obj.attributes = object.attributes.map((e) => exports.EventAttribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseEvent();
        message.type = object.type ?? "";
        message.attributes = ((_a2 = object.attributes) == null ? void 0 : _a2.map((e) => exports.EventAttribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEventAttribute() {
      return {
        key: "",
        value: "",
        index: false
      };
    }
    exports.EventAttribute = {
      typeUrl: "/tendermint.abci.EventAttribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEventAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Boolean(object.index);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEventAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.index = object.index ?? false;
        return message;
      }
    };
    function createBaseExecTxResult() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports.ExecTxResult = {
      typeUrl: "/tendermint.abci.ExecTxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExecTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExecTxResult();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseExecTxResult();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => exports.Event.fromPartial(e))) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseTxResult() {
      return {
        height: BigInt(0),
        index: 0,
        tx: new Uint8Array(),
        result: exports.ExecTxResult.fromPartial({})
      };
    }
    exports.TxResult = {
      typeUrl: "/tendermint.abci.TxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports.ExecTxResult.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports.ExecTxResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResult();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports.ExecTxResult.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports.ExecTxResult.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResult();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array();
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports.ExecTxResult.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        power: BigInt(0)
      };
    }
    exports.Validator = {
      typeUrl: "/tendermint.abci.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseValidatorUpdate() {
      return {
        pubKey: keys_1.PublicKey.fromPartial({}),
        power: BigInt(0)
      };
    }
    exports.ValidatorUpdate = {
      typeUrl: "/tendermint.abci.ValidatorUpdate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdate();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdate();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseVoteInfo() {
      return {
        validator: exports.Validator.fromPartial({}),
        blockIdFlag: 0
      };
    }
    exports.VoteInfo = {
      typeUrl: "/tendermint.abci.VoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(24).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseExtendedVoteInfo() {
      return {
        validator: exports.Validator.fromPartial({}),
        voteExtension: new Uint8Array(),
        extensionSignature: new Uint8Array(),
        blockIdFlag: 0
      };
    }
    exports.ExtendedVoteInfo = {
      typeUrl: "/tendermint.abci.ExtendedVoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(26).bytes(message.voteExtension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(34).bytes(message.extensionSignature);
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(40).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.voteExtension = reader.bytes();
              break;
            case 4:
              message.extensionSignature = reader.bytes();
              break;
            case 5:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseMisbehavior() {
      return {
        type: 0,
        validator: exports.Validator.fromPartial({}),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        totalVotingPower: BigInt(0)
      };
    }
    exports.Misbehavior = {
      typeUrl: "/tendermint.abci.Misbehavior",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehavior();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehavior();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = misbehaviorTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = misbehaviorTypeToJSON(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehavior();
        message.type = object.type ?? 0;
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseSnapshot() {
      return {
        height: BigInt(0),
        format: 0,
        chunks: 0,
        hash: new Uint8Array(),
        metadata: new Uint8Array()
      };
    }
    exports.Snapshot = {
      typeUrl: "/tendermint.abci.Snapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSnapshot();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunks))
          obj.chunks = Number(object.chunks);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = (0, helpers_1.bytesFromBase64)(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSnapshot();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        message.metadata = object.metadata ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidatorUpdates = exports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.infractionToJSON = exports.infractionFromJSON = exports.Infraction = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    var types_2 = require_types4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus || (exports.BondStatus = BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.bondStatusToJSON = bondStatusToJSON;
    var Infraction;
    (function(Infraction2) {
      Infraction2[Infraction2["INFRACTION_UNSPECIFIED"] = 0] = "INFRACTION_UNSPECIFIED";
      Infraction2[Infraction2["INFRACTION_DOUBLE_SIGN"] = 1] = "INFRACTION_DOUBLE_SIGN";
      Infraction2[Infraction2["INFRACTION_DOWNTIME"] = 2] = "INFRACTION_DOWNTIME";
      Infraction2[Infraction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Infraction || (exports.Infraction = Infraction = {}));
    function infractionFromJSON(object) {
      switch (object) {
        case 0:
        case "INFRACTION_UNSPECIFIED":
          return Infraction.INFRACTION_UNSPECIFIED;
        case 1:
        case "INFRACTION_DOUBLE_SIGN":
          return Infraction.INFRACTION_DOUBLE_SIGN;
        case 2:
        case "INFRACTION_DOWNTIME":
          return Infraction.INFRACTION_DOWNTIME;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Infraction.UNRECOGNIZED;
      }
    }
    exports.infractionFromJSON = infractionFromJSON;
    function infractionToJSON(object) {
      switch (object) {
        case Infraction.INFRACTION_UNSPECIFIED:
          return "INFRACTION_UNSPECIFIED";
        case Infraction.INFRACTION_DOUBLE_SIGN:
          return "INFRACTION_DOUBLE_SIGN";
        case Infraction.INFRACTION_DOWNTIME:
          return "INFRACTION_DOWNTIME";
        case Infraction.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.infractionToJSON = infractionToJSON;
    function createBaseHistoricalInfo() {
      return {
        header: types_1.Header.fromPartial({}),
        valset: []
      };
    }
    exports.HistoricalInfo = {
      typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHistoricalInfo();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if (Array.isArray(object == null ? void 0 : object.valset))
          obj.valset = object.valset.map((e) => exports.Validator.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseHistoricalInfo();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        message.valset = ((_a2 = object.valset) == null ? void 0 : _a2.map((e) => exports.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return {
        rate: "",
        maxRate: "",
        maxChangeRate: ""
      };
    }
    exports.CommissionRates = {
      typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommissionRates();
        if ((0, helpers_1.isSet)(object.rate))
          obj.rate = String(object.rate);
        if ((0, helpers_1.isSet)(object.maxRate))
          obj.maxRate = String(object.maxRate);
        if ((0, helpers_1.isSet)(object.maxChangeRate))
          obj.maxChangeRate = String(object.maxChangeRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommissionRates();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
      }
    };
    function createBaseCommission() {
      return {
        commissionRates: exports.CommissionRates.fromPartial({}),
        updateTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Commission = {
      typeUrl: "/cosmos.staking.v1beta1.Commission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commissionRates !== void 0) {
          exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommission();
        if ((0, helpers_1.isSet)(object.commissionRates))
          obj.commissionRates = exports.CommissionRates.fromJSON(object.commissionRates);
        if ((0, helpers_1.isSet)(object.updateTime))
          obj.updateTime = (0, helpers_1.fromJsonTimestamp)(object.updateTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = (0, helpers_1.fromTimestamp)(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommission();
        if (object.commissionRates !== void 0 && object.commissionRates !== null) {
          message.commissionRates = exports.CommissionRates.fromPartial(object.commissionRates);
        }
        if (object.updateTime !== void 0 && object.updateTime !== null) {
          message.updateTime = timestamp_1.Timestamp.fromPartial(object.updateTime);
        }
        return message;
      }
    };
    function createBaseDescription() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports.Description = {
      typeUrl: "/cosmos.staking.v1beta1.Description",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDescription();
        if ((0, helpers_1.isSet)(object.moniker))
          obj.moniker = String(object.moniker);
        if ((0, helpers_1.isSet)(object.identity))
          obj.identity = String(object.identity);
        if ((0, helpers_1.isSet)(object.website))
          obj.website = String(object.website);
        if ((0, helpers_1.isSet)(object.securityContact))
          obj.securityContact = String(object.securityContact);
        if ((0, helpers_1.isSet)(object.details))
          obj.details = String(object.details);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDescription();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: exports.Description.fromPartial({}),
        unbondingHeight: BigInt(0),
        unbondingTime: timestamp_1.Timestamp.fromPartial({}),
        commission: exports.Commission.fromPartial({}),
        minSelfDelegation: "",
        unbondingOnHoldRefCount: BigInt(0),
        unbondingIds: []
      };
    }
    exports.Validator = {
      typeUrl: "/cosmos.staking.v1beta1.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== BigInt(0)) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(96).int64(message.unbondingOnHoldRefCount);
        }
        writer.uint32(106).fork();
        for (const v of message.unbondingIds) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            case 12:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            case 13:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.unbondingIds.push(reader.uint64());
                }
              } else {
                message.unbondingIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if ((0, helpers_1.isSet)(object.consensusPubkey))
          obj.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);
        if ((0, helpers_1.isSet)(object.jailed))
          obj.jailed = Boolean(object.jailed);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = bondStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.tokens))
          obj.tokens = String(object.tokens);
        if ((0, helpers_1.isSet)(object.delegatorShares))
          obj.delegatorShares = String(object.delegatorShares);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = exports.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.unbondingHeight))
          obj.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = (0, helpers_1.fromJsonTimestamp)(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = exports.Commission.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        if (Array.isArray(object == null ? void 0 : object.unbondingIds))
          obj.unbondingIds = object.unbondingIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || BigInt(0)).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = (0, helpers_1.fromTimestamp)(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        if (message.unbondingIds) {
          obj.unbondingIds = message.unbondingIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.unbondingIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidator();
        message.operatorAddress = object.operatorAddress ?? "";
        if (object.consensusPubkey !== void 0 && object.consensusPubkey !== null) {
          message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);
        }
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        if (object.description !== void 0 && object.description !== null) {
          message.description = exports.Description.fromPartial(object.description);
        }
        if (object.unbondingHeight !== void 0 && object.unbondingHeight !== null) {
          message.unbondingHeight = BigInt(object.unbondingHeight.toString());
        }
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = timestamp_1.Timestamp.fromPartial(object.unbondingTime);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = exports.Commission.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        message.unbondingIds = ((_a2 = object.unbondingIds) == null ? void 0 : _a2.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseValAddresses() {
      return {
        addresses: []
      };
    }
    exports.ValAddresses = {
      typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValAddresses();
        if (Array.isArray(object == null ? void 0 : object.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValAddresses();
        message.addresses = ((_a2 = object.addresses) == null ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.DVPair = {
      typeUrl: "/cosmos.staking.v1beta1.DVPair",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPair();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return {
        pairs: []
      };
    }
    exports.DVPairs = {
      typeUrl: "/cosmos.staking.v1beta1.DVPairs",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pairs) {
          exports.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPairs();
        if (Array.isArray(object == null ? void 0 : object.pairs))
          obj.pairs = object.pairs.map((e) => exports.DVPair.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDVPairs();
        message.pairs = ((_a2 = object.pairs) == null ? void 0 : _a2.map((e) => exports.DVPair.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports.DVVTriplet = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplet();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return {
        triplets: []
      };
    }
    exports.DVVTriplets = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.triplets) {
          exports.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplets();
        if (Array.isArray(object == null ? void 0 : object.triplets))
          obj.triplets = object.triplets.map((e) => exports.DVVTriplet.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDVVTriplets();
        message.triplets = ((_a2 = object.triplets) == null ? void 0 : _a2.map((e) => exports.DVVTriplet.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        shares: ""
      };
    }
    exports.Delegation = {
      typeUrl: "/cosmos.staking.v1beta1.Delegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.shares))
          obj.shares = String(object.shares);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        entries: []
      };
    }
    exports.UnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports.UnbondingDelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = ((_a2 = object.entries) == null ? void 0 : _a2.map((e) => exports.UnbondingDelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        balance: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports.UnbondingDelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        sharesDst: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports.RedelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.sharesDst))
          obj.sharesDst = String(object.sharesDst);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegation() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports.Redelegation = {
      typeUrl: "/cosmos.staking.v1beta1.Redelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports.RedelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseRedelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = ((_a2 = object.entries) == null ? void 0 : _a2.map((e) => exports.RedelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        unbondingTime: duration_1.Duration.fromPartial({}),
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: "",
        minCommissionRate: ""
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.staking.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        if (message.minCommissionRate !== "") {
          writer.uint32(50).string(message.minCommissionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            case 6:
              message.minCommissionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.maxValidators))
          obj.maxValidators = Number(object.maxValidators);
        if ((0, helpers_1.isSet)(object.maxEntries))
          obj.maxEntries = Number(object.maxEntries);
        if ((0, helpers_1.isSet)(object.historicalEntries))
          obj.historicalEntries = Number(object.historicalEntries);
        if ((0, helpers_1.isSet)(object.bondDenom))
          obj.bondDenom = String(object.bondDenom);
        if ((0, helpers_1.isSet)(object.minCommissionRate))
          obj.minCommissionRate = String(object.minCommissionRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        message.minCommissionRate !== void 0 && (obj.minCommissionRate = message.minCommissionRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);
        }
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        message.minCommissionRate = object.minCommissionRate ?? "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return {
        delegation: exports.Delegation.fromPartial({}),
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports.DelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegation !== void 0) {
          exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegation))
          obj.delegation = exports.Delegation.fromJSON(object.delegation);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse();
        if (object.delegation !== void 0 && object.delegation !== null) {
          message.delegation = exports.Delegation.fromPartial(object.delegation);
        }
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return {
        redelegationEntry: exports.RedelegationEntry.fromPartial({}),
        balance: ""
      };
    }
    exports.RedelegationEntryResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegationEntry !== void 0) {
          exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntryResponse();
        if ((0, helpers_1.isSet)(object.redelegationEntry))
          obj.redelegationEntry = exports.RedelegationEntry.fromJSON(object.redelegationEntry);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntryResponse();
        if (object.redelegationEntry !== void 0 && object.redelegationEntry !== null) {
          message.redelegationEntry = exports.RedelegationEntry.fromPartial(object.redelegationEntry);
        }
        message.balance = object.balance ?? "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return {
        redelegation: exports.Redelegation.fromPartial({}),
        entries: []
      };
    }
    exports.RedelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegation !== void 0) {
          exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationResponse();
        if ((0, helpers_1.isSet)(object.redelegation))
          obj.redelegation = exports.Redelegation.fromJSON(object.redelegation);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports.RedelegationEntryResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseRedelegationResponse();
        if (object.redelegation !== void 0 && object.redelegation !== null) {
          message.redelegation = exports.Redelegation.fromPartial(object.redelegation);
        }
        message.entries = ((_a2 = object.entries) == null ? void 0 : _a2.map((e) => exports.RedelegationEntryResponse.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePool() {
      return {
        notBondedTokens: "",
        bondedTokens: ""
      };
    }
    exports.Pool = {
      typeUrl: "/cosmos.staking.v1beta1.Pool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePool();
        if ((0, helpers_1.isSet)(object.notBondedTokens))
          obj.notBondedTokens = String(object.notBondedTokens);
        if ((0, helpers_1.isSet)(object.bondedTokens))
          obj.bondedTokens = String(object.bondedTokens);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePool();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
      }
    };
    function createBaseValidatorUpdates() {
      return {
        updates: []
      };
    }
    exports.ValidatorUpdates = {
      typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.updates) {
          types_2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.updates.push(types_2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdates();
        if (Array.isArray(object == null ? void 0 : object.updates))
          obj.updates = object.updates.map((e) => types_2.ValidatorUpdate.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.updates) {
          obj.updates = message.updates.map((e) => e ? types_2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.updates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValidatorUpdates();
        message.updates = ((_a2 = object.updates) == null ? void 0 : _a2.map((e) => types_2.ValidatorUpdate.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx13 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgCancelUnbondingDelegationResponse = exports.MsgCancelUnbondingDelegation = exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        commission: staking_1.CommissionRates.fromPartial({}),
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgCreateValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = staking_1.CommissionRates.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.pubkey))
          obj.pubkey = any_1.Any.fromJSON(object.pubkey);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = coin_1.Coin.fromJSON(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = staking_1.CommissionRates.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.pubkey !== void 0 && object.pubkey !== null) {
          message.pubkey = any_1.Any.fromPartial(object.pubkey);
        }
        if (object.value !== void 0 && object.value !== null) {
          message.value = coin_1.Coin.fromPartial(object.value);
        }
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports.MsgCreateValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateValidatorResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports.MsgEditValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgEditValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.commissionRate))
          obj.commissionRate = String(object.commissionRate);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgEditValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports.MsgEditValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgEditValidatorResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgDelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports.MsgDelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDelegateResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgBeginRedelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.MsgBeginRedelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgUndelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgUndelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({}),
        creationHeight: BigInt(0)
      };
    }
    exports.MsgCancelUnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.creationHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.creationHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegationResponse() {
      return {};
    }
    exports.MsgCancelUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCancelUnbondingDelegationResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: staking_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
        this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      CreateValidator(request) {
        const data2 = exports.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data2);
        return promise.then((data3) => exports.MsgCreateValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EditValidator(request) {
        const data2 = exports.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data2);
        return promise.then((data3) => exports.MsgEditValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegate(request) {
        const data2 = exports.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data2);
        return promise.then((data3) => exports.MsgDelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BeginRedelegate(request) {
        const data2 = exports.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data2);
        return promise.then((data3) => exports.MsgBeginRedelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Undelegate(request) {
        const data2 = exports.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data2);
        return promise.then((data3) => exports.MsgUndelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelUnbondingDelegation(request) {
        const data2 = exports.MsgCancelUnbondingDelegation.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", data2);
        return promise.then((data3) => exports.MsgCancelUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stakingTypes = void 0;
    exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
    var tx_1 = require_tx13();
    exports.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query13 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPoolResponse = exports.QueryPoolRequest = exports.QueryHistoricalInfoResponse = exports.QueryHistoricalInfoRequest = exports.QueryDelegatorValidatorResponse = exports.QueryDelegatorValidatorRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryRedelegationsResponse = exports.QueryRedelegationsRequest = exports.QueryDelegatorUnbondingDelegationsResponse = exports.QueryDelegatorUnbondingDelegationsRequest = exports.QueryDelegatorDelegationsResponse = exports.QueryDelegatorDelegationsRequest = exports.QueryUnbondingDelegationResponse = exports.QueryUnbondingDelegationRequest = exports.QueryDelegationResponse = exports.QueryDelegationRequest = exports.QueryValidatorUnbondingDelegationsResponse = exports.QueryValidatorUnbondingDelegationsRequest = exports.QueryValidatorDelegationsResponse = exports.QueryValidatorDelegationsRequest = exports.QueryValidatorResponse = exports.QueryValidatorRequest = exports.QueryValidatorsResponse = exports.QueryValidatorsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseQueryValidatorsRequest() {
      return {
        status: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsRequest();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsRequest();
        message.status = object.status ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryValidatorsResponse();
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => staking_1.Validator.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorRequest() {
      return {
        validatorAddr: ""
      };
    }
    exports.QueryValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports.QueryValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = ((_a2 = object.delegationResponses) == null ? void 0 : _a2.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a2 = object.unbondingResponses) == null ? void 0 : _a2.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationResponse() {
      return {
        delegationResponse: void 0
      };
    }
    exports.QueryDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegationResponse))
          obj.delegationResponse = staking_1.DelegationResponse.fromJSON(object.delegationResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationResponse();
        if (object.delegationResponse !== void 0 && object.delegationResponse !== null) {
          message.delegationResponse = staking_1.DelegationResponse.fromPartial(object.delegationResponse);
        }
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryUnbondingDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationResponse() {
      return {
        unbond: staking_1.UnbondingDelegation.fromPartial({})
      };
    }
    exports.QueryUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationResponse();
        if ((0, helpers_1.isSet)(object.unbond))
          obj.unbond = staking_1.UnbondingDelegation.fromJSON(object.unbond);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        if (object.unbond !== void 0 && object.unbond !== null) {
          message.unbond = staking_1.UnbondingDelegation.fromPartial(object.unbond);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = ((_a2 = object.delegationResponses) == null ? void 0 : _a2.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a2 = object.unbondingResponses) == null ? void 0 : _a2.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsRequest() {
      return {
        delegatorAddr: "",
        srcValidatorAddr: "",
        dstValidatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryRedelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.srcValidatorAddr))
          obj.srcValidatorAddr = String(object.srcValidatorAddr);
        if ((0, helpers_1.isSet)(object.dstValidatorAddr))
          obj.dstValidatorAddr = String(object.dstValidatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsResponse() {
      return {
        redelegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryRedelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.redelegationResponses))
          obj.redelegationResponses = object.redelegationResponses.map((e) => staking_1.RedelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = ((_a2 = object.redelegationResponses) == null ? void 0 : _a2.map((e) => staking_1.RedelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a2 = object.validators) == null ? void 0 : _a2.map((e) => staking_1.Validator.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryDelegatorValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports.QueryDelegatorValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoRequest() {
      return {
        height: BigInt(0)
      };
    }
    exports.QueryHistoricalInfoRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoResponse() {
      return {
        hist: void 0
      };
    }
    exports.QueryHistoricalInfoResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoResponse();
        if ((0, helpers_1.isSet)(object.hist))
          obj.hist = staking_1.HistoricalInfo.fromJSON(object.hist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse();
        if (object.hist !== void 0 && object.hist !== null) {
          message.hist = staking_1.HistoricalInfo.fromPartial(object.hist);
        }
        return message;
      }
    };
    function createBaseQueryPoolRequest() {
      return {};
    }
    exports.QueryPoolRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryPoolRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryPoolRequest();
        return message;
      }
    };
    function createBaseQueryPoolResponse() {
      return {
        pool: staking_1.Pool.fromPartial({})
      };
    }
    exports.QueryPoolResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPoolResponse();
        if ((0, helpers_1.isSet)(object.pool))
          obj.pool = staking_1.Pool.fromJSON(object.pool);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPoolResponse();
        if (object.pool !== void 0 && object.pool !== null) {
          message.pool = staking_1.Pool.fromPartial(object.pool);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: staking_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data2 = exports.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data2);
        return promise.then((data3) => exports.QueryValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Validator(request) {
        const data2 = exports.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data2);
        return promise.then((data3) => exports.QueryValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDelegations(request) {
        const data2 = exports.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data2);
        return promise.then((data3) => exports.QueryValidatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorUnbondingDelegations(request) {
        const data2 = exports.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data2);
        return promise.then((data3) => exports.QueryValidatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegation(request) {
        const data2 = exports.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data2);
        return promise.then((data3) => exports.QueryDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnbondingDelegation(request) {
        const data2 = exports.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data2);
        return promise.then((data3) => exports.QueryUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorDelegations(request) {
        const data2 = exports.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data2);
        return promise.then((data3) => exports.QueryDelegatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorUnbondingDelegations(request) {
        const data2 = exports.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data2);
        return promise.then((data3) => exports.QueryDelegatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Redelegations(request) {
        const data2 = exports.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data2);
        return promise.then((data3) => exports.QueryRedelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidator(request) {
        const data2 = exports.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      HistoricalInfo(request) {
        const data2 = exports.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data2);
        return promise.then((data3) => exports.QueryHistoricalInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Pool(request = {}) {
        const data2 = exports.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data2);
        return promise.then((data3) => exports.QueryPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupStakingExtension = setupStakingExtension;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/evidence.js
var require_evidence = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/evidence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EvidenceList = exports.LightClientAttackEvidence = exports.DuplicateVoteEvidence = exports.Evidence = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseEvidence() {
      return {
        duplicateVoteEvidence: void 0,
        lightClientAttackEvidence: void 0
      };
    }
    exports.Evidence = {
      typeUrl: "/tendermint.types.Evidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.duplicateVoteEvidence !== void 0) {
          exports.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        }
        if (message.lightClientAttackEvidence !== void 0) {
          exports.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.decode(reader, reader.uint32());
              break;
            case 2:
              message.lightClientAttackEvidence = exports.LightClientAttackEvidence.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidence();
        if ((0, helpers_1.isSet)(object.duplicateVoteEvidence))
          obj.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence);
        if ((0, helpers_1.isSet)(object.lightClientAttackEvidence))
          obj.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.duplicateVoteEvidence !== void 0 && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : void 0);
        message.lightClientAttackEvidence !== void 0 && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidence();
        if (object.duplicateVoteEvidence !== void 0 && object.duplicateVoteEvidence !== null) {
          message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence);
        }
        if (object.lightClientAttackEvidence !== void 0 && object.lightClientAttackEvidence !== null) {
          message.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence);
        }
        return message;
      }
    };
    function createBaseDuplicateVoteEvidence() {
      return {
        voteA: void 0,
        voteB: void 0,
        totalVotingPower: BigInt(0),
        validatorPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.DuplicateVoteEvidence = {
      typeUrl: "/tendermint.types.DuplicateVoteEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteA !== void 0) {
          types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteB !== void 0) {
          types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        if (message.validatorPower !== BigInt(0)) {
          writer.uint32(32).int64(message.validatorPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteA = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 2:
              message.voteB = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            case 4:
              message.validatorPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuplicateVoteEvidence();
        if ((0, helpers_1.isSet)(object.voteA))
          obj.voteA = types_1.Vote.fromJSON(object.voteA);
        if ((0, helpers_1.isSet)(object.voteB))
          obj.voteB = types_1.Vote.fromJSON(object.voteB);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.validatorPower))
          obj.validatorPower = BigInt(object.validatorPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteA !== void 0 && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : void 0);
        message.voteB !== void 0 && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.validatorPower !== void 0 && (obj.validatorPower = (message.validatorPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuplicateVoteEvidence();
        if (object.voteA !== void 0 && object.voteA !== null) {
          message.voteA = types_1.Vote.fromPartial(object.voteA);
        }
        if (object.voteB !== void 0 && object.voteB !== null) {
          message.voteB = types_1.Vote.fromPartial(object.voteB);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.validatorPower !== void 0 && object.validatorPower !== null) {
          message.validatorPower = BigInt(object.validatorPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseLightClientAttackEvidence() {
      return {
        conflictingBlock: void 0,
        commonHeight: BigInt(0),
        byzantineValidators: [],
        totalVotingPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.LightClientAttackEvidence = {
      typeUrl: "/tendermint.types.LightClientAttackEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.conflictingBlock !== void 0) {
          types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        }
        if (message.commonHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.commonHeight);
        }
        for (const v of message.byzantineValidators) {
          validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(32).int64(message.totalVotingPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
              break;
            case 2:
              message.commonHeight = reader.int64();
              break;
            case 3:
              message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            case 4:
              message.totalVotingPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightClientAttackEvidence();
        if ((0, helpers_1.isSet)(object.conflictingBlock))
          obj.conflictingBlock = types_1.LightBlock.fromJSON(object.conflictingBlock);
        if ((0, helpers_1.isSet)(object.commonHeight))
          obj.commonHeight = BigInt(object.commonHeight.toString());
        if (Array.isArray(object == null ? void 0 : object.byzantineValidators))
          obj.byzantineValidators = object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.conflictingBlock !== void 0 && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : void 0);
        message.commonHeight !== void 0 && (obj.commonHeight = (message.commonHeight || BigInt(0)).toString());
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseLightClientAttackEvidence();
        if (object.conflictingBlock !== void 0 && object.conflictingBlock !== null) {
          message.conflictingBlock = types_1.LightBlock.fromPartial(object.conflictingBlock);
        }
        if (object.commonHeight !== void 0 && object.commonHeight !== null) {
          message.commonHeight = BigInt(object.commonHeight.toString());
        }
        message.byzantineValidators = ((_a2 = object.byzantineValidators) == null ? void 0 : _a2.map((e) => validator_1.Validator.fromPartial(e))) || [];
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseEvidenceList() {
      return {
        evidence: []
      };
    }
    exports.EvidenceList = {
      typeUrl: "/tendermint.types.EvidenceList",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.evidence) {
          exports.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.evidence.push(exports.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceList();
        if (Array.isArray(object == null ? void 0 : object.evidence))
          obj.evidence = object.evidence.map((e) => exports.Evidence.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.evidence) {
          obj.evidence = message.evidence.map((e) => e ? exports.Evidence.toJSON(e) : void 0);
        } else {
          obj.evidence = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseEvidenceList();
        message.evidence = ((_a2 = object.evidence) == null ? void 0 : _a2.map((e) => exports.Evidence.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/block.js
var require_block = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Block = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var evidence_1 = require_evidence();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseBlock() {
      return {
        header: types_1.Header.fromPartial({}),
        data: types_1.Data.fromPartial({}),
        evidence: evidence_1.EvidenceList.fromPartial({}),
        lastCommit: void 0
      };
    }
    exports.Block = {
      typeUrl: "/tendermint.types.Block",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== void 0) {
          types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = types_1.Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
              break;
            case 4:
              message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlock();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = types_1.Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = evidence_1.EvidenceList.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.lastCommit))
          obj.lastCommit = types_1.Commit.fromJSON(object.lastCommit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.data !== void 0 && (obj.data = message.data ? types_1.Data.toJSON(message.data) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : void 0);
        message.lastCommit !== void 0 && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlock();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = types_1.Data.fromPartial(object.data);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = evidence_1.EvidenceList.fromPartial(object.evidence);
        }
        if (object.lastCommit !== void 0 && object.lastCommit !== null) {
          message.lastCommit = types_1.Commit.fromPartial(object.lastCommit);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchBlocksResult = exports.SearchTxsResult = exports.TxMsgData = exports.MsgData = exports.SimulationResponse = exports.Result = exports.GasInfo = exports.Attribute = exports.StringEvent = exports.ABCIMessageLog = exports.TxResponse = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var types_1 = require_types4();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.abci.v1beta1";
    function createBaseTxResponse() {
      return {
        height: BigInt(0),
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        tx: void 0,
        timestamp: "",
        events: []
      };
    }
    exports.TxResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v of message.logs) {
          exports.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResponse();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.txhash))
          obj.txhash = String(object.txhash);
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.rawLog))
          obj.rawLog = String(object.rawLog);
        if (Array.isArray(object == null ? void 0 : object.logs))
          obj.logs = object.logs.map((e) => exports.ABCIMessageLog.fromJSON(e));
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = any_1.Any.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = String(object.timestamp);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseTxResponse();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.txhash = object.txhash ?? "";
        message.codespace = object.codespace ?? "";
        message.code = object.code ?? 0;
        message.data = object.data ?? "";
        message.rawLog = object.rawLog ?? "";
        message.logs = ((_a2 = object.logs) == null ? void 0 : _a2.map((e) => exports.ABCIMessageLog.fromPartial(e))) || [];
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = any_1.Any.fromPartial(object.tx);
        }
        message.timestamp = object.timestamp ?? "";
        message.events = ((_b = object.events) == null ? void 0 : _b.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseABCIMessageLog() {
      return {
        msgIndex: 0,
        log: "",
        events: []
      };
    }
    exports.ABCIMessageLog = {
      typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          exports.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIMessageLog();
        if ((0, helpers_1.isSet)(object.msgIndex))
          obj.msgIndex = Number(object.msgIndex);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports.StringEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseABCIMessageLog();
        message.msgIndex = object.msgIndex ?? 0;
        message.log = object.log ?? "";
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => exports.StringEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStringEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports.StringEvent = {
      typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStringEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseStringEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object == null ? void 0 : object.attributes))
          obj.attributes = object.attributes.map((e) => exports.Attribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseStringEvent();
        message.type = object.type ?? "";
        message.attributes = ((_a2 = object.attributes) == null ? void 0 : _a2.map((e) => exports.Attribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAttribute() {
      return {
        key: "",
        value: ""
      };
    }
    exports.Attribute = {
      typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
      }
    };
    function createBaseGasInfo() {
      return {
        gasWanted: BigInt(0),
        gasUsed: BigInt(0)
      };
    }
    exports.GasInfo = {
      typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGasInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGasInfo();
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGasInfo();
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        return message;
      }
    };
    function createBaseResult() {
      return {
        data: new Uint8Array(),
        log: "",
        events: [],
        msgResponses: []
      };
    }
    exports.Result = {
      typeUrl: "/cosmos.base.abci.v1beta1.Result",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            case 4:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResult();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseResult();
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => types_1.Event.fromPartial(e))) || [];
        message.msgResponses = ((_b = object.msgResponses) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSimulationResponse() {
      return {
        gasInfo: exports.GasInfo.fromPartial({}),
        result: void 0
      };
    }
    exports.SimulationResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          exports.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulationResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = exports.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulationResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = exports.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseMsgData() {
      return {
        msgType: "",
        data: new Uint8Array()
      };
    }
    exports.MsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgData();
        if ((0, helpers_1.isSet)(object.msgType))
          obj.msgType = String(object.msgType);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgData();
        message.msgType = object.msgType ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxMsgData() {
      return {
        data: [],
        msgResponses: []
      };
    }
    exports.TxMsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.data) {
          exports.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports.MsgData.decode(reader, reader.uint32()));
              break;
            case 2:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxMsgData();
        if (Array.isArray(object == null ? void 0 : object.data))
          obj.data = object.data.map((e) => exports.MsgData.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseTxMsgData();
        message.data = ((_a2 = object.data) == null ? void 0 : _a2.map((e) => exports.MsgData.fromPartial(e))) || [];
        message.msgResponses = ((_b = object.msgResponses) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSearchTxsResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        txs: []
      };
    }
    exports.SearchTxsResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).uint64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v of message.txs) {
          exports.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchTxsResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => exports.TxResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSearchTxsResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => exports.TxResponse.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSearchBlocksResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        blocks: []
      };
    }
    exports.SearchBlocksResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchBlocksResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).int64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).int64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).int64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).int64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).int64(message.limit);
        }
        for (const v of message.blocks) {
          block_1.Block.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchBlocksResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.int64();
              break;
            case 2:
              message.count = reader.int64();
              break;
            case 3:
              message.pageNumber = reader.int64();
              break;
            case 4:
              message.pageTotal = reader.int64();
              break;
            case 5:
              message.limit = reader.int64();
              break;
            case 6:
              message.blocks.push(block_1.Block.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchBlocksResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object == null ? void 0 : object.blocks))
          obj.blocks = object.blocks.map((e) => block_1.Block.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.blocks) {
          obj.blocks = message.blocks.map((e) => e ? block_1.Block.toJSON(e) : void 0);
        } else {
          obj.blocks = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSearchBlocksResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.blocks = ((_a2 = object.blocks) == null ? void 0 : _a2.map((e) => block_1.Block.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceClientImpl = exports.TxDecodeAminoResponse = exports.TxDecodeAminoRequest = exports.TxEncodeAminoResponse = exports.TxEncodeAminoRequest = exports.TxEncodeResponse = exports.TxEncodeRequest = exports.TxDecodeResponse = exports.TxDecodeRequest = exports.GetBlockWithTxsResponse = exports.GetBlockWithTxsRequest = exports.GetTxResponse = exports.GetTxRequest = exports.SimulateResponse = exports.SimulateRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.GetTxsEventRequest = exports.broadcastModeToJSON = exports.broadcastModeFromJSON = exports.BroadcastMode = exports.orderByToJSON = exports.orderByFromJSON = exports.OrderBy = exports.protobufPackage = void 0;
    var tx_1 = require_tx();
    var pagination_1 = require_pagination();
    var abci_1 = require_abci();
    var types_1 = require_types3();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy || (exports.OrderBy = OrderBy = {}));
    function orderByFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports.orderByFromJSON = orderByFromJSON;
    function orderByToJSON(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.orderByToJSON = orderByToJSON;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode || (exports.BroadcastMode = BroadcastMode = {}));
    function broadcastModeFromJSON(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports.broadcastModeFromJSON = broadcastModeFromJSON;
    function broadcastModeToJSON(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.broadcastModeToJSON = broadcastModeToJSON;
    function createBaseGetTxsEventRequest() {
      return {
        events: [],
        pagination: void 0,
        orderBy: 0,
        page: BigInt(0),
        limit: BigInt(0),
        query: ""
      };
    }
    exports.GetTxsEventRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        if (message.page !== BigInt(0)) {
          writer.uint32(32).uint64(message.page);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        if (message.query !== "") {
          writer.uint32(50).string(message.query);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            case 4:
              message.page = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.query = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventRequest();
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.orderBy))
          obj.orderBy = orderByFromJSON(object.orderBy);
        if ((0, helpers_1.isSet)(object.page))
          obj.page = BigInt(object.page.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.query))
          obj.query = String(object.query);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
        message.page !== void 0 && (obj.page = (message.page || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.query !== void 0 && (obj.query = message.query);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseGetTxsEventRequest();
        message.events = ((_a2 = object.events) == null ? void 0 : _a2.map((e) => e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.orderBy = object.orderBy ?? 0;
        if (object.page !== void 0 && object.page !== null) {
          message.page = BigInt(object.page.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.query = object.query ?? "";
        return message;
      }
    };
    function createBaseGetTxsEventResponse() {
      return {
        txs: [],
        txResponses: [],
        pagination: void 0,
        total: BigInt(0)
      };
    }
    exports.GetTxsEventResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResponses) {
          abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(32).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 4:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventResponse();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.txResponses))
          obj.txResponses = object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseGetTxsEventResponse();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => tx_1.Tx.fromPartial(e))) || [];
        message.txResponses = ((_b = object.txResponses) == null ? void 0 : _b.map((e) => abci_1.TxResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
    function createBaseBroadcastTxRequest() {
      return {
        txBytes: new Uint8Array(),
        mode: 0
      };
    }
    exports.BroadcastTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = broadcastModeFromJSON(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseBroadcastTxResponse() {
      return {
        txResponse: void 0
      };
    }
    exports.BroadcastTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxResponse();
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxResponse();
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseSimulateRequest() {
      return {
        tx: void 0,
        txBytes: new Uint8Array()
      };
    }
    exports.SimulateRequest = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSimulateResponse() {
      return {
        gasInfo: void 0,
        result: void 0
      };
    }
    exports.SimulateResponse = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = abci_1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = abci_1.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = abci_1.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = abci_1.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseGetTxRequest() {
      return {
        hash: ""
      };
    }
    exports.GetTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseGetTxResponse() {
      return {
        tx: void 0,
        txResponse: void 0
      };
    }
    exports.GetTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsRequest() {
      return {
        height: BigInt(0),
        pagination: void 0
      };
    }
    exports.GetBlockWithTxsRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsResponse() {
      return {
        txs: [],
        blockId: void 0,
        block: void 0,
        pagination: void 0
      };
    }
    exports.GetBlockWithTxsResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockId !== void 0) {
          types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== void 0) {
          block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.blockId = types_1.BlockID.decode(reader, reader.uint32());
              break;
            case 3:
              message.block = block_1.Block.decode(reader, reader.uint32());
              break;
            case 4:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsResponse();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = types_1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.block))
          obj.block = block_1.Block.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        message.blockId !== void 0 && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : void 0);
        message.block !== void 0 && (obj.block = message.block ? block_1.Block.toJSON(message.block) : void 0);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseGetBlockWithTxsResponse();
        message.txs = ((_a2 = object.txs) == null ? void 0 : _a2.map((e) => tx_1.Tx.fromPartial(e))) || [];
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = types_1.BlockID.fromPartial(object.blockId);
        }
        if (object.block !== void 0 && object.block !== null) {
          message.block = block_1.Block.fromPartial(object.block);
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseTxDecodeRequest() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports.TxDecodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeResponse() {
      return {
        tx: void 0
      };
    }
    exports.TxDecodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeRequest() {
      return {
        tx: void 0
      };
    }
    exports.TxEncodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeResponse() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports.TxEncodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeResponse();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeResponse();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxEncodeAminoRequest() {
      return {
        aminoJson: ""
      };
    }
    exports.TxEncodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoRequest();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    function createBaseTxEncodeAminoResponse() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports.TxEncodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoResponse();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoRequest() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports.TxDecodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoRequest();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoResponse() {
      return {
        aminoJson: ""
      };
    }
    exports.TxDecodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoResponse();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
        this.TxDecode = this.TxDecode.bind(this);
        this.TxEncode = this.TxEncode.bind(this);
        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
      }
      Simulate(request) {
        const data2 = exports.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data2);
        return promise.then((data3) => exports.SimulateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTx(request) {
        const data2 = exports.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data2);
        return promise.then((data3) => exports.GetTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BroadcastTx(request) {
        const data2 = exports.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data2);
        return promise.then((data3) => exports.BroadcastTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTxsEvent(request) {
        const data2 = exports.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data2);
        return promise.then((data3) => exports.GetTxsEventResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetBlockWithTxs(request) {
        const data2 = exports.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data2);
        return promise.then((data3) => exports.GetBlockWithTxsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecode(request) {
        const data2 = exports.TxDecodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data2);
        return promise.then((data3) => exports.TxDecodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncode(request) {
        const data2 = exports.TxEncodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data2);
        return promise.then((data3) => exports.TxEncodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncodeAmino(request) {
        const data2 = exports.TxEncodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data2);
        return promise.then((data3) => exports.TxEncodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecodeAmino(request) {
        const data2 = exports.TxDecodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data2);
        return promise.then((data3) => exports.TxDecodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.ServiceClientImpl = ServiceClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupTxExtension = setupTxExtension;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    exports.createVestingAminoConverters = createVestingAminoConverters;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js
var require_tx14 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgCreatePeriodicVestingAccountResponse = exports.MsgCreatePeriodicVestingAccount = exports.MsgCreatePermanentLockedAccountResponse = exports.MsgCreatePermanentLockedAccount = exports.MsgCreateVestingAccountResponse = exports.MsgCreateVestingAccount = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var vesting_1 = require_vesting();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseMsgCreateVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: [],
        endTime: BigInt(0),
        delayed: false
      };
    }
    exports.MsgCreateVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(32).int64(message.endTime);
        }
        if (message.delayed === true) {
          writer.uint32(40).bool(message.delayed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.endTime = reader.int64();
              break;
            case 5:
              message.delayed = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        if ((0, helpers_1.isSet)(object.delayed))
          obj.delayed = Boolean(object.delayed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        message.delayed !== void 0 && (obj.delayed = message.delayed);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCreateVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        message.delayed = object.delayed ?? false;
        return message;
      }
    };
    function createBaseMsgCreateVestingAccountResponse() {
      return {};
    }
    exports.MsgCreateVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateVestingAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateVestingAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports.MsgCreatePermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCreatePermanentLockedAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a2 = object.amount) == null ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccountResponse() {
      return {};
    }
    exports.MsgCreatePermanentLockedAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePermanentLockedAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports.MsgCreatePeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(24).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          vesting_1.Period.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.startTime = reader.int64();
              break;
            case 4:
              message.vestingPeriods.push(vesting_1.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object == null ? void 0 : object.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => vesting_1.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? vesting_1.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = ((_a2 = object.vestingPeriods) == null ? void 0 : _a2.map((e) => vesting_1.Period.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccountResponse() {
      return {};
    }
    exports.MsgCreatePeriodicVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePeriodicVestingAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
        this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this);
        this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
      }
      CreateVestingAccount(request) {
        const data2 = exports.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data2);
        return promise.then((data3) => exports.MsgCreateVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePermanentLockedAccount(request) {
        const data2 = exports.MsgCreatePermanentLockedAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", data2);
        return promise.then((data3) => exports.MsgCreatePermanentLockedAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePeriodicVestingAccount(request) {
        const data2 = exports.MsgCreatePeriodicVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", data2);
        return promise.then((data3) => exports.MsgCreatePeriodicVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
    exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/multisignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCompactBitArray = makeCompactBitArray;
    exports.makeMultisignedTx = makeMultisignedTx;
    exports.makeMultisignedTxBytes = makeMultisignedTxBytes;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_1.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_1.TxRaw.encode(signedTx).finish());
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSearchTxQueryArray = isSearchTxQueryArray;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(type, data2) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data2);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data2);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    function pubkeyToAddress(type, data2) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data2)).toUpperCase();
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = void 0;
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    exports.fromSeconds = fromSeconds;
    exports.toSeconds = toSeconds;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    function toRfc3339WithNanoseconds(dateTime) {
      var _a2;
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = ((_a2 = dateTime.nanoseconds) == null ? void 0 : _a2.toString()) ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = makeJsonRpcId;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
  }
});

// node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/ponyfill.js"(exports, module) {
    module.exports = require_ponyfill();
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name2, value, predicate) {
      if (name2 in object) {
        if (predicate === true) {
          if (object[name2] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name2, value, true);
      } else {
        defineDataProperty(object, name2, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal2 = function() {
      return polyfill;
    };
    defineProperties(getGlobal2, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal2;
  }
});

// node_modules/.pnpm/xstream@11.14.0/node_modules/xstream/index.js
var require_xstream = __commonJS({
  "node_modules/.pnpm/xstream@11.14.0/node_modules/xstream/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports.NO = NO;
    function noop() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      }()
    );
    var Observer = (
      /** @class */
      function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      }()
    );
    var FromObservable = (
      /** @class */
      function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      }()
    );
    var Merge = (
      /** @class */
      function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var L = s.length;
          this.ac = L;
          for (var i = 0; i < L; i++)
            s[i]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s = this.insArr;
          var L = s.length;
          for (var i = 0; i < L; i++)
            s[i]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
              return;
            u._c();
          }
        };
        return Merge2;
      }()
    );
    var CombineListener = (
      /** @class */
      function() {
        function CombineListener2(i, out, p) {
          this.i = i;
          this.out = out;
          this.p = p;
          p.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p = this.p, out = this.out;
          if (out === NO)
            return;
          if (p.up(t, this.i)) {
            var b = cp(p.vals);
            out._n(b);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p = this.p;
          if (p.out === NO)
            return;
          if (--p.Nc === 0)
            p.out._c();
        };
        return CombineListener2;
      }()
    );
    var Combine = (
      /** @class */
      function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i) {
          var v = this.vals[i];
          var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
          this.vals[i] = t;
          return Nn === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var n = this.Nc = this.Nn = s.length;
          var vals = this.vals = new Array(n);
          if (n === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i = 0; i < n; i++) {
              vals[i] = NO;
              s[i]._add(new CombineListener(i, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s = this.insArr;
          var n = s.length;
          var ils = this.ils;
          for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      }()
    );
    var FromArray = (
      /** @class */
      function() {
        function FromArray2(a) {
          this.type = "fromArray";
          this.a = a;
        }
        FromArray2.prototype._start = function(out) {
          var a = this.a;
          for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      }()
    );
    var FromPromise = (
      /** @class */
      function() {
        function FromPromise2(p) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v) {
            if (prod.on) {
              out._n(v);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      }()
    );
    var Periodic = (
      /** @class */
      function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      }()
    );
    var Debug = (
      /** @class */
      function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var s = this.s, l = this.l;
          if (s !== noop) {
            try {
              s(t);
            } catch (e) {
              u._e(e);
            }
          } else if (l)
            console.log(l + ":", t);
          else
            console.log(t);
          u._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Debug2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Debug2;
      }()
    );
    var Drop = (
      /** @class */
      function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          if (this.dropped++ >= this.max)
            u._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Drop2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Drop2;
      }()
    );
    var EndWhenListener = (
      /** @class */
      function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      }()
    );
    var EndWhen = (
      /** @class */
      function() {
        function EndWhen2(o, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      }()
    );
    var Filter = (
      /** @class */
      function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO || !r)
            return;
          u._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Filter2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Filter2;
      }()
    );
    var FlattenListener = (
      /** @class */
      function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      }()
    );
    var Flatten = (
      /** @class */
      function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (!this.open && this.inner === NO)
            u._c();
        };
        Flatten2.prototype._n = function(s) {
          var u = this.out;
          if (u === NO)
            return;
          var _a2 = this, inner = _a2.inner, il = _a2.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s)._add(this.il = new FlattenListener(u, this));
        };
        Flatten2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      }()
    );
    var Fold = (
      /** @class */
      function() {
        function Fold2(f, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(this.acc = r);
        };
        Fold2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Fold2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Fold2;
      }()
    );
    var Last = (
      /** @class */
      function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Last2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (this.has) {
            u._n(this.val);
            u._c();
          } else
            u._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      }()
    );
    var MapOp = (
      /** @class */
      function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(r);
        };
        MapOp2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        MapOp2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return MapOp2;
      }()
    );
    var Remember = (
      /** @class */
      function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      }()
    );
    var ReplaceError = (
      /** @class */
      function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return ReplaceError2;
      }()
    );
    var StartWith = (
      /** @class */
      function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      }()
    );
    var Take = (
      /** @class */
      function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var m = ++this.taken;
          if (m < this.max)
            u._n(t);
          else if (m === this.max) {
            u._n(t);
            u._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Take2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Take2;
      }()
    );
    var Stream = (
      /** @class */
      function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a = this._ils;
          var L = a.length;
          if (this._d)
            this._dl._n(t);
          if (L == 1)
            a[0]._n(t);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L == 1)
            a[0]._e(err);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._e(err);
          }
          if (!this._d && L == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L == 1)
            a[0]._c();
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a = this._ils;
          var i = a.indexOf(il);
          if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x, trace) {
          if (trace.indexOf(x) !== -1)
            return true;
          else if (x.out === this)
            return true;
          else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
          else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
              if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop, _stop: noop });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s = this.map(function() {
            return projectedValue;
          });
          var op = s._prod;
          op.type = "mapTo";
          return s;
        };
        Stream2.prototype.filter = function(passes) {
          var p = this._prod;
          if (p instanceof Filter)
            return new Stream2(new Filter(and(p.f, passes), p.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      }()
    );
    exports.Stream = Stream;
    var MemoryStream = (
      /** @class */
      function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x) {
          this._v = x;
          this._has = true;
          _super.prototype._n.call(this, x);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      }(Stream)
    );
    exports.MemoryStream = MemoryStream;
    var xs = Stream;
    exports.default = xs;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = concat;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      constructor(value, callbacks) {
        __publicField(this, "callbacks");
        __publicField(this, "internalValue");
        __publicField(this, "listener");
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      get value() {
        return this.internalValue;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = dropDuplicates;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromListPromise = fromListPromise;
    exports.toListPromise = toListPromise;
    exports.firstEvent = firstEvent;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => {
            listener.error(error);
          });
        },
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => {
            reject(error);
          }
        });
      });
    }
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reducer = void 0;
    exports.countStream = countStream;
    exports.asArray = asArray;
    exports.lastValue = lastValue;
    var Reducer = class {
      constructor(stream, reducer, initState) {
        __publicField(this, "stream");
        __publicField(this, "reducer");
        __publicField(this, "state");
        // completed maintains state of stream, resolves/rejects
        // on complete or error
        __publicField(this, "completed");
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      constructor(producer) {
        __publicField(this, "updates");
        __publicField(this, "producer");
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      get value() {
        return this.producer.value;
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => {
                  subscription.unsubscribe();
                }, 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/index.js
var require_build7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.36.1/node_modules/@cosmjs/stream/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/types.js
var require_types5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = void 0;
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build7();
    var types_1 = require_types5();
    var JsonRpcClient = class {
      constructor(connection) {
        __publicField(this, "connection");
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    function isJsonCompatibleDictionary(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      return Object.values(value).every(isJsonCompatibleValue);
    }
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcId = parseJsonRpcId;
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    function parseJsonRpcRequest(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (typeof data2.jsonrpc !== "string") {
        throw new Error(`Invalid "jsonrpc" field. Must be a string.`);
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data2.jsonrpc}`);
      }
      const id = parseJsonRpcId(data2);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data2.method;
      if (typeof method !== "string") {
        throw new Error(`Invalid "method" field. Must be a string.`);
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data2.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data2.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data2.params
      };
    }
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data2.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data2.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data2.error)
      };
    }
    function parseJsonRpcSuccessResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data2.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data2.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    function parseJsonRpcResponse(data2) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data2);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data2);
      }
      return response;
    }
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/index.js
var require_build8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.36.1/node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = http;
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request, timeout) {
      const settings = {
        method,
        body: request ? JSON.stringify(request) : void 0,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: timeout ? AbortSignal.timeout(timeout) : void 0
      };
      return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    exports.hasProtocol = hasProtocol;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpBatchClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      constructor(endpoint, options = {}) {
        __publicField(this, "url");
        __publicField(this, "headers");
        __publicField(this, "options");
        __publicField(this, "timer");
        __publicField(this, "queue", []);
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval,
          httpTimeout: options.httpTimeout
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => {
          this.tick();
        }, options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        if (this.timer)
          clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests, this.options.httpTimeout).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports.HttpBatchClient = HttpBatchClient;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      constructor(endpoint, timeout) {
        __publicField(this, "url");
        __publicField(this, "headers");
        __publicField(this, "timeout");
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timeout = timeout;
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request, this.timeout));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// node_modules/.pnpm/isomorphic-ws@4.0.1_ws@7.5.10/node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/isomorphic-ws@4.0.1_ws@7.5.10/node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        __publicField(this, "connected");
        __publicField(this, "connectedResolver");
        __publicField(this, "connectedRejecter");
        __publicField(this, "socket");
        __publicField(this, "timeoutId");
        __publicField(this, "closed", false);
        __publicField(this, "url");
        __publicField(this, "messageHandler");
        __publicField(this, "errorHandler");
        __publicField(this, "openHandler");
        __publicField(this, "closeHandler");
        __publicField(this, "timeout");
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data2) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data2, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          } else {
            this.socket.send(data2);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      constructor(url, timeout = 1e4) {
        __publicField(this, "connected");
        __publicField(this, "events");
        __publicField(this, "eventProducerListener");
        __publicField(this, "socket");
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data2) {
        return this.socket.send(data2);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        __publicField(this, "connectionStatus");
        __publicField(this, "events");
        __publicField(this, "url");
        __publicField(this, "timeout");
        __publicField(this, "queue", []);
        __publicField(this, "socket");
        __publicField(this, "isProcessingQueue", false);
        __publicField(this, "eventProducerListener");
        __publicField(this, "connectionStatusProducer");
        __publicField(this, "reconnectedHandler");
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => {
          this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        });
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (_error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        __publicField(this, "connectionStatus");
        __publicField(this, "events");
        __publicField(this, "socket");
        __publicField(this, "eventProducerListener");
        __publicField(this, "unconnected", true);
        __publicField(this, "disconnected", false);
        __publicField(this, "timeoutIndex", 0);
        __publicField(this, "reconnectTimeout", null);
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => {
                this.socket.reconnect();
              }, _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/index.js
var require_build9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.36.1/node_modules/@cosmjs/socket/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build8();
    var socket_1 = require_build9();
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexpected message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      constructor(request, socket) {
        __publicField(this, "request");
        __publicField(this, "socket");
        __publicField(this, "running", false);
        __publicField(this, "subscriptions", []);
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      constructor(baseUrl, onError = defaultErrorHandler) {
        __publicField(this, "url");
        __publicField(this, "socket");
        /** Same events as in socket.events but in the format we need */
        __publicField(this, "jsonRpcResponseStream");
        // Lazily create streams and use the same stream when listening to the same query twice.
        //
        // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
        // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
        __publicField(this, "subscriptionStreams", /* @__PURE__ */ new Map());
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiToSmallInt = apiToSmallInt;
    exports.apiToBigInt = apiToBigInt;
    exports.smallIntToApi = smallIntToApi;
    var math_1 = require_build();
    var encodings_1 = require_encodings();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    function apiToBigInt(input) {
      (0, encodings_1.assertString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = createJsonRpcRequest;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag || (exports.BlockIdFlag = BlockIdFlag = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data2.finalize_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      const txResult = data2.tx_result ? decodeTxData(data2.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: data2.signatures ? (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data2.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      var _a2;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a2 = data2.evidence) == null ? void 0 : _a2.evidence) ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet38Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet38Client = class _Comet38Client {
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        __publicField(this, "client");
        this.client = client;
      }
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet38Client = Comet38Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertNotEmpty)(data2.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      var _a2;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a2 = data2.evidence) == null ? void 0 : _a2.evidence) ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        __publicField(this, "client");
        this.client = client;
      }
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests3();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data2.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      var _a2;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a2 = data2.evidence) == null ? void 0 : _a2.evidence) ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        __publicField(this, "client");
        this.client = client;
      }
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint37Client = Tendermint37Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTendermint34Client = isTendermint34Client;
    exports.isTendermint37Client = isTendermint37Client;
    exports.isComet38Client = isComet38Client;
    exports.connectComet = connectComet;
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.") || version.startsWith("1.0.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.36.1/node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types6();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/stargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StargateClient = exports.BroadcastTxError = exports.TimeoutError = void 0;
    exports.isDeliverTxFailure = isDeliverTxFailure;
    exports.isDeliverTxSuccess = isDeliverTxSuccess;
    exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        __publicField(this, "txId");
        this.txId = txId;
      }
    };
    exports.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    var BroadcastTxError = class extends Error {
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        __publicField(this, "code");
        __publicField(this, "codespace");
        __publicField(this, "log");
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports.BroadcastTxError = BroadcastTxError;
    var StargateClient = class _StargateClient {
      constructor(cometClient, options) {
        __publicField(this, "cometClient");
        __publicField(this, "queryClient");
        __publicField(this, "chainId");
        __publicField(this, "accountParser");
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a2;
        let delegatedAmount;
        try {
          delegatedAmount = (_a2 = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) == null ? void 0 : _a2.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.StargateClient = StargateClient;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
    exports.createDefaultAminoConverters = createDefaultAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_1.createAuthzAminoConverters)(),
        ...(0, modules_1.createBankAminoConverters)(),
        ...(0, modules_1.createDistributionAminoConverters)(),
        ...(0, modules_1.createGovAminoConverters)(),
        ...(0, modules_1.createStakingAminoConverters)(),
        ...(0, modules_1.createIbcAminoConverters)(),
        ...(0, modules_1.createFeegrantAminoConverters)(),
        ...(0, modules_1.createVestingAminoConverters)()
      };
    }
    var SigningStargateClient = class _SigningStargateClient extends stargateclient_1.StargateClient {
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        __publicField(this, "registry");
        __publicField(this, "broadcastTimeoutMs");
        __publicField(this, "broadcastPollIntervalMs");
        __publicField(this, "signer");
        __publicField(this, "aminoTypes");
        __publicField(this, "gasPrice");
        // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
        // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
        __publicField(this, "defaultGasMultiplier", 1.4);
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningStargateClient = SigningStargateClient;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/index.js
var require_build11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.36.1/node_modules/@cosmjs/stargate/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
    exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

export {
  require_build2 as require_build,
  require_build as require_build2,
  require_binary,
  require_helpers,
  require_any,
  require_signing,
  require_coin,
  require_tx,
  require_build3,
  require_build4,
  require_build5,
  require_build6,
  require_pagination,
  require_tx4 as require_tx2,
  require_tx13 as require_tx3,
  require_abci,
  require_build10 as require_build7,
  require_build11 as require_build8
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

hash-wasm/dist/index.esm.js:
  (*!
   * hash-wasm (https://www.npmjs.com/package/hash-wasm)
   * (c) Dani Biro
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-A6MSFE4Q.js.map
